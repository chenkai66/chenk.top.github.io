<!DOCTYPE html>



<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode（七）—— 动态规划入门 |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"zh-CN","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode（七）—— 动态规划入门</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-07-06 00:00:00</span>
        <span class="mobile">2023-07-06 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>9k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>36 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>动态规划（Dynamic Programming，简称 DP）是算法竞赛和 LeetCode
中最重要也最常考的算法思想之一。很多看似复杂的问题，一旦识别出 DP
的本质，就能用简洁的状态转移方程优雅地解决。本文将从零开始，带你理解动态规划的核心思想，掌握
DP 的三步骤解题法，并通过经典一维、二维 DP
问题深入实践，最后探讨状态压缩、复杂度分析等进阶话题。</p>
<span id="more"></span>
<h2 id="什么是动态规划">什么是动态规划</h2>
<p>动态规划本质上是一种<strong>用空间换时间</strong>的优化技术。它通过保存已计算子问题的结果，避免重复计算，从而将指数级的时间复杂度降低到多项式级别。</p>
<h3 id="核心思想最优子结构与重叠子问题">核心思想：最优子结构与重叠子问题</h3>
<p>动态规划能成立，需要满足两个关键性质：</p>
<p><strong>1. 最优子结构（Optimal Substructure）</strong></p>
<p>一个问题的最优解包含其子问题的最优解。换句话说，如果我们知道了所有子问题的最优解，就能构造出原问题的最优解。</p>
<p>举个例子：要计算从 A 到 C 的最短路径，如果路径经过 B，那么 A→B 和 B→C
都必须是各自段的最短路径。如果 A→B 不是最短的，那么整条路径 A→B→C
也不可能是最短的。</p>
<p><strong>2. 重叠子问题（Overlapping Subproblems）</strong></p>
<p>在递归求解过程中，同一个子问题会被多次计算。比如计算斐波那契数列时，<code>fib(5)</code>
需要计算 <code>fib(4)</code> 和 <code>fib(3)</code>，而
<code>fib(4)</code> 又需要计算 <code>fib(3)</code> 和
<code>fib(2)</code>，<code>fib(3)</code> 被重复计算了。</p>
<p>动态规划通过记忆化（Memoization）或自底向上的表格填充，确保每个子问题只计算一次。</p>
<h3 id="动态规划-vs-递归-vs-记忆化">动态规划 vs 递归 vs 记忆化</h3>
<p>很多初学者会混淆这三个概念，这里做个清晰的对比：</p>
<p><strong>递归（Recursion）</strong>：函数调用自身，但可能重复计算子问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib_recursive</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib_recursive(n-<span class="number">1</span>) + fib_recursive(n-<span class="number">2</span>)  <span class="comment"># 大量重复计算</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O(2^n)\)</span>，空间复杂度：<span class="math inline">\(O(n)\)</span>（递归栈）</p>
<p><strong>记忆化递归（Memoization）</strong>：在递归基础上加缓存，避免重复计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">memo = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib_memo</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    memo[n] = fib_memo(n-<span class="number">1</span>) + fib_memo(n-<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span>，空间复杂度：<span class="math inline">\(O(n)\)</span></p>
<p><strong>动态规划（自底向上）</strong>：用循环从最小子问题开始，逐步构建到原问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib_dp</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span>，空间复杂度：<span class="math inline">\(O(n)\)</span>（可优化到 <span class="math inline">\(O(1)\)</span>）</p>
<p><strong>选择建议</strong>：</p>
<ul>
<li>如果子问题重叠明显，优先考虑 DP</li>
<li>如果递归思路更直观，先用记忆化递归验证，再改写成 DP</li>
<li>自底向上的 DP 通常空间效率更高，且可以进一步优化</li>
</ul>
<h2 id="dp-解题三步骤">DP 解题三步骤</h2>
<p>掌握这三步，大部分 DP 问题都能迎刃而解：</p>
<h3 id="步骤一定义状态">步骤一：定义状态</h3>
<p>状态就是问题的子问题。通常用 <code>dp[i]</code> 或
<code>dp[i][j]</code> 表示某个条件下的最优值。</p>
<p><strong>关键问题</strong>：<code>dp[i]</code> 到底表示什么？</p>
<p>常见模式：</p>
<ul>
<li><code>dp[i]</code>：前 i 个元素的最优解</li>
<li><code>dp[i]</code>：以第 i 个元素结尾的最优解</li>
<li><code>dp[i][j]</code>：前 i 个元素在 j 条件下的最优解</li>
</ul>
<p><strong>技巧</strong>：先想清楚“如果我知道
<code>dp[i-1]</code>，我能推出 <code>dp[i]</code>
吗？”如果答案是肯定的，状态定义就对了。</p>
<h3 id="步骤二找状态转移方程">步骤二：找状态转移方程</h3>
<p>这是 DP 的核心。状态转移方程描述了如何从已知状态推导出未知状态。</p>
<p>一般形式：<code>dp[i] = f(dp[i-1], dp[i-2], ..., 其他条件)</code></p>
<p><strong>推导思路</strong>： 1. 考虑 <code>dp[i]</code> 的所有可能来源
2. 找出最优的选择 3. 用数学表达式表示</p>
<h3 id="步骤三确定初始值边界条件">步骤三：确定初始值（边界条件）</h3>
<p>初始值决定了 DP 的起点。通常是最小的子问题，或者边界情况。</p>
<p>常见初始值：</p>
<ul>
<li><code>dp[0] = 0</code> 或 <code>dp[0] = 1</code></li>
<li><code>dp[1] = 某个值</code></li>
<li><code>dp[i][0] = 初始值</code>（二维 DP）</li>
</ul>
<p><strong>注意</strong>：初始值设置错误会导致整个 DP
结果错误，务必仔细检查。</p>
<h2 id="一维动态规划经典问题">一维动态规划经典问题</h2>
<h3 id="问题一爬楼梯climbing-stairs">问题一：爬楼梯（Climbing
Stairs）</h3>
<p><strong>LeetCode 70</strong>：假设你正在爬楼梯。需要 n
阶你才能到达楼顶。每次你可以爬 1 或 2
个台阶。你有多少种不同的方法可以爬到楼顶？</p>
<p><strong>示例</strong>：</p>
<ul>
<li>输入：<code>n = 3</code></li>
<li>输出：<code>3</code>（1+1+1、1+2、2+1）</li>
</ul>
<p><strong>约束条件</strong>：</p>
<ul>
<li><span class="math inline">\(1 \leq n \leq 45\)</span></li>
</ul>
<h2 id="问题分析">问题分析</h2>
<p>爬楼梯是动态规划最经典的入门问题。要到达第 <span class="math inline">\(n\)</span> 阶，只有两种可能：从第 <span class="math inline">\(n-1\)</span> 阶爬1步，或从第 <span class="math inline">\(n-2\)</span> 阶爬2步。</p>
<p><strong>核心洞察</strong>：</p>
<p>到达第 <span class="math inline">\(n\)</span> 阶的方法数 = 到达第
<span class="math inline">\(n-1\)</span> 阶的方法数 + 到达第 <span class="math inline">\(n-2\)</span> 阶的方法数</p>
<p>这是因为： - 到达 <span class="math inline">\(n-1\)</span>
阶的每种方法都可以再爬1步到达 <span class="math inline">\(n\)</span> 阶
- 到达 <span class="math inline">\(n-2\)</span>
阶的每种方法都可以再爬2步到达 <span class="math inline">\(n\)</span>
阶</p>
<h2 id="解题思路">解题思路</h2>
<p><strong>DP三步骤分析</strong>：</p>
<ol type="1">
<li><strong>状态定义</strong>：<code>dp[i]</code> 表示到达第 <span class="math inline">\(i\)</span> 阶的方法数</li>
<li><strong>状态转移</strong>：<code>dp[i] = dp[i-1] + dp[i-2]</code>（从前一阶或前两阶到达）</li>
<li><strong>初始值</strong>：
<ul>
<li><code>dp[0] = 1</code>（在起点，一种方法：不动）</li>
<li><code>dp[1] = 1</code>（到达第一阶，一种方法：爬1步）</li>
</ul></li>
</ol>
<p><strong>为什么是斐波那契数列</strong>：</p>
<p>状态转移方程 <code>dp[i] = dp[i-1] + dp[i-2]</code>
与斐波那契数列的递推公式相同。因此，到达第 <span class="math inline">\(n\)</span> 阶的方法数等于第 <span class="math inline">\(n+1\)</span> 个斐波那契数。</p>
<h2 id="复杂度分析">复杂度分析</h2>
<p><strong>基础版本</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，需要计算 <code>dp[0]</code> 到
<code>dp[n]</code>，共 <span class="math inline">\(n+1\)</span>
个状态</li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，需要长度为 <span class="math inline">\(n+1\)</span> 的数组</li>
</ul>
<p><strong>优化版本</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，不变</li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span>，只用两个变量存储前两个状态</li>
</ul>
<p><strong>复杂度证明</strong>：</p>
<p>每个状态 <code>dp[i]</code> 只计算一次，每次计算只需要 <span class="math inline">\(O(1)\)</span>
时间（查表和加法），因此总时间复杂度为 <span class="math inline">\(O(n)\)</span>。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算到达第n阶的方法数</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        算法步骤：</span></span><br><span class="line"><span class="string">        1. 初始化dp数组，长度为n+1</span></span><br><span class="line"><span class="string">        2. 设置初始值：dp[0] = 1, dp[1] = 1</span></span><br><span class="line"><span class="string">        3. 从i=2开始循环到n：</span></span><br><span class="line"><span class="string">           a. 计算dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line"><span class="string">        4. 返回dp[n]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        边界条件：</span></span><br><span class="line"><span class="string">        - n=0: 返回1（在起点）</span></span><br><span class="line"><span class="string">        - n=1: 返回1（只有一种方法）</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        优化技巧：</span></span><br><span class="line"><span class="string">        - 空间优化：只需前两个状态，用两个变量代替数组</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        变量含义：</span></span><br><span class="line"><span class="string">        - dp[i]: 到达第i阶的方法数</span></span><br><span class="line"><span class="string">        - prev2: dp[i-2]，前前一个状态</span></span><br><span class="line"><span class="string">        - prev1: dp[i-1]，前一个状态</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 基础版本：使用数组</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment"># 起点</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>  <span class="comment"># 第一阶</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p><strong>空间优化版本</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    空间优化：O(1)空间复杂度</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    优化原理：</span></span><br><span class="line"><span class="string">    - dp[i]只依赖dp[i-1]和dp[i-2]</span></span><br><span class="line"><span class="string">    - 用两个变量prev2和prev1代替整个数组</span></span><br><span class="line"><span class="string">    - 滚动更新：prev2 &lt;- prev1, prev1 &lt;- curr</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    prev2 = <span class="number">1</span>  <span class="comment"># dp[0]</span></span><br><span class="line">    prev1 = <span class="number">1</span>  <span class="comment"># dp[1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        curr = prev1 + prev2  <span class="comment"># dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">        prev2, prev1 = prev1, curr  <span class="comment"># 滚动更新</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure>
<p><strong>算法原理</strong>：</p>
<p><strong>为什么可以空间优化</strong>：</p>
<p>观察状态转移方程 <code>dp[i] = dp[i-1] + dp[i-2]</code>，计算
<code>dp[i]</code> 时只需要知道 <code>dp[i-1]</code> 和
<code>dp[i-2]</code>，不需要更早的状态。因此，只需要两个变量存储最近两个状态即可。</p>
<p><strong>滚动更新机制</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始：prev2=1(dp[0]), prev1=1(dp[1])</span><br><span class="line">i=2: curr=1+1=2, 更新：prev2=1, prev1=2</span><br><span class="line">i=3: curr=2+1=3, 更新：prev2=2, prev1=3</span><br><span class="line">i=4: curr=3+2=5, 更新：prev2=3, prev1=5</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>常见错误</strong>：</p>
<h3 id="错误一初始值设置错误">错误一：初始值设置错误</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>  <span class="comment"># 应该是1</span></span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment"># 在起点有1种方法（不动）</span></span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>  <span class="comment"># 到达第一阶有1种方法</span></span><br></pre></td></tr></table></figure>
<h3 id="错误二滚动更新顺序错误">错误二：滚动更新顺序错误</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误</span></span><br><span class="line">prev1 = curr</span><br><span class="line">prev2 = prev1  <span class="comment"># 此时prev1已经是curr了！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line">prev2, prev1 = prev1, curr  <span class="comment"># 同时更新，避免覆盖</span></span><br></pre></td></tr></table></figure>
<h3 id="问题二打家劫舍house-robber">问题二：打家劫舍（House
Robber）</h3>
<p><strong>LeetCode
198</strong>：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>输入：<code>nums = [2,7,9,3,1]</code></li>
<li>输出：<code>12</code>（偷窃1号、3号、5号房屋，金额 = 2 + 9 + 1 =
12）</li>
</ul>
<p><strong>约束条件</strong>：</p>
<ul>
<li><span class="math inline">\(1 \leq \texttt{nums.length} \leq
100\)</span></li>
<li><span class="math inline">\(0 \leq \texttt{nums[i]} \leq
400\)</span></li>
</ul>
<h2 id="问题分析-1">问题分析</h2>
<p>打家劫舍问题是典型的"选或不选"决策问题。对于每间房屋，需要在"偷"和"不偷"之间做出选择，目标是最大化总金额。</p>
<p><strong>核心挑战</strong>：</p>
<ol type="1">
<li><strong>约束条件</strong>：不能偷相邻的两间房屋（会触发警报）</li>
<li><strong>最优决策</strong>：如何在满足约束的前提下最大化收益</li>
<li><strong>状态转移</strong>：当前决策如何影响后续决策</li>
</ol>
<p><strong>关键洞察</strong>：</p>
<p>对于第 <span class="math inline">\(i\)</span> 间房屋，有两种选择： 1.
<strong>偷</strong>：获得 <code>nums[i]</code>，但不能偷第 <span class="math inline">\(i-1\)</span> 间，最大金额 =
<code>nums[i] + dp[i-2]</code> 2.
<strong>不偷</strong>：不获得金额，但可以偷第 <span class="math inline">\(i-1\)</span> 间，最大金额 =
<code>dp[i-1]</code></p>
<p>选择两者中的最大值。</p>
<h2 id="解题思路-1">解题思路</h2>
<p><strong>DP三步骤分析</strong>：</p>
<ol type="1">
<li><strong>状态定义</strong>：<code>dp[i]</code> 表示偷窃前 <span class="math inline">\(i\)</span> 间房屋能获得的最大金额</li>
<li><strong>状态转移</strong>：<code>dp[i] = max(dp[i-1], nums[i-1] + dp[i-2])</code>
<ul>
<li><code>dp[i-1]</code>：不偷第 <span class="math inline">\(i\)</span>
间，继承前 <span class="math inline">\(i-1\)</span> 间的最优解</li>
<li><code>nums[i-1] + dp[i-2]</code>：偷第 <span class="math inline">\(i\)</span> 间，加上前 <span class="math inline">\(i-2\)</span> 间的最优解</li>
</ul></li>
<li><strong>初始值</strong>：
<ul>
<li><code>dp[0] = 0</code>（没有房屋，金额为0）</li>
<li><code>dp[1] = nums[0]</code>（只有一间房屋，偷它）</li>
</ul></li>
</ol>
<p><strong>为什么这样可行</strong>：</p>
<p>动态规划的核心是<strong>最优子结构</strong>。如果我们知道了偷窃前
<span class="math inline">\(i-1\)</span> 间和前 <span class="math inline">\(i-2\)</span> 间的最优解，就能推导出偷窃前 <span class="math inline">\(i\)</span> 间的最优解。</p>
<h2 id="复杂度分析-1">复杂度分析</h2>
<p><strong>基础版本</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，需要计算 <span class="math inline">\(n\)</span> 个状态</li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，需要长度为 <span class="math inline">\(n+1\)</span> 的数组</li>
</ul>
<p><strong>优化版本</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，不变</li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span>，只用两个变量</li>
</ul>
<p><strong>复杂度证明</strong>：</p>
<p>每个状态只计算一次，每次计算只需要 <span class="math inline">\(O(1)\)</span>
时间（两次数组访问、一次比较、一次赋值），因此总时间复杂度为 <span class="math inline">\(O(n)\)</span>。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算不触发警报的最大偷窃金额</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        算法步骤：</span></span><br><span class="line"><span class="string">        1. 初始化dp数组，dp[i]表示偷窃前i间房屋的最大金额</span></span><br><span class="line"><span class="string">        2. 设置初始值：dp[0] = 0, dp[1] = nums[0]</span></span><br><span class="line"><span class="string">        3. 从i=2开始循环到n：</span></span><br><span class="line"><span class="string">           a. 选择1：不偷第i间，dp[i] = dp[i-1]</span></span><br><span class="line"><span class="string">           b. 选择2：偷第i间，dp[i] = nums[i-1] + dp[i-2]</span></span><br><span class="line"><span class="string">           c. 取两者最大值</span></span><br><span class="line"><span class="string">        4. 返回dp[n]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        边界条件：</span></span><br><span class="line"><span class="string">        - n=0: 返回0（无房屋）</span></span><br><span class="line"><span class="string">        - n=1: 返回nums[0]（只有一间）</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        优化技巧：</span></span><br><span class="line"><span class="string">        - 空间优化：dp[i]只依赖dp[i-1]和dp[i-2]，用两个变量</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        变量含义：</span></span><br><span class="line"><span class="string">        - dp[i]: 偷窃前i间房屋能获得的最大金额</span></span><br><span class="line"><span class="string">        - prev2: dp[i-2]，前前一间的最优解</span></span><br><span class="line"><span class="string">        - prev1: dp[i-1]，前一间的最优解</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 基础版本</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>  <span class="comment"># 没有房屋</span></span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>]  <span class="comment"># 只有第一间房屋</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 选择1：不偷第i间房屋</span></span><br><span class="line">            not_rob = dp[i-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 选择2：偷第i间房屋（不能偷第i-1间）</span></span><br><span class="line">            rob = nums[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">            <span class="comment"># 取最大值</span></span><br><span class="line">            dp[i] = <span class="built_in">max</span>(not_rob, rob)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p><strong>常见错误</strong>：</p>
<h3 id="错误一状态定义错误">错误一：状态定义错误</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：dp[i]表示&quot;是否偷第i间&quot;</span></span><br><span class="line">dp[i] = nums[i] <span class="keyword">if</span> 偷 <span class="keyword">else</span> <span class="number">0</span>  <span class="comment"># 没有考虑前面房屋的最优解</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确：dp[i]表示&quot;前i间的最大金额&quot;</span></span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], nums[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p><strong>变种：打家劫舍 II（环形）</strong></p>
<p><strong>LeetCode
213</strong>：如果房屋围成一圈（第一间和最后一间相邻），需要分两种情况：
1. 偷第一间，不偷最后一间：计算 <code>nums[0:n-1]</code> 2.
不偷第一间，可以偷最后一间：计算 <code>nums[1:n]</code></p>
<p>取两者最大值。</p>
<h3 id="问题三买卖股票的最佳时机best-time-to-buy-and-sell-stock">问题三：买卖股票的最佳时机（Best
Time to Buy and Sell Stock）</h3>
<p><strong>LeetCode 121</strong>：给定一个数组
<code>prices</code>，它的第 i 个元素 <code>prices[i]</code>
表示一支给定股票第 i
天的价格。你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p><strong>分析</strong>：</p>
<p>对于第 i 天，有两种状态： 1. 持有股票：可能是今天买入，或者之前就持有
2. 不持有股票：可能是今天卖出，或者之前就不持有</p>
<p><strong>状态定义</strong>：</p>
<ul>
<li><code>dp[i][0]</code>：第 i 天不持有股票的最大利润</li>
<li><code>dp[i][1]</code>：第 i 天持有股票的最大利润</li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code>（今天不持有
= 昨天不持有 或 今天卖出）</li>
<li><code>dp[i][1] = max(dp[i-1][1], -prices[i])</code>（今天持有 =
昨天持有 或 今天买入）</li>
</ul>
<p><strong>初始值</strong>：</p>
<ul>
<li><code>dp[0][0] = 0</code>（第一天不持有，利润为 0）</li>
<li><code>dp[0][1] = -prices[0]</code>（第一天持有，即买入，利润为负）</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">prices</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(prices)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>]  <span class="comment"># 最后一天不持有股票的最大利润</span></span><br></pre></td></tr></table></figure>
<p><strong>空间优化</strong>：由于只依赖前一天的状态，可以用两个变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">prices</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    hold = -prices[<span class="number">0</span>]  <span class="comment"># 持有股票</span></span><br><span class="line">    not_hold = <span class="number">0</span>       <span class="comment"># 不持有股票</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">        not_hold = <span class="built_in">max</span>(not_hold, hold + prices[i])</span><br><span class="line">        hold = <span class="built_in">max</span>(hold, -prices[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> not_hold</span><br></pre></td></tr></table></figure>
<p><strong>更直观的解法</strong>：记录到第 i
天为止的最低买入价，计算今天卖出的利润：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">prices</span>):</span><br><span class="line">    min_price = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    max_profit = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">        min_price = <span class="built_in">min</span>(min_price, price)</span><br><span class="line">        max_profit = <span class="built_in">max</span>(max_profit, price - min_price)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
</ul>
<h2 id="二维动态规划经典问题">二维动态规划经典问题</h2>
<h3 id="问题一最长公共子序列longest-common-subsequence">问题一：最长公共子序列（Longest
Common Subsequence）</h3>
<p><strong>LeetCode 1143</strong>：给定两个字符串 <code>text1</code> 和
<code>text2</code>，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回
0。</p>
<p><strong>子序列定义</strong>：字符串的一个子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p><strong>分析</strong>：</p>
<p>对于两个字符串，比较 <code>text1[i]</code> 和
<code>text2[j]</code>：</p>
<ul>
<li>如果相等：公共子序列长度 +1，继续比较 <code>text1[i+1]</code> 和
<code>text2[j+1]</code></li>
<li>如果不等：要么跳过 <code>text1[i]</code>，要么跳过
<code>text2[j]</code>，取最大值</li>
</ul>
<p><strong>状态定义</strong>：<code>dp[i][j]</code> 表示
<code>text1[0:i]</code> 和 <code>text2[0:j]</code>
的最长公共子序列长度。</p>
<p><strong>状态转移方程</strong>： <span class="math display">\[dp[i][j]
= \begin{cases}
dp[i-1][j-1] + 1 &amp; \text{if } text1[i-1] == text2[j-1] \\
\max(dp[i-1][j], dp[i][j-1]) &amp; \text{otherwise}
\end{cases}\]</span></p>
<p><strong>初始值</strong>：</p>
<ul>
<li><code>dp[0][j] = 0</code>（空字符串与任何字符串的公共子序列长度为
0）</li>
<li><code>dp[i][0] = 0</code></li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">text1, text2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<p><strong>空间优化</strong>：由于 <code>dp[i][j]</code> 只依赖
<code>dp[i-1][j-1]</code>、<code>dp[i-1][j]</code> 和
<code>dp[i][j-1]</code>，可以用一维数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">text1, text2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">    prev = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    curr = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>]:</span><br><span class="line">                curr[j] = prev[j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr[j] = <span class="built_in">max</span>(prev[j], curr[j-<span class="number">1</span>])</span><br><span class="line">        prev, curr = curr, prev</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prev[n]</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(m \times n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(\min(m,
n))\)</span>（优化后）</li>
</ul>
<h3 id="问题二编辑距离edit-distance">问题二：编辑距离（Edit
Distance）</h3>
<p><strong>LeetCode 72</strong>：给你两个单词 <code>word1</code> 和
<code>word2</code>，请返回将 <code>word1</code> 转换成
<code>word2</code>
所使用的最少操作数。你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>分析</strong>：</p>
<p>对于 <code>word1[i]</code> 和 <code>word2[j]</code>，有三种操作： 1.
<strong>插入</strong>：在 <code>word1</code> 中插入
<code>word2[j]</code>，相当于 <code>word2</code>
前移，<code>dp[i][j] = dp[i][j-1] + 1</code> 2.
<strong>删除</strong>：删除 <code>word1[i]</code>，相当于
<code>word1</code> 前移，<code>dp[i][j] = dp[i-1][j] + 1</code> 3.
<strong>替换</strong>：如果 <code>word1[i] != word2[j]</code>，替换
<code>word1[i]</code> 为
<code>word2[j]</code>，<code>dp[i][j] = dp[i-1][j-1] + 1</code>；如果相等，不需要操作，<code>dp[i][j] = dp[i-1][j-1]</code></p>
<p><strong>状态定义</strong>：<code>dp[i][j]</code> 表示将
<code>word1[0:i]</code> 转换成 <code>word2[0:j]</code>
所需的最少操作数。</p>
<p><strong>状态转移方程</strong>： <span class="math display">\[dp[i][j]
= \begin{cases}
dp[i-1][j-1] &amp; \text{if } word1[i-1] == word2[j-1] \\
\min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 &amp; \text{otherwise}
\end{cases}\]</span></p>
<p><strong>初始值</strong>：</p>
<ul>
<li><code>dp[0][j] = j</code>（将空字符串转换为 <code>word2[0:j]</code>
需要 j 次插入）</li>
<li><code>dp[i][0] = i</code>（将 <code>word1[0:i]</code>
转换为空字符串需要 i 次删除）</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">word1, word2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        dp[i][<span class="number">0</span>] = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = j</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 填充 DP 表</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(</span><br><span class="line">                    dp[i-<span class="number">1</span>][j],      <span class="comment"># 删除</span></span><br><span class="line">                    dp[i][j-<span class="number">1</span>],      <span class="comment"># 插入</span></span><br><span class="line">                    dp[i-<span class="number">1</span>][j-<span class="number">1</span>]     <span class="comment"># 替换</span></span><br><span class="line">                ) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<p><strong>空间优化</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">word1, word2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">    prev = <span class="built_in">list</span>(<span class="built_in">range</span>(n + <span class="number">1</span>))</span><br><span class="line">    curr = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        curr[<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                curr[j] = prev[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr[j] = <span class="built_in">min</span>(prev[j], curr[j-<span class="number">1</span>], prev[j-<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        prev, curr = curr, prev</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prev[n]</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(m \times n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(\min(m,
n))\)</span>（优化后）</li>
</ul>
<h3 id="问题三0-1-背包问题0-1-knapsack">问题三：0-1 背包问题（0-1
Knapsack）</h3>
<p><strong>经典问题</strong>：有 n 个物品，第 i 个物品的重量为
<code>weight[i]</code>，价值为 <code>value[i]</code>。有一个容量为 W
的背包，问如何选择物品放入背包，使得背包中物品的总价值最大？每个物品只能选择一次（0-1
背包）。</p>
<p><strong>分析</strong>：</p>
<p>对于第 i 个物品，有两种选择： 1.
<strong>不选</strong>：价值不变，<code>dp[i][w] = dp[i-1][w]</code> 2.
<strong>选</strong>：如果
<code>w &gt;= weight[i]</code>，<code>dp[i][w] = dp[i-1][w-weight[i]] + value[i]</code></p>
<p>选择两者中的最大值。</p>
<p><strong>状态定义</strong>：<code>dp[i][w]</code> 表示前 i
个物品在容量为 w 的背包中能获得的最大价值。</p>
<p><strong>状态转移方程</strong>： <span class="math display">\[dp[i][w]
= \begin{cases}
dp[i-1][w] &amp; \text{if } w &lt; weight[i] \\
\max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i]) &amp; \text{otherwise}
\end{cases}\]</span></p>
<p><strong>初始值</strong>：</p>
<ul>
<li><code>dp[0][w] = 0</code>（没有物品，价值为 0）</li>
<li><code>dp[i][0] = 0</code>（容量为 0，价值为 0）</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_01</span>(<span class="params">weight, value, W</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(weight)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (W + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> w &lt; weight[i-<span class="number">1</span>]:</span><br><span class="line">                dp[i][w] = dp[i-<span class="number">1</span>][w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(</span><br><span class="line">                    dp[i-<span class="number">1</span>][w],</span><br><span class="line">                    dp[i-<span class="number">1</span>][w - weight[i-<span class="number">1</span>]] + value[i-<span class="number">1</span>]</span><br><span class="line">                )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n][W]</span><br></pre></td></tr></table></figure>
<p><strong>空间优化（一维数组）</strong>：</p>
<p>关键点：需要<strong>逆序</strong>遍历容量，避免覆盖还未使用的
<code>dp[w-weight[i]]</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_01</span>(<span class="params">weight, value, W</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(weight)</span><br><span class="line">    dp = [<span class="number">0</span>] * (W + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(W, weight[i] - <span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 逆序</span></span><br><span class="line">            dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weight[i]] + value[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[W]</span><br></pre></td></tr></table></figure>
<p><strong>为什么逆序？</strong></p>
<p>如果正序遍历，<code>dp[w]</code> 更新时会用到
<code>dp[w-weight[i]]</code>，但这个值可能已经被当前物品更新过了，相当于同一个物品被用了两次（完全背包问题）。逆序可以保证
<code>dp[w-weight[i]]</code> 是上一轮（前 i-1 个物品）的结果。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(n \times W)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(W)\)</span>（优化后）</li>
</ul>
<p><strong>变种：完全背包</strong></p>
<p>如果每个物品可以选择无限次，只需将容量循环改为正序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_unbounded</span>(<span class="params">weight, value, W</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(weight)</span><br><span class="line">    dp = [<span class="number">0</span>] * (W + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(weight[i], W + <span class="number">1</span>):  <span class="comment"># 正序</span></span><br><span class="line">            dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weight[i]] + value[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[W]</span><br></pre></td></tr></table></figure>
<h2 id="状态压缩优化">状态压缩优化</h2>
<p>当 DP 状态只依赖前几个状态时，可以用滚动数组或位运算压缩空间。</p>
<h3 id="滚动数组">滚动数组</h3>
<p><strong>一维压缩</strong>：如果 <code>dp[i]</code> 只依赖
<code>dp[i-1]</code> 和 <code>dp[i-2]</code>，用两个变量即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 爬楼梯的空间优化版本</span></span><br><span class="line">prev2, prev1 = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    curr = prev1 + prev2</span><br><span class="line">    prev2, prev1 = prev1, curr</span><br></pre></td></tr></table></figure>
<p><strong>二维压缩</strong>：如果 <code>dp[i][j]</code> 只依赖
<code>dp[i-1][...]</code>，用两个一维数组交替使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LCS 的空间优化版本</span></span><br><span class="line">prev = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">curr = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 计算 curr[j]</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    prev, curr = curr, prev</span><br></pre></td></tr></table></figure>
<h3 id="位运算压缩">位运算压缩</h3>
<p>当状态可以用布尔值表示时（如“选或不选”），可以用整数的二进制位表示状态集合。</p>
<p><strong>例子：旅行商问题（TSP）的简化版</strong></p>
<p><code>dp[mask][i]</code> 表示访问过 <code>mask</code>
表示的城市的集合，当前在城市 i 的最短路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tsp_dp</span>(<span class="params">graph</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(graph)</span><br><span class="line">    <span class="comment"># dp[mask][i]: 访问过 mask 中的城市，当前在城市 i 的最短路径</span></span><br><span class="line">    dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n)]</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>  <span class="comment"># 从城市 0 开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> mask <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1</span> &lt;&lt; n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (mask &amp; (<span class="number">1</span> &lt;&lt; i)):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> mask &amp; (<span class="number">1</span> &lt;&lt; j):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                new_mask = mask | (<span class="number">1</span> &lt;&lt; j)</span><br><span class="line">                dp[new_mask][j] = <span class="built_in">min</span>(</span><br><span class="line">                    dp[new_mask][j],</span><br><span class="line">                    dp[mask][i] + graph[i][j]</span><br><span class="line">                )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i] + graph[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br></pre></td></tr></table></figure>
<h2 id="时间空间复杂度分析">时间空间复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<p>DP 的时间复杂度通常是：<strong>状态数 ×
每个状态的转移次数</strong></p>
<ul>
<li>一维 DP：通常 <span class="math inline">\(O(n)\)</span> 或 <span class="math inline">\(O(n \times k)\)</span>（k
是转移时需要考虑的状态数）</li>
<li>二维 DP：通常 <span class="math inline">\(O(m \times n)\)</span> 或
<span class="math inline">\(O(m \times n \times k)\)</span></li>
</ul>
<p><strong>优化技巧</strong>：</p>
<ul>
<li>减少状态数：合并等价状态</li>
<li>减少转移次数：用数据结构（如单调队列、线段树）优化转移</li>
</ul>
<h3 id="空间复杂度">空间复杂度</h3>
<ul>
<li>基础版本：<span class="math inline">\(O(n)\)</span> 或 <span class="math inline">\(O(m \times n)\)</span></li>
<li>空间优化后：通常可以降到 <span class="math inline">\(O(1)\)</span>
或 <span class="math inline">\(O(\min(m, n))\)</span></li>
</ul>
<p><strong>优化技巧</strong>：</p>
<ul>
<li>滚动数组：只保留必要的状态</li>
<li>状态压缩：用位运算表示状态集合</li>
<li>降维：将二维 DP 优化为一维</li>
</ul>
<h2 id="动态规划解题技巧总结">动态规划解题技巧总结</h2>
<h3 id="识别-dp-问题">1. 识别 DP 问题</h3>
<p><strong>特征</strong>：</p>
<ul>
<li>求最优解（最大值、最小值）</li>
<li>可以分解为子问题</li>
<li>子问题有重叠</li>
<li>满足最优子结构</li>
</ul>
<p><strong>常见题型</strong>：</p>
<ul>
<li>路径问题（不同路径、最小路径和）</li>
<li>序列问题（最长递增子序列、最长公共子序列）</li>
<li>背包问题（0-1 背包、完全背包）</li>
<li>字符串问题（编辑距离、回文串）</li>
<li>区间 DP（石子合并、括号匹配）</li>
</ul>
<h3 id="状态定义技巧">2. 状态定义技巧</h3>
<p><strong>一维状态</strong>：</p>
<ul>
<li><code>dp[i]</code>：以第 i 个元素结尾</li>
<li><code>dp[i]</code>：前 i 个元素</li>
</ul>
<p><strong>二维状态</strong>：</p>
<ul>
<li><code>dp[i][j]</code>：两个序列的前 i/j 个元素</li>
<li><code>dp[i][j]</code>：区间 [i, j]</li>
<li><code>dp[i][j]</code>：在位置 (i, j)</li>
</ul>
<p><strong>多维状态</strong>：</p>
<ul>
<li><code>dp[i][j][k]</code>：三个维度（如：天数、交易次数、持有状态）</li>
</ul>
<h3 id="状态转移方程推导">3. 状态转移方程推导</h3>
<p><strong>思考步骤</strong>： 1. 考虑 <code>dp[i]</code> 的所有可能来源
2. 列出所有转移方式 3. 找出最优选择 4. 用数学表达式表示</p>
<p><strong>常见转移模式</strong>：</p>
<ul>
<li>线性转移：<code>dp[i] = f(dp[i-1], dp[i-2], ...)</code></li>
<li>区间转移：<code>dp[i][j] = f(dp[i][k], dp[k+1][j])</code></li>
<li>树形转移：<code>dp[u] = f(dp[v1], dp[v2], ...)</code>（树形
DP）</li>
</ul>
<h3 id="边界条件处理">4. 边界条件处理</h3>
<p><strong>常见边界</strong>：</p>
<ul>
<li>空序列：<code>dp[0] = 0</code> 或 <code>dp[0] = 1</code></li>
<li>单个元素：<code>dp[1] = 初始值</code></li>
<li>二维 DP：第一行和第一列</li>
</ul>
<p><strong>注意</strong>：边界条件错误会导致整个 DP
失败，务必仔细检查。</p>
<h3 id="空间优化">5. 空间优化</h3>
<p><strong>何时优化</strong>：</p>
<ul>
<li>状态只依赖前几个状态</li>
<li>内存限制严格</li>
<li>需要提升代码效率</li>
</ul>
<p><strong>优化方法</strong>：</p>
<ul>
<li>滚动数组</li>
<li>降维（二维→一维）</li>
<li>状态压缩（位运算）</li>
</ul>
<h2 id="qa-动态规划常见问题">❓ Q&amp;A: 动态规划常见问题</h2>
<h3 id="q1-如何判断一个问题是否可以用动态规划解决">Q1:
如何判断一个问题是否可以用动态规划解决？</h3>
<p><strong>A</strong>: 检查是否满足两个条件： 1.
<strong>最优子结构</strong>：问题的最优解包含子问题的最优解 2.
<strong>重叠子问题</strong>：递归求解时会有重复计算</p>
<p>如果满足，就可以用
DP。如果不确定，先写递归版本，如果发现大量重复计算，就改用 DP。</p>
<h3 id="q2-动态规划和贪心算法有什么区别">Q2:
动态规划和贪心算法有什么区别？</h3>
<p><strong>A</strong>:</p>
<ul>
<li><strong>贪心</strong>：每一步都做当前最优选择，不回溯。适用于局部最优能导致全局最优的问题（如最小生成树、最短路径的某些变种）。</li>
<li><strong>DP</strong>：会考虑所有可能的选择，通过比较得出最优解。适用于需要全局最优的问题。</li>
</ul>
<p><strong>关键区别</strong>：贪心不需要保存子问题的解，DP 需要。</p>
<h3 id="q3-什么时候用记忆化递归什么时候用自底向上的-dp">Q3:
什么时候用记忆化递归，什么时候用自底向上的 DP？</h3>
<p><strong>A</strong>:</p>
<ul>
<li><strong>记忆化递归</strong>：思路更直观，适合验证想法。但递归有栈空间开销，可能栈溢出。</li>
<li><strong>自底向上
DP</strong>：效率更高，可以空间优化。适合生产环境。</li>
</ul>
<p><strong>建议</strong>：先用记忆化递归验证，再改写成 DP。</p>
<h3 id="q4-如何优化-dp-的空间复杂度">Q4: 如何优化 DP 的空间复杂度？</h3>
<p><strong>A</strong>: 1.
<strong>滚动数组</strong>：如果只依赖前几个状态，用变量或小数组代替大数组
2. <strong>降维</strong>：二维 DP 优化为一维（注意遍历顺序） 3.
<strong>状态压缩</strong>：用位运算表示状态集合 4.
<strong>只保留必要状态</strong>：如果某些状态永远不会用到，不计算它们</p>
<h3 id="q5-为什么-0-1-背包的空间优化要逆序遍历">Q5: 为什么 0-1
背包的空间优化要逆序遍历？</h3>
<p><strong>A</strong>:
因为每个物品只能选一次。如果正序遍历，<code>dp[w]</code> 更新时会用到
<code>dp[w-weight[i]]</code>，但这个值可能已经被当前物品更新过了，相当于同一个物品被用了两次。逆序可以保证
<code>dp[w-weight[i]]</code> 是上一轮（前 i-1 个物品）的结果。</p>
<h3 id="q6-如何调试-dp-问题">Q6: 如何调试 DP 问题？</h3>
<p><strong>A</strong>: 1. <strong>打印 DP
表</strong>：看每个状态的值是否正确 2.
<strong>检查初始值</strong>：确保边界条件正确 3.
<strong>验证转移方程</strong>：手动计算几个小例子 4.
<strong>对比递归版本</strong>：如果递归版本正确，DP
版本应该得到相同结果</p>
<h3 id="q7-dp-的时间复杂度可以进一步优化吗">Q7: DP
的时间复杂度可以进一步优化吗？</h3>
<p><strong>A</strong>: 可以。常见优化方法：</p>
<ul>
<li><strong>单调队列/栈</strong>：优化转移的查找过程（如滑动窗口最大值）</li>
<li><strong>线段树/树状数组</strong>：快速查询区间最值</li>
<li><strong>斜率优化</strong>：将转移方程转化为斜率形式，用单调队列维护凸包</li>
<li><strong>四边形不等式</strong>：区间 DP 的优化技巧</li>
</ul>
<h3 id="q8-如何确定状态定义的维度">Q8: 如何确定状态定义的维度？</h3>
<p><strong>A</strong>: 看问题需要哪些信息才能唯一确定一个子问题：</p>
<ul>
<li>如果只需要位置信息：一维 <code>dp[i]</code></li>
<li>如果需要两个序列的位置：二维 <code>dp[i][j]</code></li>
<li>如果需要额外条件（如背包容量、交易次数）：增加维度</li>
</ul>
<p><strong>原则</strong>：维度越少越好，但必须能完整描述子问题。</p>
<h3 id="q9-遇到-dp-问题没有思路怎么办">Q9: 遇到 DP
问题没有思路怎么办？</h3>
<p><strong>A</strong>: 1. <strong>先写暴力递归</strong>：理解问题的本质
2. <strong>找规律</strong>：观察小规模例子的解 3.
<strong>画状态转移图</strong>：可视化状态之间的关系 4.
<strong>类比经典问题</strong>：看看是否类似背包、LCS、编辑距离等 5.
<strong>从简单到复杂</strong>：先解决简化版本，再逐步增加约束</p>
<h3 id="q10-动态规划可以解决所有最优化问题吗">Q10:
动态规划可以解决所有最优化问题吗？</h3>
<p><strong>A</strong>: 不能。DP
只适用于满足最优子结构和重叠子问题的问题。以下情况不适合 DP：</p>
<ul>
<li><strong>贪心可解</strong>：局部最优即全局最优（如最小生成树）</li>
<li><strong>无重叠子问题</strong>：分治法更合适（如归并排序）</li>
<li><strong>状态空间太大</strong>：需要其他方法（如启发式算法、近似算法）</li>
</ul>
<p><strong>总结</strong>：DP
是强大的工具，但不是万能的。要根据问题特点选择最合适的算法。</p>
<h2 id="变体与扩展问题">变体与扩展问题</h2>
<h3 id="变体一区间-dp">变体一：区间 DP</h3>
<p>区间 DP 是二维 DP 的一种特殊形式，状态定义为 <code>dp[i][j]</code>
表示区间 <code>[i, j]</code> 的最优解。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>状态转移通常从小区间到大区间</li>
<li>需要枚举分割点 <code>k</code>，将区间 <code>[i, j]</code> 分割为
<code>[i, k]</code> 和 <code>[k+1, j]</code></li>
</ul>
<p><strong>经典问题</strong>：</p>
<ul>
<li><ol start="312" type="1">
<li>戳气球：<code>dp[i][j]</code> 表示戳破区间 <code>[i, j]</code>
内所有气球能获得的最大分数</li>
</ol></li>
<li><ol start="516" type="1">
<li>最长回文子序列：<code>dp[i][j]</code> 表示 <code>s[i:j+1]</code>
的最长回文子序列长度</li>
</ol></li>
<li><ol start="5" type="1">
<li>最长回文子串：也可以用区间 DP 解决</li>
</ol></li>
</ul>
<p><strong>模板代码</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 区间 DP 模板</span></span><br><span class="line">n = <span class="built_in">len</span>(nums)</span><br><span class="line">dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 枚举区间长度</span></span><br><span class="line"><span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - length + <span class="number">1</span>):</span><br><span class="line">        j = i + length - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 枚举分割点</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, j):</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k] + dp[k+<span class="number">1</span>][j] + cost(i, k, j))</span><br></pre></td></tr></table></figure></p>
<h3 id="变体二树形-dp">变体二：树形 DP</h3>
<p>树形 DP 是在树结构上进行的动态规划，通常需要 DFS 遍历树。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>状态定义与树的节点相关</li>
<li>状态转移需要考虑子节点的状态</li>
<li>通常需要后序遍历（先处理子节点，再处理当前节点）</li>
</ul>
<p><strong>经典问题</strong>：</p>
<ul>
<li><ol start="337" type="1">
<li>打家劫舍 III：在二叉树上打家劫舍</li>
</ol></li>
<li><ol start="124" type="1">
<li>二叉树中的最大路径和：<code>dp[node]</code> 表示以 <code>node</code>
为起点的最大路径和</li>
</ol></li>
<li><ol start="543" type="1">
<li>二叉树的直径：通过树形 DP 计算最长路径</li>
</ol></li>
</ul>
<p><strong>模板代码</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_dp</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> base_case</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理左子树和右子树</span></span><br><span class="line">    left_result = tree_dp(node.left)</span><br><span class="line">    right_result = tree_dp(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据子节点状态更新当前节点状态</span></span><br><span class="line">    dp[node] = combine(left_result, right_result, node.val)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[node]</span><br></pre></td></tr></table></figure></p>
<h3 id="变体三状态压缩-dp">变体三：状态压缩 DP</h3>
<p>当状态可以用布尔值表示时，可以用整数的二进制位压缩状态，常用于旅行商问题（TSP）等。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>状态数是指数级的，但可以通过位运算优化</li>
<li>适用于状态空间较小但需要枚举所有状态的问题</li>
</ul>
<p><strong>经典问题</strong>：</p>
<ul>
<li>旅行商问题（TSP）：<code>dp[mask][i]</code> 表示访问过
<code>mask</code> 中的城市，当前在城市 <code>i</code> 的最短路径</li>
<li><ol start="464" type="1">
<li>我能赢吗：用位压缩表示已选择的数字</li>
</ol></li>
<li><ol start="698" type="1">
<li>划分为k个相等的子集：用位压缩表示已选择的元素</li>
</ol></li>
</ul>
<p><strong>技巧</strong>：</p>
<ul>
<li>用 <code>mask &amp; (1 &lt;&lt; i)</code> 检查第 <code>i</code>
位是否为 1</li>
<li>用 <code>mask | (1 &lt;&lt; i)</code> 将第 <code>i</code> 位设为
1</li>
<li>用 <code>mask ^ (1 &lt;&lt; i)</code> 翻转第 <code>i</code> 位</li>
</ul>
<h3 id="变体四数位-dp">变体四：数位 DP</h3>
<p>数位 DP
用于解决与数字的每一位相关的问题，如统计满足条件的数字个数。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>通常需要处理数字的上界</li>
<li>状态包括：当前位数、是否达到上界、前导零等</li>
</ul>
<p><strong>经典问题</strong>：</p>
<ul>
<li><ol start="233" type="1">
<li>数字 1 的个数：统计 1 到 n 中数字 1 出现的次数</li>
</ol></li>
<li><ol start="902" type="1">
<li>最大为 N 的数字组合：统计可以用给定数字组合成的数字个数</li>
</ol></li>
</ul>
<h2 id="常见错误与调试技巧">常见错误与调试技巧</h2>
<h3 id="错误一状态定义不清晰">错误一：状态定义不清晰</h3>
<p><strong>问题</strong>：<code>dp[i]</code>
的含义不明确，导致状态转移方程错误。</p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>明确 <code>dp[i]</code> 表示什么（以第 i 个元素结尾？前 i
个元素？）</li>
<li>用注释说明状态定义</li>
<li>先写递归版本，再改写成 DP</li>
</ul>
<h3 id="错误二状态转移方程遗漏情况">错误二：状态转移方程遗漏情况</h3>
<p><strong>问题</strong>：只考虑了部分转移情况，导致结果错误。</p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>列出所有可能的转移方式</li>
<li>检查是否考虑了所有边界情况</li>
<li>用具体例子验证转移方程</li>
</ul>
<h3 id="错误三初始值设置错误">错误三：初始值设置错误</h3>
<p><strong>问题</strong>：初始值设置不当，导致后续计算错误。</p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>明确最小子问题的解</li>
<li>检查边界条件（空数组、单个元素等）</li>
<li>用具体例子验证初始值</li>
</ul>
<h3 id="错误四数组越界">错误四：数组越界</h3>
<p><strong>问题</strong>：访问 <code>dp[i-k]</code> 时，<code>i-k</code>
可能为负数。</p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>检查数组访问是否越界</li>
<li>使用条件判断保护数组访问</li>
<li>考虑是否需要调整数组大小（如 <code>dp[n+1]</code>）</li>
</ul>
<h3 id="调试技巧">调试技巧</h3>
<ol type="1">
<li><p><strong>打印 DP 表</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;dp[<span class="subst">&#123;i&#125;</span>] = <span class="subst">&#123;dp[i]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>对比递归版本</strong>：如果递归版本正确，DP
版本应该得到相同结果</p></li>
<li><p><strong>手动计算小例子</strong>：用纸笔计算几个小规模例子，验证
DP 过程</p></li>
<li><p><strong>使用断言</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> dp[i] &gt;= <span class="number">0</span>, <span class="string">f&quot;dp[<span class="subst">&#123;i&#125;</span>] should be non-negative&quot;</span></span><br><span class="line"><span class="keyword">assert</span> dp[i] &lt;= max_value, <span class="string">f&quot;dp[<span class="subst">&#123;i&#125;</span>] exceeds maximum&quot;</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="实战建议">实战建议</h2>
<h3 id="如何快速识别-dp-问题">如何快速识别 DP 问题</h3>
<p>看到以下特征时，考虑动态规划： 1.
<strong>求最优解</strong>：最大值、最小值、最长、最短等 2.
<strong>可以分解为子问题</strong>：问题可以分解为相似的子问题 3.
<strong>有重叠子问题</strong>：递归求解时会有重复计算 4.
<strong>满足最优子结构</strong>：子问题的最优解能构成原问题的最优解</p>
<h3 id="解题步骤总结">解题步骤总结</h3>
<ol type="1">
<li><strong>理解问题</strong>：明确问题要求什么</li>
<li><strong>定义状态</strong>：<code>dp[i]</code> 或
<code>dp[i][j]</code> 表示什么</li>
<li><strong>找状态转移</strong>：如何从已知状态推导出未知状态</li>
<li><strong>确定初始值</strong>：最小子问题的解</li>
<li><strong>写代码</strong>：实现 DP 算法</li>
<li><strong>优化空间</strong>：如果可能，进行空间优化</li>
</ol>
<h3 id="经典问题分类">经典问题分类</h3>
<p><strong>一维 DP</strong>：</p>
<ul>
<li><ol start="70" type="1">
<li>爬楼梯</li>
</ol></li>
<li><ol start="198" type="1">
<li>打家劫舍</li>
</ol></li>
<li><ol start="121" type="1">
<li>买卖股票的最佳时机</li>
</ol></li>
</ul>
<p><strong>二维 DP</strong>：</p>
<ul>
<li><ol start="1143" type="1">
<li>最长公共子序列</li>
</ol></li>
<li><ol start="72" type="1">
<li>编辑距离</li>
</ol></li>
<li><ol start="64" type="1">
<li>最小路径和</li>
</ol></li>
</ul>
<p><strong>背包问题</strong>：</p>
<ul>
<li>0-1 背包</li>
<li>完全背包</li>
<li>多重背包</li>
</ul>
<p><strong>区间 DP</strong>：</p>
<ul>
<li><ol start="312" type="1">
<li>戳气球</li>
</ol></li>
<li><ol start="516" type="1">
<li>最长回文子序列</li>
</ol></li>
</ul>
<p><strong>树形 DP</strong>：</p>
<ul>
<li><ol start="337" type="1">
<li>打家劫舍 III</li>
</ol></li>
<li><ol start="124" type="1">
<li>二叉树中的最大路径和</li>
</ol></li>
</ul>
<h3 id="性能优化建议">性能优化建议</h3>
<ol type="1">
<li><p><strong>空间优化</strong>：</p>
<ul>
<li>如果只依赖前几个状态，用滚动数组</li>
<li>二维 DP 优化为一维（注意遍历顺序）</li>
</ul></li>
<li><p><strong>时间优化</strong>：</p>
<ul>
<li>减少不必要的状态计算</li>
<li>使用数据结构优化状态转移（如单调队列、线段树）</li>
</ul></li>
<li><p><strong>代码优化</strong>：</p>
<ul>
<li>合并相似逻辑</li>
<li>使用更高效的数据结构</li>
</ul></li>
</ol>
<h2 id="总结">总结</h2>
<p>动态规划是算法竞赛和 LeetCode 中的核心技能。掌握 DP 的关键在于：</p>
<ol type="1">
<li><strong>理解核心思想</strong>：最优子结构和重叠子问题</li>
<li><strong>掌握三步骤</strong>：定义状态、找转移方程、确定初始值</li>
<li><strong>多练习经典问题</strong>：从一维到二维，从简单到复杂</li>
<li><strong>学会优化</strong>：空间优化、时间优化、状态压缩</li>
</ol>
<p>希望本文能帮助你建立对动态规划的清晰认识。记住，DP
不是死记硬背模板，而是理解问题的本质，找到状态之间的转移关系。多练习，多思考，你一定能掌握这门艺术！</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>本文标题：LeetCode（七）—— 动态规划入门</li>
        <li>本文作者：Chen Kai</li>
        <li>创建时间：2023-07-06 00:00:00</li>
        <li>
            本文链接：https://www.chenk.top/LeetCode%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/LAMP-%E4%B8%8E%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LAMP 与阿里云服务器详解</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/LLM%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%B8%8E%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LLM工作流与应用架构：企业级实战指南</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情赞美帅气伟大的ck吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- 由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">1.</span> <span class="nav-text">什么是动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E4%B8%8E%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.</span> <span class="nav-text">核心思想：最优子结构与重叠子问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-vs-%E9%80%92%E5%BD%92-vs-%E8%AE%B0%E5%BF%86%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">动态规划 vs 递归 vs 记忆化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dp-%E8%A7%A3%E9%A2%98%E4%B8%89%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.</span> <span class="nav-text">DP 解题三步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%80%E5%AE%9A%E4%B9%89%E7%8A%B6%E6%80%81"><span class="nav-number">2.1.</span> <span class="nav-text">步骤一：定义状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C%E6%89%BE%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">步骤二：找状态转移方程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%89%E7%A1%AE%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%80%BC%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.3.</span> <span class="nav-text">步骤三：确定初始值（边界条件）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">一维动态规划经典问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%E7%88%AC%E6%A5%BC%E6%A2%AFclimbing-stairs"><span class="nav-number">3.1.</span> <span class="nav-text">问题一：爬楼梯（Climbing
Stairs）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">问题分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">5.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">6.</span> <span class="nav-text">复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%80%E5%88%9D%E5%A7%8B%E5%80%BC%E8%AE%BE%E7%BD%AE%E9%94%99%E8%AF%AF"><span class="nav-number">6.1.</span> <span class="nav-text">错误一：初始值设置错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BA%8C%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0%E9%A1%BA%E5%BA%8F%E9%94%99%E8%AF%AF"><span class="nav-number">6.2.</span> <span class="nav-text">错误二：滚动更新顺序错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Dhouse-robber"><span class="nav-number">6.3.</span> <span class="nav-text">问题二：打家劫舍（House
Robber）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-1"><span class="nav-number">7.</span> <span class="nav-text">问题分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1"><span class="nav-number">8.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="nav-number">9.</span> <span class="nav-text">复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%80%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF"><span class="nav-number">9.1.</span> <span class="nav-text">错误一：状态定义错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%89%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAbest-time-to-buy-and-sell-stock"><span class="nav-number">9.2.</span> <span class="nav-text">问题三：买卖股票的最佳时机（Best
Time to Buy and Sell Stock）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="nav-number">10.</span> <span class="nav-text">二维动态规划经典问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97longest-common-subsequence"><span class="nav-number">10.1.</span> <span class="nav-text">问题一：最长公共子序列（Longest
Common Subsequence）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BBedit-distance"><span class="nav-number">10.2.</span> <span class="nav-text">问题二：编辑距离（Edit
Distance）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%890-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%980-1-knapsack"><span class="nav-number">10.3.</span> <span class="nav-text">问题三：0-1 背包问题（0-1
Knapsack）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96"><span class="nav-number">11.</span> <span class="nav-text">状态压缩优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="nav-number">11.1.</span> <span class="nav-text">滚动数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8E%8B%E7%BC%A9"><span class="nav-number">11.2.</span> <span class="nav-text">位运算压缩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">12.</span> <span class="nav-text">时间空间复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">12.1.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">12.2.</span> <span class="nav-text">空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93"><span class="nav-number">13.</span> <span class="nav-text">动态规划解题技巧总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%86%E5%88%AB-dp-%E9%97%AE%E9%A2%98"><span class="nav-number">13.1.</span> <span class="nav-text">1. 识别 DP 问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89%E6%8A%80%E5%B7%A7"><span class="nav-number">13.2.</span> <span class="nav-text">2. 状态定义技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">13.3.</span> <span class="nav-text">3. 状态转移方程推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">13.4.</span> <span class="nav-text">4. 边界条件处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96"><span class="nav-number">13.5.</span> <span class="nav-text">5. 空间优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qa-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">14.</span> <span class="nav-text">❓ Q&amp;A: 动态规划常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#q1-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3"><span class="nav-number">14.1.</span> <span class="nav-text">Q1:
如何判断一个问题是否可以用动态规划解决？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">14.2.</span> <span class="nav-text">Q2:
动态规划和贪心算法有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q3-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84-dp"><span class="nav-number">14.3.</span> <span class="nav-text">Q3:
什么时候用记忆化递归，什么时候用自底向上的 DP？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q4-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-dp-%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">14.4.</span> <span class="nav-text">Q4: 如何优化 DP 的空间复杂度？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q5-%E4%B8%BA%E4%BB%80%E4%B9%88-0-1-%E8%83%8C%E5%8C%85%E7%9A%84%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96%E8%A6%81%E9%80%86%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">14.5.</span> <span class="nav-text">Q5: 为什么 0-1
背包的空间优化要逆序遍历？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q6-%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-dp-%E9%97%AE%E9%A2%98"><span class="nav-number">14.6.</span> <span class="nav-text">Q6: 如何调试 DP 问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q7-dp-%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%AF%E4%BB%A5%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96%E5%90%97"><span class="nav-number">14.7.</span> <span class="nav-text">Q7: DP
的时间复杂度可以进一步优化吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q8-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%B4%E5%BA%A6"><span class="nav-number">14.8.</span> <span class="nav-text">Q8: 如何确定状态定义的维度？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q9-%E9%81%87%E5%88%B0-dp-%E9%97%AE%E9%A2%98%E6%B2%A1%E6%9C%89%E6%80%9D%E8%B7%AF%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">14.9.</span> <span class="nav-text">Q9: 遇到 DP
问题没有思路怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E6%89%80%E6%9C%89%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E5%90%97"><span class="nav-number">14.10.</span> <span class="nav-text">Q10:
动态规划可以解决所有最优化问题吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%8E%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98"><span class="nav-number">15.</span> <span class="nav-text">变体与扩展问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%80%E5%8C%BA%E9%97%B4-dp"><span class="nav-number">15.1.</span> <span class="nav-text">变体一：区间 DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%BA%8C%E6%A0%91%E5%BD%A2-dp"><span class="nav-number">15.2.</span> <span class="nav-text">变体二：树形 DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%89%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9-dp"><span class="nav-number">15.3.</span> <span class="nav-text">变体三：状态压缩 DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E5%9B%9B%E6%95%B0%E4%BD%8D-dp"><span class="nav-number">15.4.</span> <span class="nav-text">变体四：数位 DP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">16.</span> <span class="nav-text">常见错误与调试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%80%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89%E4%B8%8D%E6%B8%85%E6%99%B0"><span class="nav-number">16.1.</span> <span class="nav-text">错误一：状态定义不清晰</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BA%8C%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E9%81%97%E6%BC%8F%E6%83%85%E5%86%B5"><span class="nav-number">16.2.</span> <span class="nav-text">错误二：状态转移方程遗漏情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%89%E5%88%9D%E5%A7%8B%E5%80%BC%E8%AE%BE%E7%BD%AE%E9%94%99%E8%AF%AF"><span class="nav-number">16.3.</span> <span class="nav-text">错误三：初始值设置错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%9B%9B%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C"><span class="nav-number">16.4.</span> <span class="nav-text">错误四：数组越界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">16.5.</span> <span class="nav-text">调试技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E5%BB%BA%E8%AE%AE"><span class="nav-number">17.</span> <span class="nav-text">实战建议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%AF%86%E5%88%AB-dp-%E9%97%AE%E9%A2%98"><span class="nav-number">17.1.</span> <span class="nav-text">如何快速识别 DP 问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4%E6%80%BB%E7%BB%93"><span class="nav-number">17.2.</span> <span class="nav-text">解题步骤总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E7%B1%BB"><span class="nav-number">17.3.</span> <span class="nav-text">经典问题分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-number">17.4.</span> <span class="nav-text">性能优化建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">18.</span> <span class="nav-text">总结</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
