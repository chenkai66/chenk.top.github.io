<!DOCTYPE html>



<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode（八）—— 回溯算法 |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"zh-CN","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode（八）—— 回溯算法</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-07-28 00:00:00</span>
        <span class="mobile">2023-07-28 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>14.3k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>57 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>回溯算法是解决组合优化问题的经典方法，在 LeetCode
中应用广泛。从全排列到 N
皇后，从子集生成到括号匹配，回溯算法以其清晰的递归结构和强大的搜索能力，成为解决这类问题的首选方案。本文将深入探讨回溯算法的核心思想、实现框架、优化技巧，并通过多个经典例题帮助读者掌握这一重要算法。</p>
<span id="more"></span>
<h2 id="什么是回溯算法">什么是回溯算法</h2>
<p>回溯算法（Backtracking）是一种通过探索所有可能的候选解来找出所有解的算法。当探索到某一步时，如果发现这个选择不能得到有效解，就回退一步，重新选择。回溯算法本质上是一种<strong>深度优先搜索（DFS）</strong>的特殊形式，区别在于回溯算法会在搜索过程中<strong>撤销之前的选择</strong>。</p>
<p>回溯算法的核心思想可以用一句话概括：<strong>尝试所有可能的选择，如果当前选择不可行，就回退并尝试下一个选择</strong>。这种"试错"的过程，就像走迷宫时遇到死胡同就返回上一个路口重新选择路径一样。</p>
<p>回溯算法的历史可以追溯到 19 世纪，但真正系统化是在 20 世纪 50
年代。回溯算法特别适合解决约束满足问题（Constraint Satisfaction
Problems, CSP），这类问题的特点是：</p>
<ul>
<li>变量之间存在约束关系</li>
<li>需要找到满足所有约束的解</li>
<li>解的数量可能是指数级的</li>
</ul>
<p>在计算机科学中，回溯算法被广泛应用于人工智能、编译器设计、组合数学等领域。在
LeetCode 中，回溯算法是解决排列、组合、子集等问题的标准方法。</p>
<h2 id="回溯与-dfs-的关系">回溯与 DFS 的关系</h2>
<p>很多初学者会困惑：回溯算法和深度优先搜索（DFS）有什么区别？实际上，回溯算法是
DFS 的一种应用形式。</p>
<p><strong>DFS</strong>
是一种遍历图或树的算法，它沿着一条路径尽可能深地搜索，直到无法继续，然后回溯到上一个节点继续搜索。DFS
的核心是<strong>遍历</strong>，目标是访问所有节点。</p>
<p><strong>回溯算法</strong> 在 DFS
的基础上，增加了<strong>状态恢复</strong>的机制。当我们做出一个选择后，会递归地探索后续的可能性；当递归返回时，需要撤销这个选择，恢复到之前的状态，以便尝试其他选择。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFS 遍历树（不需要恢复状态）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(node.val)  <span class="comment"># 访问节点</span></span><br><span class="line">    dfs(node.left)</span><br><span class="line">    dfs(node.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回溯算法（需要恢复状态）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        记录结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        path.append(choice)      <span class="comment"># 做选择</span></span><br><span class="line">        backtrack(path, choices) <span class="comment"># 递归</span></span><br><span class="line">        path.pop()               <span class="comment"># 撤销选择（关键！）</span></span><br></pre></td></tr></table></figure>
<p>回溯算法中的 <code>path.pop()</code>
就是状态恢复的关键。没有这一步，算法就无法正确地探索所有可能性。</p>
<h3 id="实际应用场景对比">实际应用场景对比</h3>
<p>为了更好地理解两者的区别，我们看一个具体例子：</p>
<p><strong>DFS
遍历二叉树</strong>：我们只需要访问每个节点一次，不需要恢复状态，因为每个节点的访问是独立的。</p>
<p><strong>回溯解决全排列</strong>：需要尝试所有可能的排列。当我们选择数字
1 后，需要尝试选择 2 和 3；尝试完以 1 开头的所有排列后，需要"撤销"对 1
的选择，尝试选择 2，然后尝试以 2
开头的所有排列。这里的"撤销"就是状态恢复。</p>
<h3 id="回溯算法的搜索树">回溯算法的搜索树</h3>
<p>回溯算法可以看作是在一棵隐式的搜索树上进行
DFS。树的每个节点代表一个状态，边代表一个选择。当我们到达一个叶子节点时，如果满足条件，就找到了一个解；如果不满足，就回溯到父节点，尝试其他分支。</p>
<p>例如，对于全排列 <code>[1,2,3]</code>，搜索树的第一层有三个分支（选择
1、2 或
3），第二层有两个分支（选择剩余的两个数字之一），第三层只有一个分支（选择最后一个数字）。整个搜索树有
<span class="math inline">\(3! = 6\)</span> 个叶子节点，对应 6
个排列。</p>
<h2 id="回溯算法的三要素">回溯算法的三要素</h2>
<p>理解回溯算法，需要掌握三个核心要素：<strong>选择（Choice）</strong>、<strong>约束（Constraint）</strong>、<strong>目标（Goal）</strong>。</p>
<h3 id="选择choice">选择（Choice）</h3>
<p>选择是指在当前状态下，可以做出的所有可能决策。例如：</p>
<ul>
<li>在全排列问题中，选择是"选择哪个数字放在当前位置"</li>
<li>在 N 皇后问题中，选择是"在当前位置放置皇后"</li>
<li>在组合问题中，选择是"是否包含当前元素"</li>
</ul>
<h3 id="约束constraint">约束（Constraint）</h3>
<p>约束是指限制我们做出选择的条件。只有满足约束条件的选择才是合法的。例如：</p>
<ul>
<li>全排列中，不能选择已经使用过的数字</li>
<li>N 皇后中，不能与已有皇后在同一行、列或对角线上</li>
<li>组合总和问题中，选择的数字之和不能超过目标值</li>
</ul>
<h3 id="目标goal">目标（Goal）</h3>
<p>目标是指我们想要达到的终止条件。当满足目标时，我们就找到了一个解。例如：</p>
<ul>
<li>全排列中，当路径长度等于数组长度时，得到一个排列</li>
<li>N 皇后中，当成功放置 N 个皇后时，得到一个解</li>
<li>子集问题中，当遍历完所有元素时，得到一个子集</li>
</ul>
<h2 id="回溯算法模板">回溯算法模板</h2>
<p>回溯算法有一个通用的模板，掌握这个模板可以解决大部分回溯问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">    <span class="comment"># 终止条件：找到解或无法继续</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        结果.append(path[:])  <span class="comment"># 注意：需要复制，不能直接 append(path)</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历所有可能的选择</span></span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        <span class="comment"># 剪枝：跳过不满足约束的选择</span></span><br><span class="line">        <span class="keyword">if</span> 不满足约束条件:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        path.append(choice)</span><br><span class="line">        <span class="comment"># 更新选择列表（如果需要）</span></span><br><span class="line">        <span class="comment"># new_choices = 更新后的选择列表</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        backtrack(path, new_choices)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 撤销选择（回溯）</span></span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>： 1.
<strong>结果保存</strong>：<code>path[:]</code> 创建了 <code>path</code>
的副本。如果直接 <code>append(path)</code>，由于 <code>path</code>
是引用，后续修改会影响已保存的结果。 2.
<strong>状态恢复</strong>：<code>path.pop()</code>
必须在递归返回后执行，确保回溯到上一个状态。 3.
<strong>剪枝优化</strong>：在循环中提前判断约束条件，避免无效递归。</p>
<h3 id="模板的变体">模板的变体</h3>
<p>根据问题的不同特点，模板会有一些变体：</p>
<p><strong>变体一：需要返回值的回溯</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 找到一个解就返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        <span class="keyword">if</span> 不满足约束条件:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        path.append(choice)</span><br><span class="line">        <span class="keyword">if</span> backtrack(path, new_choices):  <span class="comment"># 如果找到解，立即返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        path.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 所有选择都尝试过，无解</span></span><br></pre></td></tr></table></figure>
<p><strong>变体二：需要记录路径的回溯</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices, result</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.append(path[:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        <span class="keyword">if</span> 不满足约束条件:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        path.append(choice)</span><br><span class="line">        backtrack(path, new_choices, result)</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>
<p><strong>变体三：使用索引而非列表拷贝</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">index, path</span>):</span><br><span class="line">    <span class="keyword">if</span> index == <span class="built_in">len</span>(nums):</span><br><span class="line">        result.append(path[:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择1：不包含当前元素</span></span><br><span class="line">    backtrack(index + <span class="number">1</span>, path)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择2：包含当前元素</span></span><br><span class="line">    path.append(nums[index])</span><br><span class="line">    backtrack(index + <span class="number">1</span>, path)</span><br><span class="line">    path.pop()</span><br></pre></td></tr></table></figure>
<h2 id="经典问题一全排列">经典问题一：全排列</h2>
<p><strong>LeetCode 46</strong>：给定一个不含重复数字的数组
<code>nums</code>，返回其所有可能的全排列。可以按任意顺序返回答案。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>输入：<code>nums = [1,2,3]</code></li>
<li>输出：<code>[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</code></li>
</ul>
<p><strong>约束条件</strong>：</p>
<ul>
<li><span class="math inline">\(1 \leq \texttt{nums.length} \leq
6\)</span></li>
<li><span class="math inline">\(-10 \leq \texttt{nums[i]} \leq
10\)</span></li>
<li><code>nums</code> 中的所有整数互不相同</li>
</ul>
<h2 id="问题分析">问题分析</h2>
<p>全排列问题要求生成数组的所有排列方式。对于 <span class="math inline">\(n\)</span> 个不同元素，共有 <span class="math inline">\(n!\)</span> 种排列。</p>
<p><strong>核心挑战</strong>：</p>
<ol type="1">
<li><strong>如何避免重复选择</strong>：每个元素在每个排列中只能出现一次</li>
<li><strong>如何系统地探索所有可能性</strong>：需要尝试所有可能的排列组合</li>
<li><strong>如何高效地回溯</strong>：当一条路径无法继续时，需要撤销选择并尝试其他路径</li>
</ol>
<p><strong>应用场景</strong>：</p>
<ul>
<li>密码破解：尝试所有可能的密码组合</li>
<li>任务调度：安排任务的执行顺序</li>
<li>游戏求解：探索所有可能的游戏状态</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p><strong>回溯三要素分析</strong>：</p>
<ul>
<li><strong>选择</strong>：当前位置可以选择哪些数字（所有未使用的数字）</li>
<li><strong>约束</strong>：不能选择已经使用过的数字（通过
<code>used</code> 数组标记）</li>
<li><strong>目标</strong>：路径长度等于数组长度（生成了一个完整排列）</li>
</ul>
<p><strong>算法流程</strong>：</p>
<ol type="1">
<li>使用 <code>used</code> 数组标记哪些数字已被使用</li>
<li>使用 <code>path</code> 列表记录当前路径（部分排列）</li>
<li>递归函数 <code>backtrack()</code>：
<ul>
<li>如果 <code>path</code> 长度等于 <code>nums</code>
长度，保存结果并返回</li>
<li>遍历所有数字，如果未使用，则：
<ul>
<li>标记为已使用</li>
<li>加入 <code>path</code></li>
<li>递归处理下一位置</li>
<li>回溯：撤销标记和选择</li>
</ul></li>
</ul></li>
</ol>
<h2 id="复杂度分析">复杂度分析</h2>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n \times
n!)\)</span></p>
<ul>
<li>共有 <span class="math inline">\(n!\)</span>
个排列（叶子节点数）</li>
<li>每个排列需要 <span class="math inline">\(O(n)\)</span>
时间复制到结果中</li>
<li>总时间复杂度：<span class="math inline">\(O(n \times
n!)\)</span></li>
</ul>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span></p>
<ul>
<li>递归栈深度：<span class="math inline">\(O(n)\)</span>（最多 <span class="math inline">\(n\)</span> 层递归）</li>
<li><code>path</code> 数组：<span class="math inline">\(O(n)\)</span></li>
<li><code>used</code> 数组：<span class="math inline">\(O(n)\)</span></li>
<li>结果数组：<span class="math inline">\(O(n \times
n!)\)</span>（输出空间，不计入复杂度）</li>
</ul>
<p><strong>复杂度证明</strong>：</p>
<p>对于 <span class="math inline">\(n\)</span> 个元素的全排列： -
第一层有 <span class="math inline">\(n\)</span> 个选择 - 第二层有 <span class="math inline">\(n-1\)</span> 个选择 - ... - 第 <span class="math inline">\(n\)</span> 层有 <span class="math inline">\(1\)</span> 个选择</p>
<p>总排列数：<span class="math inline">\(n \times (n-1) \times \cdots
\times 1 = n!\)</span></p>
<p>每个排列需要 <span class="math inline">\(O(n)\)</span>
时间复制，因此总时间复杂度为 <span class="math inline">\(O(n \times
n!)\)</span>。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成数组的所有全排列</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        算法步骤：</span></span><br><span class="line"><span class="string">        1. 初始化结果列表、路径列表和标记数组</span></span><br><span class="line"><span class="string">        2. 定义回溯函数backtrack()：</span></span><br><span class="line"><span class="string">           a. 终止条件：路径长度等于数组长度，保存结果</span></span><br><span class="line"><span class="string">           b. 遍历所有数字，跳过已使用的</span></span><br><span class="line"><span class="string">           c. 做选择：标记使用、加入路径</span></span><br><span class="line"><span class="string">           d. 递归：处理下一位置</span></span><br><span class="line"><span class="string">           e. 撤销选择：恢复标记、移除路径</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        边界条件：</span></span><br><span class="line"><span class="string">        - 空数组：返回 [[]]</span></span><br><span class="line"><span class="string">        - 单元素：返回 [[元素]]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        优化技巧：</span></span><br><span class="line"><span class="string">        - 使用used数组避免重复选择（O(1)查找）</span></span><br><span class="line"><span class="string">        - 使用path[:]创建副本保存结果（避免引用问题）</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        变量含义：</span></span><br><span class="line"><span class="string">        - result: 存储所有排列的结果列表</span></span><br><span class="line"><span class="string">        - path: 当前正在构建的排列路径</span></span><br><span class="line"><span class="string">        - used: 布尔数组，used[i]表示nums[i]是否已使用</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        path = []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)  <span class="comment"># 标记哪些数字已使用</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>():</span><br><span class="line">            <span class="comment"># 终止条件：路径长度等于数组长度</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                result.append(path[:])  <span class="comment"># 创建副本，避免引用问题</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历所有可能的选择</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 约束检查：跳过已使用的数字</span></span><br><span class="line">                <span class="keyword">if</span> used[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 递归：处理下一位置</span></span><br><span class="line">                backtrack()</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 撤销选择（回溯）</span></span><br><span class="line">                path.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>算法原理</strong>：</p>
<p>回溯算法通过"尝试-撤销"的方式系统地探索所有可能性：</p>
<ol type="1">
<li><strong>尝试</strong>：选择一个未使用的数字加入当前路径</li>
<li><strong>递归</strong>：继续构建剩余位置的排列</li>
<li><strong>撤销</strong>：当递归返回时，撤销当前选择，尝试其他可能性</li>
</ol>
<p>这种"深度优先搜索 +
状态恢复"的模式确保了所有排列都被探索到，且不会遗漏或重复。</p>
<p><strong>执行过程示例</strong>（<code>nums = [1,2,3]</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">初始：path = [], used = [False, False, False]</span><br><span class="line">第1层：选择1</span><br><span class="line">  path = [1], used = [True, False, False]</span><br><span class="line">  第2层：选择2</span><br><span class="line">    path = [1,2], used = [True, True, False]</span><br><span class="line">    第3层：选择3</span><br><span class="line">      path = [1,2,3] → 保存结果 [[1,2,3]]</span><br><span class="line">      回溯：path = [1,2], used = [True, True, False]</span><br><span class="line">    回溯：path = [1], used = [True, False, False]</span><br><span class="line">  第2层：选择3</span><br><span class="line">    path = [1,3], used = [True, False, True]</span><br><span class="line">    第3层：选择2</span><br><span class="line">      path = [1,3,2] → 保存结果 [[1,2,3], [1,3,2]]</span><br><span class="line">      回溯：path = [1,3], used = [True, False, True]</span><br><span class="line">    回溯：path = [1], used = [True, False, False]</span><br><span class="line">  回溯：path = [], used = [False, False, False]</span><br><span class="line">第1层：选择2（继续类似过程）...</span><br></pre></td></tr></table></figure>
<p><strong>常见错误</strong>：</p>
<h3 id="错误一忘记创建路径副本">错误一：忘记创建路径副本</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误</span></span><br><span class="line">result.append(path)  <span class="comment"># path是引用，后续修改会影响已保存的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line">result.append(path[:])  <span class="comment"># 创建副本</span></span><br></pre></td></tr></table></figure>
<h3 id="错误二忘记撤销选择">错误二：忘记撤销选择</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误</span></span><br><span class="line">path.append(nums[i])</span><br><span class="line">used[i] = <span class="literal">True</span></span><br><span class="line">backtrack()</span><br><span class="line"><span class="comment"># 忘记：path.pop() 和 used[i] = False</span></span><br><span class="line"><span class="comment"># 导致无法回溯，无法探索其他可能性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line">path.append(nums[i])</span><br><span class="line">used[i] = <span class="literal">True</span></span><br><span class="line">backtrack()</span><br><span class="line">path.pop()      <span class="comment"># 必须撤销</span></span><br><span class="line">used[i] = <span class="literal">False</span>  <span class="comment"># 必须恢复状态</span></span><br></pre></td></tr></table></figure>
<h3 id="错误三约束检查位置错误">错误三：约束检查位置错误</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：在递归后检查约束</span></span><br><span class="line">path.append(nums[i])</span><br><span class="line">backtrack()</span><br><span class="line"><span class="keyword">if</span> used[i]:  <span class="comment"># 太晚了！</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确：在递归前检查约束</span></span><br><span class="line"><span class="keyword">if</span> used[i]:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">path.append(nums[i])</span><br><span class="line">backtrack()</span><br></pre></td></tr></table></figure>
<h3 id="全排列问题的搜索过程">全排列问题的搜索过程</h3>
<p>让我们追踪一下 <code>permute([1,2,3])</code> 的执行过程：</p>
<ol type="1">
<li><p>初始状态：<code>path = []</code>,
<code>used = [False, False, False]</code></p></li>
<li><p>第一层递归：选择 1</p>
<ul>
<li><code>path = [1]</code>,
<code>used = [True, False, False]</code></li>
<li>第二层递归：选择 2
<ul>
<li><code>path = [1,2]</code>,
<code>used = [True, True, False]</code></li>
<li>第三层递归：选择 3
<ul>
<li><code>path = [1,2,3]</code> → 满足条件，保存结果</li>
<li>回溯：<code>path = [1,2]</code>,
<code>used = [True, True, False]</code></li>
</ul></li>
<li>回溯：<code>path = [1]</code>,
<code>used = [True, False, False]</code></li>
</ul></li>
<li>第二层递归：选择 3
<ul>
<li><code>path = [1,3]</code>,
<code>used = [True, False, True]</code></li>
<li>第三层递归：选择 2
<ul>
<li><code>path = [1,3,2]</code> → 满足条件，保存结果</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>回溯到第一层：<code>path = []</code>,
<code>used = [False, False, False]</code></p></li>
<li><p>第一层递归：选择 2（继续类似过程）...</p></li>
</ol>
<p>通过这个过程回溯算法系统地探索了所有 <span class="math inline">\(3! =
6\)</span> 种可能性。</p>
<h3 id="全排列-ii包含重复元素">全排列 II（包含重复元素）</h3>
<p>如果数组包含重复元素，需要去重。有两种方法：</p>
<p><strong>方法一：排序 + 剪枝</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    nums.sort()  <span class="comment"># 排序，使相同元素相邻</span></span><br><span class="line">    used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 剪枝：如果当前数字与前一个相同，且前一个未使用，则跳过</span></span><br><span class="line">            <span class="comment"># 这确保了相同数字的相对顺序，避免重复</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            backtrack()</span><br><span class="line">            path.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    backtrack()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>方法二：使用集合去重</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        seen = <span class="built_in">set</span>()  <span class="comment"># 当前层已使用的数字</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> used[i] <span class="keyword">or</span> nums[i] <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            seen.add(nums[i])</span><br><span class="line">            </span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            backtrack()</span><br><span class="line">            path.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    backtrack()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="经典问题二组合总和">经典问题二：组合总和</h2>
<p><strong>LeetCode 39</strong>：给定一个无重复元素的数组
<code>candidates</code> 和一个目标数 <code>target</code>，找出
<code>candidates</code> 中所有可以使数字和为 <code>target</code>
的组合。<code>candidates</code> 中的数字可以无限制重复被选取。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>输入：<code>candidates = [2,3,6,7]</code>,
<code>target = 7</code></li>
<li>输出：<code>[[2,2,3], [7]]</code></li>
</ul>
<p><strong>约束条件</strong>：</p>
<ul>
<li><span class="math inline">\(1 \leq \texttt{candidates.length} \leq
30\)</span></li>
<li><span class="math inline">\(2 \leq \texttt{candidates[i]} \leq
40\)</span></li>
<li><code>candidates</code> 中的所有元素互不相同</li>
<li><span class="math inline">\(1 \leq \texttt{target} \leq
500\)</span></li>
</ul>
<h2 id="问题分析-1">问题分析</h2>
<p>组合总和问题要求找到所有和为 <code>target</code>
的组合，且每个数字可以重复使用。</p>
<p><strong>核心挑战</strong>：</p>
<ol type="1">
<li><strong>如何避免重复组合</strong>：<code>[2,3]</code> 和
<code>[3,2]</code> 是同一个组合，需要避免重复</li>
<li><strong>如何控制搜索空间</strong>：当剩余值小于0时，需要提前终止</li>
<li><strong>如何允许重复使用</strong>：同一个数字可以在组合中出现多次</li>
</ol>
<p><strong>关键洞察</strong>：</p>
<p>通过<strong>限制选择范围</strong>（从 <code>start</code>
开始）来避免重复。如果总是从数组开头选择，会产生 <code>[2,3]</code> 和
<code>[3,2]</code>
这样的重复组合。通过只从当前位置及之后选择，确保组合中的数字按数组顺序排列，从而避免重复。</p>
<h2 id="解题思路-1">解题思路</h2>
<p><strong>回溯三要素分析</strong>：</p>
<ul>
<li><strong>选择</strong>：选择哪个数字加入当前组合（从
<code>start</code> 位置开始）</li>
<li><strong>约束</strong>：
<ul>
<li>组合的和不能超过
<code>target</code>（<code>remain &gt;= 0</code>）</li>
<li>只能从当前位置及之后选择（避免重复）</li>
</ul></li>
<li><strong>目标</strong>：组合的和等于
<code>target</code>（<code>remain == 0</code>）</li>
</ul>
<p><strong>算法流程</strong>：</p>
<ol type="1">
<li>定义回溯函数 <code>backtrack(start, remain)</code>：
<ul>
<li><code>start</code>：当前可以选择的位置起始索引</li>
<li><code>remain</code>：剩余目标和</li>
</ul></li>
<li>终止条件：
<ul>
<li><code>remain == 0</code>：找到有效组合，保存结果</li>
<li><code>remain &lt; 0</code>：当前路径无效，直接返回</li>
</ul></li>
<li>遍历从 <code>start</code> 开始的所有候选数字：
<ul>
<li>加入当前路径</li>
<li>递归：<code>backtrack(i, remain - candidates[i])</code>（注意从
<code>i</code> 开始，允许重复）</li>
<li>回溯：移除当前选择</li>
</ul></li>
</ol>
<h2 id="复杂度分析-1">复杂度分析</h2>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(2^N)\)</span>，其中 <span class="math inline">\(N = \lceil \texttt{target} /
\min(\texttt{candidates}) \rceil\)</span></p>
<ul>
<li>最坏情况下，每个位置都有两个选择（选或不选）</li>
<li>由于可以重复选择，实际搜索空间可能更大</li>
<li>通过剪枝可以大幅减少实际搜索节点数</li>
</ul>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(\texttt{target})\)</span></p>
<ul>
<li>递归栈深度最多为 <code>target</code>（当每次都选择最小数字时）</li>
<li><code>path</code> 数组长度最多为 <code>target</code></li>
</ul>
<p><strong>复杂度证明</strong>：</p>
<p>假设最小候选数为 <span class="math inline">\(m\)</span>，则最多需要选择 <span class="math inline">\(\lceil \texttt{target} / m \rceil\)</span>
个数字。每个位置有 <span class="math inline">\(|\texttt{candidates}|\)</span>
个选择，但由于剪枝和重复使用的限制，实际复杂度介于 <span class="math inline">\(O(2^N)\)</span> 和 <span class="math inline">\(O(k^N)\)</span> 之间，其中 <span class="math inline">\(k = |\texttt{candidates}|\)</span>。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        找出所有和为target的组合（数字可重复使用）</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        算法步骤：</span></span><br><span class="line"><span class="string">        1. 定义回溯函数backtrack(start, remain)：</span></span><br><span class="line"><span class="string">           a. 终止条件1：remain == 0，保存结果</span></span><br><span class="line"><span class="string">           b. 终止条件2：remain &lt; 0，剪枝返回</span></span><br><span class="line"><span class="string">           c. 从start开始遍历候选数字</span></span><br><span class="line"><span class="string">           d. 做选择：加入路径</span></span><br><span class="line"><span class="string">           e. 递归：backtrack(i, remain - candidates[i])（从i开始，允许重复）</span></span><br><span class="line"><span class="string">           f. 撤销选择：移除路径</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        边界条件：</span></span><br><span class="line"><span class="string">        - 空数组：返回 []</span></span><br><span class="line"><span class="string">        - target为0：返回 [[]]</span></span><br><span class="line"><span class="string">        - 所有候选数都大于target：返回 []</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        优化技巧：</span></span><br><span class="line"><span class="string">        - 使用start参数避免重复组合（只从当前位置及之后选择）</span></span><br><span class="line"><span class="string">        - remain &lt; 0时提前剪枝，减少无效搜索</span></span><br><span class="line"><span class="string">        - 排序后可以进一步优化（见下方优化版本）</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        变量含义：</span></span><br><span class="line"><span class="string">        - result: 存储所有有效组合的结果列表</span></span><br><span class="line"><span class="string">        - path: 当前正在构建的组合路径</span></span><br><span class="line"><span class="string">        - start: 当前可以选择的位置起始索引（避免重复）</span></span><br><span class="line"><span class="string">        - remain: 剩余目标和</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        path = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start, remain</span>):</span><br><span class="line">            <span class="comment"># 终止条件1：找到有效组合</span></span><br><span class="line">            <span class="keyword">if</span> remain == <span class="number">0</span>:</span><br><span class="line">                result.append(path[:])  <span class="comment"># 保存结果</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 终止条件2：当前路径无效（剪枝）</span></span><br><span class="line">            <span class="keyword">if</span> remain &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 从start开始选择，避免重复组合</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 递归：注意从i开始（不是i+1），允许重复使用</span></span><br><span class="line">                backtrack(i, remain - candidates[i])</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 撤销选择（回溯）</span></span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="number">0</span>, target)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>算法原理</strong>：</p>
<p><strong>为什么从 <code>start</code> 开始可以避免重复</strong>：</p>
<p>假设
<code>candidates = [2,3,6,7]</code>，<code>target = 7</code>：</p>
<ul>
<li>如果从0开始：可能产生 <code>[2,3]</code> 和
<code>[3,2]</code>（重复）</li>
<li>如果从 <code>start</code> 开始：
<ul>
<li>选择2后，<code>start=0</code>，只能选择2,3,6,7 → 产生
<code>[2,2,3]</code>, <code>[2,3]</code> 等</li>
<li>选择3后，<code>start=1</code>，只能选择3,6,7 → 产生
<code>[3,3]</code> 等</li>
<li>不会产生 <code>[3,2]</code>，因为选择3时
<code>start=1</code>，不会再选择2</li>
</ul></li>
</ul>
<p><strong>为什么递归时从 <code>i</code> 开始（不是
<code>i+1</code>）</strong>：</p>
<p>因为题目允许重复使用同一个数字。如果从 <code>i+1</code>
开始，每个数字只能使用一次，就变成了"组合总和II"问题。</p>
<p><strong>常见错误</strong>：</p>
<h3 id="错误一从0开始选择导致重复">错误一：从0开始选择导致重复</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(candidates)):  <span class="comment"># 总是从0开始</span></span><br><span class="line">    backtrack(i, remain - candidates[i])</span><br><span class="line"><span class="comment"># 会产生 [2,3] 和 [3,2] 这样的重复组合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(candidates)):  <span class="comment"># 从start开始</span></span><br><span class="line">    backtrack(i, remain - candidates[i])</span><br></pre></td></tr></table></figure>
<h3 id="错误二递归时使用-i1-导致无法重复使用">错误二：递归时使用
<code>i+1</code> 导致无法重复使用</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误</span></span><br><span class="line">backtrack(i + <span class="number">1</span>, remain - candidates[i])  <span class="comment"># 每个数字只能用一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line">backtrack(i, remain - candidates[i])  <span class="comment"># 允许重复使用</span></span><br></pre></td></tr></table></figure>
<h3 id="组合总和问题的优化">组合总和问题的优化</h3>
<p>可以通过排序和提前终止来优化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">candidates, target</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    candidates.sort()  <span class="comment"># 排序，便于剪枝</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start, remain</span>):</span><br><span class="line">        <span class="keyword">if</span> remain == <span class="number">0</span>:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(candidates)):</span><br><span class="line">            <span class="comment"># 剪枝：如果当前数字已经大于剩余值，后续数字更大，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> candidates[i] &gt; remain:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 注意是 break 不是 continue，因为已排序</span></span><br><span class="line">            </span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            backtrack(i, remain - candidates[i])</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>这个优化利用了排序的性质：如果
<code>candidates[i] &gt; remain</code>，那么
<code>candidates[i+1]</code> 及之后的数字都大于
<code>remain</code>，可以直接终止循环。</p>
<h3 id="组合总和-ii每个数字只能使用一次">组合总和
II（每个数字只能使用一次）</h3>
<p>如果每个数字只能使用一次，且数组可能包含重复元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">candidates, target</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    candidates.sort()  <span class="comment"># 排序以便去重</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start, remain</span>):</span><br><span class="line">        <span class="keyword">if</span> remain == <span class="number">0</span>:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> remain &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(candidates)):</span><br><span class="line">            <span class="comment"># 剪枝：跳过重复元素</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> candidates[i] == candidates[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            <span class="comment"># 每个数字只能用一次，所以从 i+1 开始</span></span><br><span class="line">            backtrack(i + <span class="number">1</span>, remain - candidates[i])</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="经典问题三子集">经典问题三：子集</h2>
<p><strong>LeetCode 78</strong>：给定一个不含重复元素的整数数组
<code>nums</code>，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。可以按任意顺序返回解集。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>输入：<code>nums = [1,2,3]</code></li>
<li>输出：<code>[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]</code></li>
</ul>
<p><strong>约束条件</strong>：</p>
<ul>
<li><span class="math inline">\(1 \leq \texttt{nums.length} \leq
10\)</span></li>
<li><span class="math inline">\(-10 \leq \texttt{nums[i]} \leq
10\)</span></li>
<li><code>nums</code> 中的所有元素互不相同</li>
</ul>
<h2 id="问题分析-2">问题分析</h2>
<p>子集问题要求生成数组的所有子集（幂集）。对于 <span class="math inline">\(n\)</span> 个元素，共有 <span class="math inline">\(2^n\)</span> 个子集（包括空集）。</p>
<p><strong>核心特点</strong>：</p>
<ol type="1">
<li><strong>每个状态都是一个解</strong>：与全排列、组合问题不同，子集问题不需要等到满足某个条件才保存结果，而是在每个递归状态都保存当前路径</li>
<li><strong>如何避免重复</strong>：通过 <code>start</code>
参数限制选择范围，确保子集按数组顺序生成</li>
<li><strong>两种理解方式</strong>：
<ul>
<li>方式一：对每个元素，有两个选择（选或不选）</li>
<li>方式二：逐步添加元素到集合中</li>
</ul></li>
</ol>
<h2 id="解题思路-2">解题思路</h2>
<p><strong>回溯三要素分析</strong>：</p>
<ul>
<li><strong>选择</strong>：是否将当前元素加入子集（从 <code>start</code>
位置开始）</li>
<li><strong>约束</strong>：只能从当前位置及之后选择（避免重复）</li>
<li><strong>目标</strong>：每个状态都是一个有效子集（无需特定终止条件）</li>
</ul>
<p><strong>算法流程</strong>：</p>
<ol type="1">
<li>定义回溯函数 <code>backtrack(start)</code>：
<ul>
<li>保存当前路径（每个状态都是一个解）</li>
<li>从 <code>start</code> 开始遍历剩余元素</li>
<li>加入当前元素，递归，回溯</li>
</ul></li>
<li>与组合问题的区别：
<ul>
<li>组合问题：只在满足条件时保存结果</li>
<li>子集问题：每个递归调用开始时都保存结果</li>
</ul></li>
</ol>
<h2 id="复杂度分析-2">复杂度分析</h2>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n \times
2^n)\)</span></p>
<ul>
<li>共有 <span class="math inline">\(2^n\)</span> 个子集</li>
<li>每个子集需要 <span class="math inline">\(O(n)\)</span>
时间复制到结果中</li>
<li>总时间复杂度：<span class="math inline">\(O(n \times
2^n)\)</span></li>
</ul>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span></p>
<ul>
<li>递归栈深度：<span class="math inline">\(O(n)\)</span>（最多 <span class="math inline">\(n\)</span> 层递归）</li>
<li><code>path</code> 数组：<span class="math inline">\(O(n)\)</span></li>
<li>结果数组：<span class="math inline">\(O(n \times
2^n)\)</span>（输出空间，不计入复杂度）</li>
</ul>
<p><strong>复杂度证明</strong>：</p>
<p>对于 <span class="math inline">\(n\)</span>
个元素，每个元素有"选"或"不选"两种状态，因此共有 <span class="math inline">\(2^n\)</span> 种组合，即 <span class="math inline">\(2^n\)</span> 个子集。</p>
<p><strong>方法一：回溯法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成数组的所有子集（幂集）</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        算法步骤：</span></span><br><span class="line"><span class="string">        1. 定义回溯函数backtrack(start)：</span></span><br><span class="line"><span class="string">           a. 保存当前路径（每个状态都是一个解）</span></span><br><span class="line"><span class="string">           b. 从start开始遍历剩余元素</span></span><br><span class="line"><span class="string">           c. 做选择：加入路径</span></span><br><span class="line"><span class="string">           d. 递归：backtrack(i + 1)</span></span><br><span class="line"><span class="string">           e. 撤销选择：移除路径</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        边界条件：</span></span><br><span class="line"><span class="string">        - 空数组：返回 [[]]</span></span><br><span class="line"><span class="string">        - 单元素：返回 [[], [元素]]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        优化技巧：</span></span><br><span class="line"><span class="string">        - 使用start参数避免重复子集</span></span><br><span class="line"><span class="string">        - 每次递归开始时保存当前状态</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        变量含义：</span></span><br><span class="line"><span class="string">        - result: 存储所有子集的结果列表</span></span><br><span class="line"><span class="string">        - path: 当前正在构建的子集路径</span></span><br><span class="line"><span class="string">        - start: 当前可以选择的位置起始索引</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        path = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start</span>):</span><br><span class="line">            <span class="comment"># 每个状态都是一个解（包括空集）</span></span><br><span class="line">            result.append(path[:])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 从start开始选择，避免重复</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 递归：从i+1开始（每个元素只能选一次）</span></span><br><span class="line">                backtrack(i + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 撤销选择（回溯）</span></span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>算法原理</strong>：</p>
<p><strong>为什么每个状态都要保存</strong>：</p>
<p>子集问题的本质是"选或不选"的组合。当我们遍历到某个位置时，之前的选择已经形成了一个有效子集。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,2,3]</span><br><span class="line">初始：path = [] → 保存 []</span><br><span class="line">选择1：path = [1] → 保存 [1]</span><br><span class="line">  选择2：path = [1,2] → 保存 [1,2]</span><br><span class="line">    选择3：path = [1,2,3] → 保存 [1,2,3]</span><br><span class="line">    回溯：path = [1,2]</span><br><span class="line">  回溯：path = [1]</span><br><span class="line">  选择3：path = [1,3] → 保存 [1,3]</span><br><span class="line">  回溯：path = [1]</span><br><span class="line">回溯：path = []</span><br><span class="line">选择2：path = [2] → 保存 [2]</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p><strong>执行过程示例</strong>（<code>nums = [1,2,3]</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">backtrack(0): path=[] → 保存 []</span><br><span class="line">  选择1: path=[1] → 保存 [1]</span><br><span class="line">    backtrack(1): path=[1]</span><br><span class="line">      选择2: path=[1,2] → 保存 [1,2]</span><br><span class="line">        backtrack(2): path=[1,2]</span><br><span class="line">          选择3: path=[1,2,3] → 保存 [1,2,3]</span><br><span class="line">          回溯: path=[1,2]</span><br><span class="line">      回溯: path=[1]</span><br><span class="line">      选择3: path=[1,3] → 保存 [1,3]</span><br><span class="line">      回溯: path=[1]</span><br><span class="line">  回溯: path=[]</span><br><span class="line">  选择2: path=[2] → 保存 [2]</span><br><span class="line">    选择3: path=[2,3] → 保存 [2,3]</span><br><span class="line">  回溯: path=[]</span><br><span class="line">  选择3: path=[3] → 保存 [3]</span><br><span class="line">结果: [[], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]]</span><br></pre></td></tr></table></figure>
<p><strong>常见错误</strong>：</p>
<h3 id="错误一只在叶子节点保存结果">错误一：只在叶子节点保存结果</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start</span>):</span><br><span class="line">    <span class="keyword">if</span> start == <span class="built_in">len</span>(nums):  <span class="comment"># 只在叶子节点保存</span></span><br><span class="line">        result.append(path[:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">        path.append(nums[i])</span><br><span class="line">        backtrack(i + <span class="number">1</span>)</span><br><span class="line">        path.pop()</span><br><span class="line"><span class="comment"># 会漏掉很多子集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start</span>):</span><br><span class="line">    result.append(path[:])  <span class="comment"># 每个状态都保存</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">        path.append(nums[i])</span><br><span class="line">        backtrack(i + <span class="number">1</span>)</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>
<p><strong>方法二：位运算</strong></p>
<p>对于小规模问题，也可以用位运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 每个数字对应一个 bit，共 2^n 种组合</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n):</span><br><span class="line">        subset = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i &amp; (<span class="number">1</span> &lt;&lt; j):</span><br><span class="line">                subset.append(nums[j])</span><br><span class="line">        result.append(subset)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n \times
2^n)\)</span>，共有 <span class="math inline">\(2^n\)</span>
个子集，每个子集需要 <span class="math inline">\(O(n)\)</span>
时间复制。</p>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，递归栈深度为 <span class="math inline">\(n\)</span>。</p>
<h3 id="子集问题的另一种理解">子集问题的另一种理解</h3>
<p>子集问题可以理解为：对于每个元素，我们有两个选择：包含或不包含。因此，对于
<span class="math inline">\(n\)</span> 个元素，共有 <span class="math inline">\(2^n\)</span> 种选择方式，对应 <span class="math inline">\(2^n\)</span> 个子集。</p>
<p>这种理解方式对应了另一种实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">index</span>):</span><br><span class="line">        <span class="comment"># 终止条件：处理完所有元素</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(nums):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 选择1：不包含当前元素</span></span><br><span class="line">        backtrack(index + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 选择2：包含当前元素</span></span><br><span class="line">        path.append(nums[index])</span><br><span class="line">        backtrack(index + <span class="number">1</span>)</span><br><span class="line">        path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>这种实现方式更直观地体现了"每个元素有两个选择"的思想，但两种实现的时间复杂度相同。</p>
<h3 id="子集-ii包含重复元素">子集 II（包含重复元素）</h3>
<p>如果数组包含重复元素，需要去重：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    nums.sort()  <span class="comment"># 排序以便去重</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start</span>):</span><br><span class="line">        result.append(path[:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 剪枝：跳过重复元素</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            backtrack(i + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="经典问题四n-皇后">经典问题四：N 皇后</h2>
<p><strong>LeetCode 51</strong>：<span class="math inline">\(n\)</span>
皇后问题研究的是如何将 <span class="math inline">\(n\)</span>
个皇后放置在 <span class="math inline">\(n \times n\)</span>
的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code>，返回所有不同的 <span class="math inline">\(n\)</span> 皇后问题的解决方案。</p>
<p><strong>皇后攻击规则</strong>：皇后可以攻击与之处在同一行、同一列或同一斜线上的棋子。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>输入：<code>n = 4</code></li>
<li>输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],</span><br><span class="line"> [&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>约束条件</strong>：</p>
<ul>
<li><span class="math inline">\(1 \leq n \leq 9\)</span></li>
</ul>
<h2 id="问题分析-3">问题分析</h2>
<p>N皇后问题是经典的约束满足问题（CSP），要求在 <span class="math inline">\(n \times n\)</span> 棋盘上放置 <span class="math inline">\(n\)</span>
个皇后，使得任意两个皇后不能互相攻击。</p>
<p><strong>核心挑战</strong>：</p>
<ol type="1">
<li><strong>多重约束</strong>：每个皇后不能与其他皇后在同一行、同一列或同一对角线上</li>
<li><strong>对角线判断</strong>：如何高效地判断两个位置是否在同一对角线上</li>
<li><strong>状态恢复</strong>：需要记录和恢复列、对角线的占用状态</li>
</ol>
<p><strong>关键洞察</strong>：</p>
<ul>
<li><strong>行约束</strong>：逐行放置皇后，每行只放一个，自动满足行约束</li>
<li><strong>列约束</strong>：使用集合记录已占用的列</li>
<li><strong>对角线约束</strong>：
<ul>
<li>主对角线（左上到右下）：同一对角线上的格子满足
<code>row - col = 常数</code></li>
<li>副对角线（右上到左下）：同一对角线上的格子满足
<code>row + col = 常数</code></li>
</ul></li>
</ul>
<h2 id="解题思路-3">解题思路</h2>
<p><strong>回溯三要素分析</strong>：</p>
<ul>
<li><strong>选择</strong>：在当前行选择哪一列放置皇后（0 到 n-1）</li>
<li><strong>约束</strong>：
<ul>
<li>该列未被占用</li>
<li>主对角线未被占用（<code>row - col</code> 不在已占用集合中）</li>
<li>副对角线未被占用（<code>row + col</code> 不在已占用集合中）</li>
</ul></li>
<li><strong>目标</strong>：成功放置 <span class="math inline">\(n\)</span> 个皇后（<code>row == n</code>）</li>
</ul>
<p><strong>算法流程</strong>：</p>
<ol type="1">
<li>使用三个集合分别记录已占用的列、主对角线、副对角线</li>
<li>定义回溯函数 <code>backtrack(row)</code>：
<ul>
<li>终止条件：<code>row == n</code>，保存当前棋盘</li>
<li>遍历当前行的所有列</li>
<li>检查约束：列、主对角线、副对角线都未占用</li>
<li>做选择：放置皇后，更新集合</li>
<li>递归处理下一行</li>
<li>撤销选择：移除皇后，恢复集合</li>
</ul></li>
</ol>
<h2 id="复杂度分析-3">复杂度分析</h2>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n!)\)</span></p>
<ul>
<li>第一行有 <span class="math inline">\(n\)</span> 种选择</li>
<li>第二行最多 <span class="math inline">\(n-1\)</span>
种选择（至少有一列被占用）</li>
<li>第三行最多 <span class="math inline">\(n-2\)</span> 种选择</li>
<li>...</li>
<li>总搜索节点数约为 <span class="math inline">\(n \times (n-1) \times
\cdots \times 1 = n!\)</span></li>
<li>实际由于对角线约束，搜索空间更小</li>
</ul>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span></p>
<ul>
<li>递归栈深度：<span class="math inline">\(O(n)\)</span></li>
<li>棋盘：<span class="math inline">\(O(n^2)\)</span></li>
<li>三个集合：<span class="math inline">\(O(n)\)</span></li>
</ul>
<p><strong>复杂度证明</strong>：</p>
<p>虽然理论上第一行有 <span class="math inline">\(n\)</span>
个选择，第二行有 <span class="math inline">\(n\)</span> 个选择，总共
<span class="math inline">\(n^n\)</span>
种可能，但由于列约束和对角线约束，实际搜索空间远小于 <span class="math inline">\(n^n\)</span>。通过剪枝，复杂度降低到 <span class="math inline">\(O(n!)\)</span>。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        N皇后问题：在n×n棋盘上放置n个皇后，使其不互相攻击</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        算法步骤：</span></span><br><span class="line"><span class="string">        1. 初始化棋盘和三个集合（列、主对角线、副对角线）</span></span><br><span class="line"><span class="string">        2. 定义回溯函数backtrack(row)：</span></span><br><span class="line"><span class="string">           a. 终止条件：row == n，保存棋盘</span></span><br><span class="line"><span class="string">           b. 遍历当前行的每一列</span></span><br><span class="line"><span class="string">           c. 约束检查：列、主对角线、副对角线都未占用</span></span><br><span class="line"><span class="string">           d. 做选择：放置皇后，更新集合</span></span><br><span class="line"><span class="string">           e. 递归：backtrack(row + 1)</span></span><br><span class="line"><span class="string">           f. 撤销选择：移除皇后，恢复集合</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        边界条件：</span></span><br><span class="line"><span class="string">        - n=1：返回 [[&quot;Q&quot;]]</span></span><br><span class="line"><span class="string">        - n=2, n=3：无解，返回 []</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        优化技巧：</span></span><br><span class="line"><span class="string">        - 使用集合O(1)判断约束，比遍历检查快</span></span><br><span class="line"><span class="string">        - 逐行放置，自动满足行约束</span></span><br><span class="line"><span class="string">        - 对角线公式：主对角线 row-col，副对角线 row+col</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        变量含义：</span></span><br><span class="line"><span class="string">        - result: 存储所有有效解的列表</span></span><br><span class="line"><span class="string">        - board: n×n棋盘，&#x27;Q&#x27;表示皇后，&#x27;.&#x27;表示空格</span></span><br><span class="line"><span class="string">        - cols: 已占用的列集合</span></span><br><span class="line"><span class="string">        - diag1: 已占用的主对角线集合（row - col）</span></span><br><span class="line"><span class="string">        - diag2: 已占用的副对角线集合（row + col）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        board = [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        cols = <span class="built_in">set</span>()  <span class="comment"># 已占用的列</span></span><br><span class="line">        diag1 = <span class="built_in">set</span>()  <span class="comment"># 主对角线：row - col</span></span><br><span class="line">        diag2 = <span class="built_in">set</span>()  <span class="comment"># 副对角线：row + col</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row</span>):</span><br><span class="line">            <span class="comment"># 终止条件：成功放置n个皇后</span></span><br><span class="line">            <span class="keyword">if</span> row == n:</span><br><span class="line">                <span class="comment"># 转换为题目要求的格式</span></span><br><span class="line">                result.append([<span class="string">&#x27;&#x27;</span>.join(row) <span class="keyword">for</span> row <span class="keyword">in</span> board])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 尝试在当前行的每一列放置皇后</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 约束检查</span></span><br><span class="line">                <span class="keyword">if</span> col <span class="keyword">in</span> cols <span class="keyword">or</span> (row - col) <span class="keyword">in</span> diag1 <span class="keyword">or</span> (row + col) <span class="keyword">in</span> diag2:</span><br><span class="line">                    <span class="keyword">continue</span>  <span class="comment"># 该位置不满足约束，跳过</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                board[row][col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">                cols.add(col)</span><br><span class="line">                diag1.add(row - col)</span><br><span class="line">                diag2.add(row + col)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 递归：处理下一行</span></span><br><span class="line">                backtrack(row + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 撤销选择（回溯）</span></span><br><span class="line">                board[row][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                cols.remove(col)</span><br><span class="line">                diag1.remove(row - col)</span><br><span class="line">                diag2.remove(row + col)</span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>算法原理</strong>：</p>
<p><strong>为什么对角线公式有效</strong>：</p>
<p>对于棋盘上的位置 <span class="math inline">\((r, c)\)</span>： -
<strong>主对角线</strong>：从左上到右下，同一对角线上的格子满足 <span class="math inline">\(r - c = k\)</span>（常数） - 例如：<span class="math inline">\((0,0)\)</span>, <span class="math inline">\((1,1)\)</span>, <span class="math inline">\((2,2)\)</span> 都满足 <span class="math inline">\(r - c = 0\)</span> - 例如：<span class="math inline">\((0,1)\)</span>, <span class="math inline">\((1,2)\)</span>, <span class="math inline">\((2,3)\)</span> 都满足 <span class="math inline">\(r - c = -1\)</span> -
<strong>副对角线</strong>：从右上到左下，同一对角线上的格子满足 <span class="math inline">\(r + c = k\)</span>（常数） - 例如：<span class="math inline">\((0,2)\)</span>, <span class="math inline">\((1,1)\)</span>, <span class="math inline">\((2,0)\)</span> 都满足 <span class="math inline">\(r + c = 2\)</span> - 例如：<span class="math inline">\((0,3)\)</span>, <span class="math inline">\((1,2)\)</span>, <span class="math inline">\((2,1)\)</span>, <span class="math inline">\((3,0)\)</span> 都满足 <span class="math inline">\(r + c = 3\)</span></p>
<p><strong>执行过程示例</strong>（<span class="math inline">\(n =
4\)</span>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">row=0: 尝试col=0, 放置皇后，cols=&#123;0&#125;, diag1=&#123;0&#125;, diag2=&#123;0&#125;</span><br><span class="line">  row=1: 尝试col=0, 冲突（列）</span><br><span class="line">         尝试col=1, 冲突（主对角线：1-1=0）</span><br><span class="line">         尝试col=2, 可行，放置皇后</span><br><span class="line">    row=2: 尝试各列...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p><strong>常见错误</strong>：</p>
<h3 id="错误一对角线判断错误">错误一：对角线判断错误</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：直接用row和col判断</span></span><br><span class="line"><span class="keyword">if</span> board[i][col] == <span class="string">&#x27;Q&#x27;</span>:  <span class="comment"># 需要遍历整个列和对角线，O(n)</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确：使用集合和公式，O(1)</span></span><br><span class="line"><span class="keyword">if</span> col <span class="keyword">in</span> cols <span class="keyword">or</span> (row - col) <span class="keyword">in</span> diag1 <span class="keyword">or</span> (row + col) <span class="keyword">in</span> diag2:</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<h3 id="错误二忘记恢复所有状态">错误二：忘记恢复所有状态</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：只恢复部分状态</span></span><br><span class="line">board[row][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">cols.remove(col)</span><br><span class="line"><span class="comment"># 忘记：diag1.remove(row - col) 和 diag2.remove(row + col)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确：恢复所有状态</span></span><br><span class="line">board[row][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">cols.remove(col)</span><br><span class="line">diag1.remove(row - col)</span><br><span class="line">diag2.remove(row + col)</span><br></pre></td></tr></table></figure>
<h3 id="n-皇后问题的优化技巧">N 皇后问题的优化技巧</h3>
<p><strong>优化一：使用位运算</strong></p>
<p>对于小规模的 N 皇后问题，可以使用位运算来加速约束检查：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">n</span>):</span><br><span class="line">    result = []</span><br><span class="line">    board = [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row, cols, diag1, diag2</span>):</span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            result.append([<span class="string">&#x27;&#x27;</span>.join(row) <span class="keyword">for</span> row <span class="keyword">in</span> board])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算可用的列</span></span><br><span class="line">        available = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &amp; (~(cols | diag1 | diag2))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> available:</span><br><span class="line">            <span class="comment"># 获取最低位的 1</span></span><br><span class="line">            col = available &amp; -available</span><br><span class="line">            col_index = <span class="built_in">bin</span>(col - <span class="number">1</span>).count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            board[row][col_index] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">            backtrack(row + <span class="number">1</span>, </span><br><span class="line">                     cols | col, </span><br><span class="line">                     (diag1 | col) &lt;&lt; <span class="number">1</span>, </span><br><span class="line">                     (diag2 | col) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            board[row][col_index] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 移除最低位的 1</span></span><br><span class="line">            available &amp;= available - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>优化二：只统计解的个数</strong></p>
<p>如果只需要统计解的个数而不需要具体解，可以进一步优化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">totalNQueens</span>(<span class="params">n</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    cols = <span class="built_in">set</span>()</span><br><span class="line">    diag1 = <span class="built_in">set</span>()</span><br><span class="line">    diag2 = <span class="built_in">set</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> col <span class="keyword">in</span> cols <span class="keyword">or</span> (row - col) <span class="keyword">in</span> diag1 <span class="keyword">or</span> (row + col) <span class="keyword">in</span> diag2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            cols.add(col)</span><br><span class="line">            diag1.add(row - col)</span><br><span class="line">            diag2.add(row + col)</span><br><span class="line">            backtrack(row + <span class="number">1</span>)</span><br><span class="line">            cols.remove(col)</span><br><span class="line">            diag1.remove(row - col)</span><br><span class="line">            diag2.remove(row + col)</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p>这种优化避免了构建和保存棋盘状态，只统计解的个数，空间复杂度更低。</p>
<h2 id="经典问题五括号生成">经典问题五：括号生成</h2>
<p><strong>LeetCode 22</strong>：数字 <span class="math inline">\(n\)</span>
代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>输入：<code>n = 3</code></li>
<li>输出：<code>["((()))", "(()())", "(())()", "()(())", "()()()"]</code></li>
</ul>
<p><strong>约束条件</strong>：</p>
<ul>
<li><span class="math inline">\(1 \leq n \leq 8\)</span></li>
</ul>
<h2 id="问题分析-4">问题分析</h2>
<p>括号生成问题要求生成所有有效的括号序列。对于 <span class="math inline">\(n\)</span> 对括号，有效序列的数量等于第 <span class="math inline">\(n\)</span> 个卡特兰数 <span class="math inline">\(C_n\)</span>。</p>
<p><strong>核心挑战</strong>：</p>
<ol type="1">
<li><strong>如何保证括号有效</strong>：任何时候右括号数量不能超过左括号数量</li>
<li><strong>如何避免无效搜索</strong>：通过约束条件提前剪枝</li>
<li><strong>如何系统地生成所有可能性</strong>：使用回溯探索所有选择</li>
</ol>
<p><strong>关键洞察</strong>：</p>
<ul>
<li><strong>约束1</strong>：左括号数量不能超过 <span class="math inline">\(n\)</span></li>
<li><strong>约束2</strong>：右括号数量不能超过左括号数量（否则无法匹配）</li>
<li><strong>终止条件</strong>：生成长度为 <span class="math inline">\(2n\)</span> 的序列</li>
</ul>
<h2 id="解题思路-4">解题思路</h2>
<p><strong>回溯三要素分析</strong>：</p>
<ul>
<li><strong>选择</strong>：当前位置放置左括号 <code>(</code> 还是右括号
<code>)</code></li>
<li><strong>约束</strong>：
<ul>
<li>左括号：<code>left &lt; n</code>（左括号数量未达到上限）</li>
<li>右括号：<code>right &lt; left</code>（右括号数量少于左括号）</li>
</ul></li>
<li><strong>目标</strong>：生成长度为 <span class="math inline">\(2n\)</span>
的有效括号序列（<code>len(path) == 2n</code>）</li>
</ul>
<p><strong>算法流程</strong>：</p>
<ol type="1">
<li>定义回溯函数 <code>backtrack(left, right)</code>：
<ul>
<li><code>left</code>：已使用的左括号数量</li>
<li><code>right</code>：已使用的右括号数量</li>
</ul></li>
<li>终止条件：<code>len(path) == 2n</code>，保存结果</li>
<li>尝试两种选择：
<ul>
<li>如果 <code>left &lt; n</code>，可以放置左括号</li>
<li>如果 <code>right &lt; left</code>，可以放置右括号</li>
</ul></li>
</ol>
<h2 id="复杂度分析-4">复杂度分析</h2>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(\frac{4^n}{\sqrt{n}})\)</span></p>
<p>这是第 <span class="math inline">\(n\)</span>
个卡特兰数的渐近复杂度。第 <span class="math inline">\(n\)</span>
个卡特兰数：</p>
<p><span class="math display">\[C_n = \frac{1}{n+1}\binom{2n}{n} =
\frac{(2n)!}{(n+1)!n!} \approx
\frac{4^n}{n^{3/2}\sqrt{\pi}}\]</span></p>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span></p>
<ul>
<li>递归栈深度：<span class="math inline">\(O(2n) = O(n)\)</span></li>
<li><code>path</code> 数组：<span class="math inline">\(O(2n) =
O(n)\)</span></li>
</ul>
<p><strong>复杂度证明</strong>：</p>
<p>括号序列的数量等于卡特兰数 <span class="math inline">\(C_n\)</span>。对于 <span class="math inline">\(n=3\)</span>，<span class="math inline">\(C_3 =
5\)</span>；对于 <span class="math inline">\(n=4\)</span>，<span class="math inline">\(C_4 = 14\)</span>。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成所有有效的n对括号组合</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        算法步骤：</span></span><br><span class="line"><span class="string">        1. 定义回溯函数backtrack(left, right)：</span></span><br><span class="line"><span class="string">           a. 终止条件：len(path) == 2n，保存结果</span></span><br><span class="line"><span class="string">           b. 选择1：如果left &lt; n，放置左括号&#x27;(&#x27;</span></span><br><span class="line"><span class="string">           c. 选择2：如果right &lt; left，放置右括号&#x27;)&#x27;</span></span><br><span class="line"><span class="string">           d. 每次选择后递归，然后回溯</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        边界条件：</span></span><br><span class="line"><span class="string">        - n=1：返回 [&quot;()&quot;]</span></span><br><span class="line"><span class="string">        - n=0：返回 [&quot;&quot;]（根据约束不会发生）</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        优化技巧：</span></span><br><span class="line"><span class="string">        - 通过约束条件提前剪枝，避免生成无效序列</span></span><br><span class="line"><span class="string">        - 只在right &lt; left时放置右括号，保证有效性</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        变量含义：</span></span><br><span class="line"><span class="string">        - result: 存储所有有效括号序列的列表</span></span><br><span class="line"><span class="string">        - path: 当前正在构建的括号序列</span></span><br><span class="line"><span class="string">        - left: 已使用的左括号数量</span></span><br><span class="line"><span class="string">        - right: 已使用的右括号数量</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        path = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="comment"># 终止条件：生成长度为2n的序列</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">2</span> * n:</span><br><span class="line">                result.append(<span class="string">&#x27;&#x27;</span>.join(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 选择1：放置左括号</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                path.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                backtrack(left + <span class="number">1</span>, right)</span><br><span class="line">                path.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 选择2：放置右括号（需要满足约束）</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left:</span><br><span class="line">                path.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                backtrack(left, right + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>算法原理</strong>：</p>
<p><strong>为什么 <code>right &lt; left</code> 能保证有效</strong>：</p>
<p>括号序列有效的充要条件是： 1. 左右括号数量相等 2.
任何前缀中，左括号数量 ≥ 右括号数量</p>
<p>通过在递归过程中维护
<code>right &lt; left</code>，确保了条件2始终满足。终止时
<code>left == right == n</code>，满足条件1。</p>
<p><strong>卡特兰数的数学背景</strong>：</p>
<p>括号生成问题与卡特兰数密切相关。卡特兰数在组合数学中有很多应用：</p>
<ul>
<li><span class="math inline">\(n\)</span> 对括号的有效序列数</li>
<li><span class="math inline">\(n\)</span>
个节点的不同二叉搜索树数量</li>
<li><span class="math inline">\(n+2\)</span> 边形的三角剖分数</li>
<li>在 <span class="math inline">\(n \times n\)</span>
网格中，从左下角到右上角不越过对角线的路径数</li>
</ul>
<p><strong>执行过程示例</strong>（<code>n = 2</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">backtrack(0,0): path=[]</span><br><span class="line">  选择&#x27;(&#x27;: path=[&#x27;(&#x27;], left=1, right=0</span><br><span class="line">    选择&#x27;(&#x27;: path=[&#x27;(&#x27;,  &#x27;(&#x27;], left=2, right=0</span><br><span class="line">      选择&#x27;)&#x27;: path=[&#x27;(&#x27;, &#x27;(&#x27;, &#x27;)&#x27;], left=2, right=1</span><br><span class="line">        选择&#x27;)&#x27;: path=[&#x27;(&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;)&#x27;] → 保存 &quot;(())&quot;</span><br><span class="line">        回溯: path=[&#x27;(&#x27;, &#x27;(&#x27;, &#x27;)&#x27;]</span><br><span class="line">      回溯: path=[&#x27;(&#x27;, &#x27;(&#x27;]</span><br><span class="line">    回溯: path=[&#x27;(&#x27;]</span><br><span class="line">    选择&#x27;)&#x27;: path=[&#x27;(&#x27;, &#x27;)&#x27;], left=1, right=1</span><br><span class="line">      选择&#x27;(&#x27;: path=[&#x27;(&#x27;, &#x27;)&#x27;, &#x27;(&#x27;], left=2, right=1</span><br><span class="line">        选择&#x27;)&#x27;: path=[&#x27;(&#x27;, &#x27;)&#x27;, &#x27;(&#x27;, &#x27;)&#x27;] → 保存 &quot;()()&quot;</span><br><span class="line">        回溯: path=[&#x27;(&#x27;, &#x27;)&#x27;, &#x27;(&#x27;]</span><br><span class="line">      回溯: path=[&#x27;(&#x27;, &#x27;)&#x27;]</span><br><span class="line">    回溯: path=[&#x27;(&#x27;]</span><br><span class="line">  回溯: path=[]</span><br><span class="line">结果: [&quot;(())&quot;, &quot;()()&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>常见错误</strong>：</p>
<h3 id="错误一没有约束检查">错误一：没有约束检查</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：没有检查left &lt; n和right &lt; left</span></span><br><span class="line">path.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">backtrack(left + <span class="number">1</span>, right)</span><br><span class="line">path.pop()</span><br><span class="line">path.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">backtrack(left, right + <span class="number">1</span>)</span><br><span class="line">path.pop()</span><br><span class="line"><span class="comment"># 会生成无效序列如 &quot;))((&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line"><span class="keyword">if</span> left &lt; n:</span><br><span class="line">    path.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    backtrack(left + <span class="number">1</span>, right)</span><br><span class="line">    path.pop()</span><br><span class="line"><span class="keyword">if</span> right &lt; left:</span><br><span class="line">    path.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    backtrack(left, right + <span class="number">1</span>)</span><br><span class="line">    path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="括号生成问题的数学背景">括号生成问题的数学背景</h3>
<p>括号生成问题与<strong>卡特兰数（Catalan Number）</strong>密切相关。第
<span class="math inline">\(n\)</span> 个卡特兰数表示 <span class="math inline">\(n\)</span>
对括号可以组成的不同有效括号序列的数量。</p>
<p>卡特兰数在组合数学中有很多应用：</p>
<ul>
<li><span class="math inline">\(n\)</span> 对括号的有效序列数</li>
<li><span class="math inline">\(n\)</span>
个节点的不同二叉搜索树数量</li>
<li><span class="math inline">\(n+2\)</span> 边形的三角剖分数</li>
<li>在 <span class="math inline">\(n \times n\)</span>
网格中，从左下角到右上角不越过对角线的路径数</li>
</ul>
<h3 id="括号生成问题的其他解法">括号生成问题的其他解法</h3>
<p><strong>方法一：动态规划</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> left <span class="keyword">in</span> generateParenthesis(i):</span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> generateParenthesis(n - <span class="number">1</span> - i):</span><br><span class="line">                result.append(<span class="string">&#x27;(&#x27;</span> + left + <span class="string">&#x27;)&#x27;</span> + right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>这种方法的思路是：第一个括号内包含 <span class="math inline">\(i\)</span> 对括号，第一个括号外包含 <span class="math inline">\(n-1-i\)</span> 对括号。</p>
<p><strong>方法二：迭代生成</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">n</span>):</span><br><span class="line">    result = [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * n):</span><br><span class="line">        new_result = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> result:</span><br><span class="line">            left_count = s.count(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            right_count = s.count(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> left_count &lt; n:</span><br><span class="line">                new_result.append(s + <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> right_count &lt; left_count:</span><br><span class="line">                new_result.append(s + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        result = new_result</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>这种方法逐字符生成，每次添加一个左括号或右括号，保证始终满足约束条件。</p>
<h2 id="剪枝优化技巧">剪枝优化技巧</h2>
<p>剪枝是回溯算法优化的重要手段，通过提前排除不可能的分支，大幅减少搜索空间。</p>
<h3 id="约束剪枝">1. 约束剪枝</h3>
<p>在进入递归前检查约束条件，不满足则跳过：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">    <span class="keyword">if</span> 不满足约束条件:  <span class="comment"># 剪枝</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 做选择并递归</span></span><br></pre></td></tr></table></figure>
<p><strong>示例</strong>：组合总和问题中，如果剩余值小于
0，直接返回。</p>
<h3 id="重复剪枝">2. 重复剪枝</h3>
<p>对于包含重复元素的问题，通过排序和跳过相同元素避免重复：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 跳过重复元素</span></span><br></pre></td></tr></table></figure>
<h3 id="可行性剪枝">3. 可行性剪枝</h3>
<p>提前判断当前分支是否可能产生解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果剩余元素不足以构成解，剪枝</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) + (n - i) &lt; target_length:</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h3 id="上下界剪枝">4. 上下界剪枝</h3>
<p>在搜索过程中维护上下界，提前排除不可能的范围：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前和 + 剩余最大和 &lt; target，剪枝</span></span><br><span class="line"><span class="keyword">if</span> current_sum + max_remaining_sum &lt; target:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="comment"># 当前和 + 剩余最小和 &gt; target，剪枝</span></span><br><span class="line"><span class="keyword">if</span> current_sum + min_remaining_sum &gt; target:</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h3 id="对称性剪枝">5. 对称性剪枝</h3>
<p>利用问题的对称性减少搜索：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如：全排列中，如果 nums[i] == nums[j]，且 i &lt; j</span></span><br><span class="line"><span class="comment"># 那么选择 nums[i] 和 nums[j] 的结果是对称的</span></span><br><span class="line"><span class="comment"># 可以只选择其中一个</span></span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析">时间复杂度分析</h2>
<p>回溯算法的时间复杂度分析通常比较复杂，因为需要分析所有可能的搜索路径。</p>
<h3 id="一般分析方法">一般分析方法</h3>
<ol type="1">
<li><strong>确定搜索树的大小</strong>：有多少个节点？</li>
<li><strong>确定每个节点的处理时间</strong>：生成子节点需要多少时间？</li>
<li><strong>总时间复杂度</strong> = 节点数 × 每个节点的处理时间</li>
</ol>
<h3 id="常见复杂度">常见复杂度</h3>
<ul>
<li><strong>全排列</strong>：<span class="math inline">\(O(n \times
n!)\)</span>
<ul>
<li>共有 <span class="math inline">\(n!\)</span> 个叶子节点（排列）</li>
<li>每个排列需要 <span class="math inline">\(O(n)\)</span> 时间复制</li>
</ul></li>
<li><strong>子集</strong>：<span class="math inline">\(O(n \times
2^n)\)</span>
<ul>
<li>共有 <span class="math inline">\(2^n\)</span> 个子集</li>
<li>每个子集需要 <span class="math inline">\(O(n)\)</span> 时间复制</li>
</ul></li>
<li><strong>组合</strong>：<span class="math inline">\(O(C(n,k) \times
k)\)</span>
<ul>
<li>共有 <span class="math inline">\(C(n,k)\)</span> 个组合</li>
<li>每个组合需要 <span class="math inline">\(O(k)\)</span> 时间复制</li>
</ul></li>
<li><strong>N 皇后</strong>：<span class="math inline">\(O(n!)\)</span>
<ul>
<li>第一行 <span class="math inline">\(n\)</span> 种选择，第二行最多
<span class="math inline">\(n-1\)</span> 种，以此类推</li>
</ul></li>
</ul>
<h3 id="优化后的复杂度">优化后的复杂度</h3>
<p>剪枝可以大幅减少实际搜索的节点数，但最坏情况复杂度通常不变。平均情况下，剪枝可能将复杂度降低一个数量级。</p>
<h2 id="更多经典问题">更多经典问题</h2>
<h3 id="单词搜索">单词搜索</h3>
<p><strong>问题描述</strong>：给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中"相邻"单元格是那些水平相邻或垂直相邻的单元格。</p>
<p><strong>思路</strong>：从网格的每个位置开始，使用回溯算法搜索单词。需要标记已访问的单元格，回溯时恢复状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">board, word</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row, col, index</span>):</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> row &gt;= m <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> col &gt;= n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> board[row][col] != word[index]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 标记为已访问</span></span><br><span class="line">        temp = board[row][col]</span><br><span class="line">        board[row][col] = <span class="string">&#x27;#&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 尝试四个方向</span></span><br><span class="line">        <span class="keyword">for</span> dr, dc <span class="keyword">in</span> directions:</span><br><span class="line">            <span class="keyword">if</span> backtrack(row + dr, col + dc, index + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 回溯：恢复状态</span></span><br><span class="line">        board[row][col] = temp</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> backtrack(i, j, <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="数独求解">数独求解</h3>
<p><strong>问题描述</strong>：编写一个程序，通过已填充的空格来解决数独问题。数独的解法需遵循规则：数字
1-9 在每一行、每一列和每一个 3x3 宫格内只能出现一次。</p>
<p><strong>思路</strong>：使用回溯算法，逐个填充空格。对于每个空格，尝试
1-9 的所有可能值，检查是否满足约束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solveSudoku</span>(<span class="params">board</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">row, col, num</span>):</span><br><span class="line">        <span class="comment"># 检查行</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[row][j] == num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[i][col] == num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查 3x3 宫格</span></span><br><span class="line">        start_row, start_col = (row // <span class="number">3</span>) * <span class="number">3</span>, (col // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_row, start_row + <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(start_col, start_col + <span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == num:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="string">&#x27;123456789&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span> isValid(i, j, num):</span><br><span class="line">                            board[i][j] = num</span><br><span class="line">                            <span class="keyword">if</span> backtrack():</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                            board[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    backtrack()</span><br></pre></td></tr></table></figure>
<h3 id="复原-ip-地址">复原 IP 地址</h3>
<p><strong>问题描述</strong>：给定一个只包含数字的字符串，复原它并返回所有可能的
IP 地址格式。</p>
<p><strong>思路</strong>：使用回溯算法，将字符串分成四段，每段是 0-255
之间的数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">s</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start</span>):</span><br><span class="line">        <span class="comment"># 终止条件：分成四段且用完所有字符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> start == <span class="built_in">len</span>(s):</span><br><span class="line">                result.append(<span class="string">&#x27;.&#x27;</span>.join(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每段最多 3 位数字</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">min</span>(start + <span class="number">3</span>, <span class="built_in">len</span>(s))):</span><br><span class="line">            segment = s[start:end + <span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 约束检查</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(segment) &gt; <span class="number">1</span> <span class="keyword">and</span> segment[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:  <span class="comment"># 不能有前导 0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(segment) &gt; <span class="number">255</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            path.append(segment)</span><br><span class="line">            backtrack(end + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="常见陷阱与注意事项">常见陷阱与注意事项</h2>
<h3 id="结果保存时未复制">1. 结果保存时未复制</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误</span></span><br><span class="line">result.append(path)  <span class="comment"># path 是引用，后续修改会影响已保存的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line">result.append(path[:])  <span class="comment"># 创建副本</span></span><br></pre></td></tr></table></figure>
<h3 id="状态恢复不完整">2. 状态恢复不完整</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：忘记恢复 used 数组</span></span><br><span class="line">path.pop()</span><br><span class="line"><span class="comment"># used[i] = False  # 遗漏！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line">path.pop()</span><br><span class="line">used[i] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="剪枝条件错误">3. 剪枝条件错误</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：去重剪枝条件写反</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>] <span class="keyword">and</span> used[i-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">continue</span>  <span class="comment"># 应该是 not used[i-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<h3 id="选择列表更新错误">4. 选择列表更新错误</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：在组合问题中从 0 开始选择，导致重复</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):  <span class="comment"># 应该从 start 开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br></pre></td></tr></table></figure>
<h3 id="终止条件遗漏">5. 终止条件遗漏</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：忘记检查边界条件</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">    result.append(path[:])</span><br><span class="line">    <span class="comment"># return  # 遗漏！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">    result.append(path[:])</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h2 id="回溯算法的迭代实现">回溯算法的迭代实现</h2>
<p>虽然回溯算法通常用递归实现，但也可以使用迭代方式。迭代实现使用显式栈来模拟递归调用。</p>
<h3 id="全排列的迭代实现">全排列的迭代实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute_iterative</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    stack = [([], [<span class="literal">False</span>] * <span class="built_in">len</span>(nums))]  <span class="comment"># (path, used)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        path, used = stack.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            result.append(path)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                new_path = path + [nums[i]]</span><br><span class="line">                new_used = used[:]</span><br><span class="line">                new_used[i] = <span class="literal">True</span></span><br><span class="line">                stack.append((new_path, new_used))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="子集的迭代实现">子集的迭代实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsets_iterative</span>(<span class="params">nums</span>):</span><br><span class="line">    result = [[]]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># 对于已有的每个子集，添加当前数字形成新子集</span></span><br><span class="line">        new_subsets = []</span><br><span class="line">        <span class="keyword">for</span> subset <span class="keyword">in</span> result:</span><br><span class="line">            new_subsets.append(subset + [num])</span><br><span class="line">        result.extend(new_subsets)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>迭代实现的优势：</p>
<ul>
<li>避免栈溢出问题</li>
<li>可以更好地控制搜索顺序</li>
<li>在某些情况下可能更高效</li>
</ul>
<p>迭代实现的劣势：</p>
<ul>
<li>代码通常更复杂</li>
<li>状态管理更困难</li>
<li>对于复杂问题，递归实现更直观</li>
</ul>
<h2 id="回溯算法与其他算法的关系">回溯算法与其他算法的关系</h2>
<h3 id="回溯-vs-动态规划">回溯 vs 动态规划</h3>
<p>回溯算法和动态规划都用于解决优化问题，但适用场景不同：</p>
<ul>
<li><strong>回溯算法</strong>：需要找出<strong>所有解</strong>，时间复杂度通常是指数级</li>
<li><strong>动态规划</strong>：需要找出<strong>最优解</strong>，通过记忆化将时间复杂度降低到多项式级</li>
</ul>
<p>有些问题既可以用回溯也可以用动态规划，选择取决于需求：</p>
<ul>
<li>如果需要所有解：用回溯</li>
<li>如果只需要最优解：用动态规划</li>
</ul>
<h3 id="回溯-vs-贪心算法">回溯 vs 贪心算法</h3>
<p>回溯算法和贪心算法都通过做选择来解决问题：</p>
<ul>
<li><strong>回溯算法</strong>：系统地尝试所有选择，如果当前选择不可行就回溯</li>
<li><strong>贪心算法</strong>：每次选择当前看起来最优的选择，不回溯</li>
</ul>
<p>贪心算法通常更快，但只能保证局部最优，不一定得到全局最优解。回溯算法虽然慢，但可以保证找到所有解或全局最优解。</p>
<h3 id="回溯-vs-分支限界">回溯 vs 分支限界</h3>
<p>回溯算法和分支限界（Branch and Bound）都是搜索算法：</p>
<ul>
<li><strong>回溯算法</strong>：深度优先搜索，找到解后继续搜索其他解</li>
<li><strong>分支限界</strong>：广度优先或最佳优先搜索，使用界限函数剪枝</li>
</ul>
<p>分支限界通常用于优化问题，通过界限函数提前排除不可能产生最优解的分支。</p>
<h2 id="实战技巧总结">实战技巧总结</h2>
<ol type="1">
<li><p><strong>先画搜索树</strong>：在编码前画出问题的搜索树，理解选择、约束和目标。</p></li>
<li><p><strong>使用模板</strong>：掌握回溯模板，大部分问题都可以套用。</p></li>
<li><p><strong>注意去重</strong>：对于包含重复元素的问题，排序 +
剪枝是常用方法。</p></li>
<li><p><strong>合理剪枝</strong>：根据问题特点设计剪枝策略，可以大幅提升效率。</p></li>
<li><p><strong>状态管理</strong>：使用合适的数据结构（集合、数组）管理状态，提高约束检查效率。</p></li>
<li><p><strong>边界处理</strong>：仔细处理边界条件，避免数组越界或无限递归。</p></li>
<li><p><strong>调试技巧</strong>：在关键位置打印 <code>path</code>
和选择列表，理解搜索过程。</p></li>
</ol>
<h2 id="qa-回溯算法常见问题">❓ Q&amp;A: 回溯算法常见问题</h2>
<h3 id="q1-回溯算法和-dfs-有什么区别">Q1: 回溯算法和 DFS
有什么区别？</h3>
<p><strong>A</strong>: 回溯算法是 DFS 的一种应用形式。DFS
专注于遍历所有节点，而回溯算法在 DFS
的基础上增加了<strong>状态恢复</strong>机制。回溯算法在递归返回时会撤销之前的选择，恢复到上一个状态，以便尝试其他可能性。没有状态恢复的
DFS 无法解决需要探索所有可能组合的问题。</p>
<h3 id="q2-为什么回溯算法中要用-path-而不是-path">Q2:
为什么回溯算法中要用 <code>path[:]</code> 而不是
<code>path</code>？</h3>
<p><strong>A</strong>: <code>path</code> 是一个列表引用，如果直接
<code>append(path)</code>，保存的是同一个引用。当后续修改
<code>path</code> 时（如
<code>path.pop()</code>），已保存的结果也会被修改。<code>path[:]</code>
创建了 <code>path</code>
的浅拷贝，保存的是独立的副本，后续修改不会影响已保存的结果。</p>
<h3 id="q3-如何判断一个问题是否适合用回溯算法">Q3:
如何判断一个问题是否适合用回溯算法？</h3>
<p><strong>A</strong>: 适合用回溯算法的问题通常具有以下特征： 1.
需要找出所有可能的解（而不是单一最优解） 2. 解可以表示为一系列选择 3.
选择之间有约束关系 4. 可以通过试错的方式探索所有可能性</p>
<p>典型问题包括：排列、组合、子集、N 皇后、数独、括号生成等。</p>
<h3 id="q4-回溯算法的时间复杂度如何分析">Q4:
回溯算法的时间复杂度如何分析？</h3>
<p><strong>A</strong>: 回溯算法的时间复杂度通常是指数级的。分析方法： 1.
确定搜索树的节点数（通常是 <span class="math inline">\(O(2^n)\)</span>
或 <span class="math inline">\(O(n!)\)</span>） 2.
确定每个节点的处理时间（通常是 <span class="math inline">\(O(n)\)</span>
或 <span class="math inline">\(O(1)\)</span>） 3. 总复杂度 = 节点数 ×
每个节点的处理时间</p>
<p>例如，全排列问题有 <span class="math inline">\(n!\)</span>
个叶子节点，每个节点需要 <span class="math inline">\(O(n)\)</span>
时间，总复杂度为 <span class="math inline">\(O(n \times
n!)\)</span>。</p>
<h3 id="q5-如何优化回溯算法的性能">Q5: 如何优化回溯算法的性能？</h3>
<p><strong>A</strong>: 主要优化方法： 1.
<strong>剪枝</strong>：提前排除不可能的分支 2.
<strong>排序</strong>：对输入排序，便于去重和剪枝 3.
<strong>记忆化</strong>：对于重叠子问题，使用记忆化避免重复计算 4.
<strong>约束传播</strong>：利用约束关系提前缩小搜索空间 5.
<strong>启发式搜索</strong>：优先探索更可能产生解的分支</p>
<h3 id="q6-去重剪枝中-usedi-1-的判断逻辑是什么">Q6: 去重剪枝中
<code>used[i-1]</code> 的判断逻辑是什么？</h3>
<p><strong>A</strong>:
在包含重复元素的排列/组合问题中，排序后相同元素会相邻。去重策略是：如果当前元素与前一个元素相同，且前一个元素<strong>未被使用</strong>，则跳过当前元素。</p>
<p>这是因为：如果前一个相同元素未被使用，说明我们在同一层已经尝试过选择它，当前选择会产生重复结果。如果前一个元素已被使用，说明我们在上一层选择了它，当前选择是合法的（因为位置不同）。</p>
<h3 id="q7-组合问题中为什么要从-start-开始选择">Q7: 组合问题中为什么要从
<code>start</code> 开始选择？</h3>
<p><strong>A</strong>:
组合问题要求结果中元素的顺序不重要（<code>[1,2]</code> 和
<code>[2,1]</code> 是同一个组合）。如果从 0
开始选择，会产生重复。例如选择 2 后再选择 1，和选择 1 后再选择 2
是重复的。</p>
<p>从 <code>start</code>
开始选择保证了我们总是按照数组的顺序选择元素，避免了重复组合。每次递归时，<code>start</code>
递增，确保不会选择之前的元素。</p>
<h3 id="q8-回溯算法会栈溢出吗">Q8: 回溯算法会栈溢出吗？</h3>
<p><strong>A</strong>:
可能会。回溯算法使用递归实现，递归深度等于问题的规模。对于大规模问题（如
<span class="math inline">\(n &gt; 20\)</span>
的全排列），递归深度可能很大，导致栈溢出。</p>
<p>解决方法： 1. <strong>迭代实现</strong>：使用显式栈模拟递归 2.
<strong>限制深度</strong>：对于超大规模问题，考虑其他算法 3.
<strong>尾递归优化</strong>：某些语言支持尾递归优化（但 Python
不支持）</p>
<h3 id="q9-如何将回溯算法改为迭代实现">Q9:
如何将回溯算法改为迭代实现？</h3>
<p><strong>A</strong>: 使用显式栈模拟递归过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack_iterative</span>():</span><br><span class="line">    stack = [(初始状态)]</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        state = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">            result.append(state)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">            <span class="keyword">if</span> 满足约束:</span><br><span class="line">                new_state = 更新状态(state, choice)</span><br><span class="line">                stack.append(new_state)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>迭代实现的优势是避免了栈溢出，但代码通常更复杂，状态管理也更困难。</p>
<h3 id="q10-回溯算法可以解决动态规划问题吗">Q10:
回溯算法可以解决动态规划问题吗？</h3>
<p><strong>A</strong>:
理论上可以，但不推荐。回溯算法会探索所有可能的路径，时间复杂度通常是指数级的。动态规划通过记忆化和状态转移，将时间复杂度降低到多项式级别。</p>
<p>例如，0-1 背包问题可以用回溯解决（<span class="math inline">\(O(2^n)\)</span>），但用动态规划可以优化到 <span class="math inline">\(O(n \times
W)\)</span>。只有在需要找出所有解（而不是最优解）时，回溯算法才有优势。</p>
<h3 id="q11-如何调试回溯算法">Q11: 如何调试回溯算法？</h3>
<p><strong>A</strong>: 调试回溯算法的几个技巧：</p>
<ol type="1">
<li><strong>打印路径和状态</strong>：在关键位置打印
<code>path</code>、<code>used</code> 等状态变量</li>
<li><strong>使用调试器</strong>：设置断点，单步执行，观察状态变化</li>
<li><strong>可视化搜索树</strong>：画出问题的搜索树，理解算法的执行流程</li>
<li><strong>小规模测试</strong>：先用小规模数据测试，验证逻辑正确性</li>
<li><strong>对比结果</strong>：与已知正确答案对比，找出差异</li>
</ol>
<h3 id="q12-回溯算法的时间复杂度总是指数级的吗">Q12:
回溯算法的时间复杂度总是指数级的吗？</h3>
<p><strong>A</strong>:
不一定。虽然回溯算法在最坏情况下通常是指数级复杂度，但通过有效的剪枝，实际运行时间可能远小于理论最坏情况。</p>
<p>例如，N 皇后问题的理论复杂度是 <span class="math inline">\(O(n!)\)</span>，但由于约束条件的存在，实际搜索的节点数远小于
<span class="math inline">\(n!\)</span>。对于 <span class="math inline">\(n=8\)</span>，理论上有 <span class="math inline">\(8! = 40320\)</span> 种可能，但实际只需要搜索约
2000 个节点就能找到所有解。</p>
<h3 id="q13-如何选择回溯算法的数据结构">Q13:
如何选择回溯算法的数据结构？</h3>
<p><strong>A</strong>: 选择合适的数据结构可以提升效率：</p>
<ul>
<li><strong>路径存储</strong>：使用列表 <code>list</code>，支持高效的
<code>append</code> 和 <code>pop</code></li>
<li><strong>已访问标记</strong>：使用集合 <code>set</code>
或布尔数组，根据操作频率选择</li>
<li><strong>约束检查</strong>：使用集合可以 <span class="math inline">\(O(1)\)</span> 时间检查，比列表更高效</li>
<li><strong>去重</strong>：使用集合去重，或排序后使用剪枝</li>
</ul>
<p>例如，在全排列问题中，如果频繁检查数字是否已使用，用集合比列表更高效。</p>
<h3 id="q14-回溯算法可以并行化吗">Q14: 回溯算法可以并行化吗？</h3>
<p><strong>A</strong>:
可以，但需要谨慎设计。回溯算法的并行化主要有两种方式：</p>
<ol type="1">
<li><strong>任务级并行</strong>：将搜索树的不同分支分配给不同线程/进程</li>
<li><strong>数据级并行</strong>：并行处理同一层的多个选择</li>
</ol>
<p>并行化的挑战：</p>
<ul>
<li>负载均衡：不同分支的搜索时间可能差异很大</li>
<li>共享状态：需要同步访问共享的结果集</li>
<li>开销：线程/进程创建和通信的开销可能抵消并行化的收益</li>
</ul>
<p>对于大规模问题，并行化可以显著提升性能，但需要仔细设计以避免竞争条件和性能瓶颈。</p>
<h2 id="总结">总结</h2>
<p>回溯算法是解决组合优化问题的强大工具。掌握回溯算法的要点：</p>
<ol type="1">
<li><strong>理解三要素</strong>：选择、约束、目标</li>
<li><strong>掌握模板</strong>：熟练运用回溯模板解决各类问题</li>
<li><strong>学会剪枝</strong>：通过合理的剪枝大幅提升效率</li>
<li><strong>注意细节</strong>：状态恢复、结果复制、去重处理等</li>
</ol>
<p>通过大量练习，回溯算法会成为你解决 LeetCode
问题的得力助手。记住：回溯算法的本质是"试错"，通过系统地探索所有可能性，最终找到所有解。</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>本文标题：LeetCode（八）—— 回溯算法</li>
        <li>本文作者：Chen Kai</li>
        <li>创建时间：2023-07-28 00:00:00</li>
        <li>
            本文链接：https://www.chenk.top/LeetCode%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/LeetCode%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode（十）—— 栈与队列</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/LeetCode%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E6%9E%84%E9%80%A0/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode（六）—— 二叉树遍历与构造</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情赞美帅气伟大的ck吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- 由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">什么是回溯算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%8E-dfs-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.</span> <span class="nav-text">回溯与 DFS 的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%AF%94"><span class="nav-number">2.1.</span> <span class="nav-text">实际应用场景对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">2.2.</span> <span class="nav-text">回溯算法的搜索树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">3.</span> <span class="nav-text">回溯算法的三要素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9choice"><span class="nav-number">3.1.</span> <span class="nav-text">选择（Choice）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9Fconstraint"><span class="nav-number">3.2.</span> <span class="nav-text">约束（Constraint）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87goal"><span class="nav-number">3.3.</span> <span class="nav-text">目标（Goal）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.</span> <span class="nav-text">回溯算法模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8F%98%E4%BD%93"><span class="nav-number">4.1.</span> <span class="nav-text">模板的变体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E4%B8%80%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">经典问题一：全排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">6.</span> <span class="nav-text">问题分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">7.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">8.</span> <span class="nav-text">复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%80%E5%BF%98%E8%AE%B0%E5%88%9B%E5%BB%BA%E8%B7%AF%E5%BE%84%E5%89%AF%E6%9C%AC"><span class="nav-number">8.1.</span> <span class="nav-text">错误一：忘记创建路径副本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BA%8C%E5%BF%98%E8%AE%B0%E6%92%A4%E9%94%80%E9%80%89%E6%8B%A9"><span class="nav-number">8.2.</span> <span class="nav-text">错误二：忘记撤销选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%89%E7%BA%A6%E6%9D%9F%E6%A3%80%E6%9F%A5%E4%BD%8D%E7%BD%AE%E9%94%99%E8%AF%AF"><span class="nav-number">8.3.</span> <span class="nav-text">错误三：约束检查位置错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E7%9A%84%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">8.4.</span> <span class="nav-text">全排列问题的搜索过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97-ii%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">8.5.</span> <span class="nav-text">全排列 II（包含重复元素）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E4%BA%8C%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">9.</span> <span class="nav-text">经典问题二：组合总和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-1"><span class="nav-number">10.</span> <span class="nav-text">问题分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1"><span class="nav-number">11.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="nav-number">12.</span> <span class="nav-text">复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%80%E4%BB%8E0%E5%BC%80%E5%A7%8B%E9%80%89%E6%8B%A9%E5%AF%BC%E8%87%B4%E9%87%8D%E5%A4%8D"><span class="nav-number">12.1.</span> <span class="nav-text">错误一：从0开始选择导致重复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BA%8C%E9%80%92%E5%BD%92%E6%97%B6%E4%BD%BF%E7%94%A8-i1-%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8"><span class="nav-number">12.2.</span> <span class="nav-text">错误二：递归时使用
i+1 导致无法重复使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">12.3.</span> <span class="nav-text">组合总和问题的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii%E6%AF%8F%E4%B8%AA%E6%95%B0%E5%AD%97%E5%8F%AA%E8%83%BD%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AC%A1"><span class="nav-number">12.4.</span> <span class="nav-text">组合总和
II（每个数字只能使用一次）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E4%B8%89%E5%AD%90%E9%9B%86"><span class="nav-number">13.</span> <span class="nav-text">经典问题三：子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-2"><span class="nav-number">14.</span> <span class="nav-text">问题分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2"><span class="nav-number">15.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="nav-number">16.</span> <span class="nav-text">复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%80%E5%8F%AA%E5%9C%A8%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%9C"><span class="nav-number">16.1.</span> <span class="nav-text">错误一：只在叶子节点保存结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%90%86%E8%A7%A3"><span class="nav-number">16.2.</span> <span class="nav-text">子集问题的另一种理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E9%9B%86-ii%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">16.3.</span> <span class="nav-text">子集 II（包含重复元素）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%9B%9Bn-%E7%9A%87%E5%90%8E"><span class="nav-number">17.</span> <span class="nav-text">经典问题四：N 皇后</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-3"><span class="nav-number">18.</span> <span class="nav-text">问题分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3"><span class="nav-number">19.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="nav-number">20.</span> <span class="nav-text">复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%80%E5%AF%B9%E8%A7%92%E7%BA%BF%E5%88%A4%E6%96%AD%E9%94%99%E8%AF%AF"><span class="nav-number">20.1.</span> <span class="nav-text">错误一：对角线判断错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BA%8C%E5%BF%98%E8%AE%B0%E6%81%A2%E5%A4%8D%E6%89%80%E6%9C%89%E7%8A%B6%E6%80%81"><span class="nav-number">20.2.</span> <span class="nav-text">错误二：忘记恢复所有状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="nav-number">20.3.</span> <span class="nav-text">N 皇后问题的优化技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E4%BA%94%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-number">21.</span> <span class="nav-text">经典问题五：括号生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-4"><span class="nav-number">22.</span> <span class="nav-text">问题分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4"><span class="nav-number">23.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-4"><span class="nav-number">24.</span> <span class="nav-text">复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%80%E6%B2%A1%E6%9C%89%E7%BA%A6%E6%9D%9F%E6%A3%80%E6%9F%A5"><span class="nav-number">24.1.</span> <span class="nav-text">错误一：没有约束检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%83%8C%E6%99%AF"><span class="nav-number">24.2.</span> <span class="nav-text">括号生成问题的数学背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B6%E4%BB%96%E8%A7%A3%E6%B3%95"><span class="nav-number">24.3.</span> <span class="nav-text">括号生成问题的其他解法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="nav-number">25.</span> <span class="nav-text">剪枝优化技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F%E5%89%AA%E6%9E%9D"><span class="nav-number">25.1.</span> <span class="nav-text">1. 约束剪枝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E5%89%AA%E6%9E%9D"><span class="nav-number">25.2.</span> <span class="nav-text">2. 重复剪枝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%89%AA%E6%9E%9D"><span class="nav-number">25.3.</span> <span class="nav-text">3. 可行性剪枝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E7%95%8C%E5%89%AA%E6%9E%9D"><span class="nav-number">25.4.</span> <span class="nav-text">4. 上下界剪枝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%89%AA%E6%9E%9D"><span class="nav-number">25.5.</span> <span class="nav-text">5. 对称性剪枝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">26.</span> <span class="nav-text">时间复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="nav-number">26.1.</span> <span class="nav-text">一般分析方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">26.2.</span> <span class="nav-text">常见复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">26.3.</span> <span class="nav-text">优化后的复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="nav-number">27.</span> <span class="nav-text">更多经典问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="nav-number">27.1.</span> <span class="nav-text">单词搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%8B%AC%E6%B1%82%E8%A7%A3"><span class="nav-number">27.2.</span> <span class="nav-text">数独求解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%8E%9F-ip-%E5%9C%B0%E5%9D%80"><span class="nav-number">27.3.</span> <span class="nav-text">复原 IP 地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">28.</span> <span class="nav-text">常见陷阱与注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98%E6%97%B6%E6%9C%AA%E5%A4%8D%E5%88%B6"><span class="nav-number">28.1.</span> <span class="nav-text">1. 结果保存时未复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E4%B8%8D%E5%AE%8C%E6%95%B4"><span class="nav-number">28.2.</span> <span class="nav-text">2. 状态恢复不完整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%AA%E6%9E%9D%E6%9D%A1%E4%BB%B6%E9%94%99%E8%AF%AF"><span class="nav-number">28.3.</span> <span class="nav-text">3. 剪枝条件错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%88%97%E8%A1%A8%E6%9B%B4%E6%96%B0%E9%94%99%E8%AF%AF"><span class="nav-number">28.4.</span> <span class="nav-text">4. 选择列表更新错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6%E9%81%97%E6%BC%8F"><span class="nav-number">28.5.</span> <span class="nav-text">5. 终止条件遗漏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="nav-number">29.</span> <span class="nav-text">回溯算法的迭代实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="nav-number">29.1.</span> <span class="nav-text">全排列的迭代实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E9%9B%86%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="nav-number">29.2.</span> <span class="nav-text">子集的迭代实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">30.</span> <span class="nav-text">回溯算法与其他算法的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-vs-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">30.1.</span> <span class="nav-text">回溯 vs 动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-vs-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">30.2.</span> <span class="nav-text">回溯 vs 贪心算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-vs-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C"><span class="nav-number">30.3.</span> <span class="nav-text">回溯 vs 分支限界</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93"><span class="nav-number">31.</span> <span class="nav-text">实战技巧总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qa-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">32.</span> <span class="nav-text">❓ Q&amp;A: 回溯算法常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#q1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%92%8C-dfs-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">32.1.</span> <span class="nav-text">Q1: 回溯算法和 DFS
有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%AD%E8%A6%81%E7%94%A8-path-%E8%80%8C%E4%B8%8D%E6%98%AF-path"><span class="nav-number">32.2.</span> <span class="nav-text">Q2:
为什么回溯算法中要用 path[:] 而不是
path？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q3-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88%E7%94%A8%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">32.3.</span> <span class="nav-text">Q3:
如何判断一个问题是否适合用回溯算法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q4-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90"><span class="nav-number">32.4.</span> <span class="nav-text">Q4:
回溯算法的时间复杂度如何分析？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q5-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">32.5.</span> <span class="nav-text">Q5: 如何优化回溯算法的性能？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q6-%E5%8E%BB%E9%87%8D%E5%89%AA%E6%9E%9D%E4%B8%AD-usedi-1-%E7%9A%84%E5%88%A4%E6%96%AD%E9%80%BB%E8%BE%91%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">32.6.</span> <span class="nav-text">Q6: 去重剪枝中
used[i-1] 的判断逻辑是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q7-%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BB%8E-start-%E5%BC%80%E5%A7%8B%E9%80%89%E6%8B%A9"><span class="nav-number">32.7.</span> <span class="nav-text">Q7: 组合问题中为什么要从
start 开始选择？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q8-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%E5%90%97"><span class="nav-number">32.8.</span> <span class="nav-text">Q8: 回溯算法会栈溢出吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q9-%E5%A6%82%E4%BD%95%E5%B0%86%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%94%B9%E4%B8%BA%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="nav-number">32.9.</span> <span class="nav-text">Q9:
如何将回溯算法改为迭代实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q10-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%90%97"><span class="nav-number">32.10.</span> <span class="nav-text">Q10:
回溯算法可以解决动态规划问题吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q11-%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">32.11.</span> <span class="nav-text">Q11: 如何调试回溯算法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q12-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E6%98%AF%E6%8C%87%E6%95%B0%E7%BA%A7%E7%9A%84%E5%90%97"><span class="nav-number">32.12.</span> <span class="nav-text">Q12:
回溯算法的时间复杂度总是指数级的吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q13-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">32.13.</span> <span class="nav-text">Q13:
如何选择回溯算法的数据结构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q14-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%B9%B6%E8%A1%8C%E5%8C%96%E5%90%97"><span class="nav-number">32.14.</span> <span class="nav-text">Q14: 回溯算法可以并行化吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">33.</span> <span class="nav-text">总结</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
