<!DOCTYPE html>



<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode（五）—— 二分查找 |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"zh-CN","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode（五）—— 二分查找</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-06-15 00:00:00</span>
        <span class="mobile">2023-06-15 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>8.9k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>35 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>二分查找是算法学习中的经典话题，也是 LeetCode
中高频出现的题型。看似简单的“折半查找”，在实际应用中却有不少细节需要处理：边界条件、循环终止、索引更新……这些细节往往决定了代码的正确性。本文将从原理出发，系统梳理二分查找的核心思想、模板实现和常见题型，帮助你在
LeetCode 中游刃有余。</p>
<span id="more"></span>
<h2 id="二分查找的核心思想">二分查找的核心思想</h2>
<p>二分查找（Binary
Search）是一种在<strong>有序数组</strong>中查找特定元素的算法。它的核心思想可以用一句话概括：<strong>通过比较中间元素与目标值，每次将搜索范围缩小一半</strong>。</p>
<h3 id="为什么需要有序数组">为什么需要有序数组？</h3>
<p>二分查找之所以高效，是因为它利用了数组的有序性。假设我们在一个长度为
<span class="math inline">\(n\)</span> 的有序数组中查找目标值：</p>
<ul>
<li><strong>暴力查找</strong>：最坏情况下需要遍历整个数组，时间复杂度为
<span class="math inline">\(O(n)\)</span></li>
<li><strong>二分查找</strong>：每次比较后可以排除一半的元素，时间复杂度为
<span class="math inline">\(O(\log n)\)</span></li>
</ul>
<p>当 <span class="math inline">\(n=1000\)</span> 时，暴力查找最多需要
<span class="math inline">\(1000\)</span> 次比较，而二分查找最多只需要
<span class="math inline">\(10\)</span> 次（因为 <span class="math inline">\(2^{10} = 1024 &gt; 1000\)</span>）。当 <span class="math inline">\(n\)</span> 增大到 <span class="math inline">\(10^6\)</span> 时，这个差距会更加明显。</p>
<h3 id="算法流程">算法流程</h3>
<p>二分查找的基本流程如下：</p>
<ol type="1">
<li><p><strong>初始化</strong>：设置左右边界 <code>left</code> 和
<code>right</code></p></li>
<li><p><strong>循环条件</strong>：当 <code>left &lt;= right</code>（或
<code>left &lt; right</code>）时继续</p></li>
<li><p><strong>计算中点</strong>：<code>mid = (left + right) / 2</code>
或 <code>mid = left + (right - left) / 2</code></p></li>
<li><p><strong>比较判断</strong>：</p>
<ul>
<li>如果 <code>nums[mid] == target</code>，找到目标，返回
<code>mid</code></li>
<li>如果 <code>nums[mid] &lt; target</code>，目标在右半部分，更新
<code>left = mid + 1</code></li>
<li>如果 <code>nums[mid] &gt; target</code>，目标在左半部分，更新
<code>right = mid - 1</code></li>
</ul></li>
<li><p><strong>未找到</strong>：循环结束后仍未找到，返回
<code>-1</code></p></li>
</ol>
<h3 id="时间复杂度分析">时间复杂度分析</h3>
<p>二分查找的时间复杂度是 <span class="math inline">\(O(\log
n)\)</span>，空间复杂度是 <span class="math inline">\(O(1)\)</span>。</p>
<p><strong>时间复杂度推导</strong>：</p>
<p>设数组长度为 <span class="math inline">\(n\)</span>，每次查找后剩余元素数量为：</p>
<ul>
<li>第 1 次：<span class="math inline">\(n\)</span></li>
<li>第 2 次：<span class="math inline">\(\frac{n}{2}\)</span></li>
<li>第 3 次：<span class="math inline">\(\frac{n}{4}\)</span></li>
<li>...</li>
<li>第 <span class="math inline">\(k\)</span> 次：<span class="math inline">\(\frac{n}{2^{k-1}}\)</span></li>
</ul>
<p>当剩余元素数量为 1 时，查找结束：</p>
<p><span class="math display">\[
\frac{n}{2^{k-1}} = 1
\]</span></p>
<p><span class="math display">\[
n = 2^{k-1}
\]</span></p>
<p><span class="math display">\[
k = \log_2 n + 1
\]</span></p>
<p>因此，最坏情况下需要 <span class="math inline">\(\log_2 n +
1\)</span> 次比较，时间复杂度为 <span class="math inline">\(O(\log
n)\)</span>。</p>
<h2 id="边界处理左闭右开-vs-左闭右闭">边界处理：左闭右开 vs
左闭右闭</h2>
<p>二分查找的实现有两种常见的区间定义方式：<strong>左闭右开</strong>
<code>[left, right)</code> 和 <strong>左闭右闭</strong>
<code>[left, right]</code>。选择不同的区间定义会影响循环条件、索引更新和边界处理。</p>
<h3 id="左闭右闭区间-left-right">左闭右闭区间
<code>[left, right]</code></h3>
<p>在这种定义下，<code>left</code> 和 <code>right</code>
都指向有效的数组索引，区间包含两端。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>初始值：<code>left = 0</code>, <code>right = n - 1</code></li>
<li>循环条件：<code>left &lt;= right</code>（因为
<code>left == right</code> 时区间仍有效）</li>
<li>索引更新：<code>left = mid + 1</code>,
<code>right = mid - 1</code></li>
</ul>
<p><strong>代码模板</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 左闭右闭</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 注意是 &lt;=</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># 目标在右半部分</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span>  <span class="comment"># 目标在左半部分</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 未找到</span></span><br></pre></td></tr></table></figure>
<p><strong>示例</strong>：在 <code>[1, 2, 3, 4, 5]</code> 中查找
<code>3</code></p>
<ul>
<li>初始：<code>left=0, right=4</code>，区间 <code>[0, 4]</code> 包含 5
个元素</li>
<li><code>mid=2</code>, <code>nums[2]=3</code>，找到目标</li>
</ul>
<h3 id="左闭右开区间-left-right">左闭右开区间
<code>[left, right)</code></h3>
<p>在这种定义下，<code>left</code> 指向有效索引，<code>right</code>
指向“边界外”，区间不包含右端点。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>初始值：<code>left = 0</code>, <code>right = n</code>（注意
<code>right</code> 是数组长度）</li>
<li>循环条件：<code>left &lt; right</code>（因为
<code>left == right</code> 时区间为空）</li>
<li>索引更新：<code>left = mid + 1</code>,
<code>right = mid</code>（注意 <code>right</code> 不
<code>-1</code>）</li>
</ul>
<p><strong>代码模板</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)  <span class="comment"># 左闭右开</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> left &lt; right:  <span class="comment"># 注意是 &lt;</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># 目标在右半部分</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid  <span class="comment"># 注意不 -1，因为 right 是开区间</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 未找到</span></span><br></pre></td></tr></table></figure>
<p><strong>示例</strong>：在 <code>[1, 2, 3, 4, 5]</code> 中查找
<code>3</code></p>
<ul>
<li>初始：<code>left=0, right=5</code>，区间 <code>[0, 5)</code> 包含 5
个元素</li>
<li><code>mid=2</code>, <code>nums[2]=3</code>，找到目标</li>
</ul>
<h3 id="两种方式的对比">两种方式的对比</h3>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 39%">
<col style="width: 39%">
</colgroup>
<thead>
<tr>
<th>特性</th>
<th>左闭右闭 <code>[left, right]</code></th>
<th>左闭右开 <code>[left, right)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>初始 <code>right</code></td>
<td><code>len(nums) - 1</code></td>
<td><code>len(nums)</code></td>
</tr>
<tr>
<td>循环条件</td>
<td><code>left &lt;= right</code></td>
<td><code>left &lt; right</code></td>
</tr>
<tr>
<td><code>right</code> 更新</td>
<td><code>right = mid - 1</code></td>
<td><code>right = mid</code></td>
</tr>
<tr>
<td>区间含义</td>
<td>包含两端</td>
<td>不包含右端</td>
</tr>
<tr>
<td>适用场景</td>
<td>传统二分查找</td>
<td>边界查找、插入位置</td>
</tr>
</tbody>
</table>
<p><strong>选择建议</strong>：</p>
<ul>
<li><strong>左闭右闭</strong>：更直观，适合基础二分查找</li>
<li><strong>左闭右开</strong>：在处理边界问题时更方便，如“查找插入位置”</li>
</ul>
<h3 id="防止整数溢出">防止整数溢出</h3>
<p>计算中点时，推荐使用 <code>mid = left + (right - left) // 2</code>
而不是 <code>mid = (left + right) // 2</code>。</p>
<p><strong>原因</strong>：当 <code>left</code> 和 <code>right</code>
都很大时，<code>left + right</code> 可能超出整数范围导致溢出。而
<code>left + (right - left) // 2</code> 等价于
<code>(left + right) // 2</code>，但避免了溢出风险。</p>
<h2 id="二分查找模板">二分查找模板</h2>
<p>根据不同的应用场景，二分查找可以分为三种模板：<strong>基础版</strong>、<strong>左边界查找</strong>和<strong>右边界查找</strong>。</p>
<h3 id="模板一基础二分查找">模板一：基础二分查找</h3>
<p><strong>适用场景</strong>：查找目标值在数组中的位置（假设数组中存在且唯一）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基础二分查找：查找目标值的位置</span></span><br><span class="line"><span class="string">    返回：目标值的索引，不存在返回 -1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="模板二查找左边界">模板二：查找左边界</h3>
<p><strong>适用场景</strong>：查找目标值的<strong>第一个</strong>出现位置（数组中可能有重复元素）。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>当 <code>nums[mid] == target</code>
时，不立即返回，而是继续向左查找</li>
<li>循环结束后，<code>left</code> 指向第一个大于等于 <code>target</code>
的位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_left_boundary</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查找左边界：返回目标值的第一个出现位置</span></span><br><span class="line"><span class="string">    返回：第一个出现位置的索引，不存在返回 -1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># nums[mid] &gt;= target</span></span><br><span class="line">            right = mid - <span class="number">1</span>  <span class="comment"># 继续向左查找</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 检查 left 是否越界，以及 nums[left] 是否等于 target</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>使用左闭右开区间的版本</strong>（更简洁）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_left_boundary</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查找左边界（左闭右开版本）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># nums[mid] &gt;= target</span></span><br><span class="line">            right = mid  <span class="comment"># 注意：right = mid，不 -1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># left 指向第一个大于等于 target 的位置</span></span><br><span class="line">    <span class="keyword">if</span> left == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h3 id="模板三查找右边界">模板三：查找右边界</h3>
<p><strong>适用场景</strong>：查找目标值的<strong>最后一个</strong>出现位置（数组中可能有重复元素）。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>当 <code>nums[mid] == target</code>
时，不立即返回，而是继续向右查找</li>
<li>循环结束后，<code>right</code> 指向最后一个小于等于
<code>target</code> 的位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_right_boundary</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查找右边界：返回目标值的最后一个出现位置</span></span><br><span class="line"><span class="string">    返回：最后一个出现位置的索引，不存在返回 -1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># nums[mid] &lt;= target</span></span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># 继续向右查找</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 检查 right 是否越界，以及 nums[right] 是否等于 target</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> nums[right] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
<p><strong>使用左闭右开区间的版本</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_right_boundary</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查找右边界（左闭右开版本）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># nums[mid] &lt;= target</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># right - 1 指向最后一个小于等于 target 的位置</span></span><br><span class="line">    <span class="keyword">if</span> right == <span class="number">0</span> <span class="keyword">or</span> nums[right - <span class="number">1</span>] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> right - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="模板选择指南">模板选择指南</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>使用的模板</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找唯一目标值</td>
<td>模板一：基础二分查找</td>
</tr>
<tr>
<td>查找第一个出现位置</td>
<td>模板二：查找左边界</td>
</tr>
<tr>
<td>查找最后一个出现位置</td>
<td>模板三：查找右边界</td>
</tr>
<tr>
<td>查找插入位置</td>
<td>模板二：查找左边界（返回 <code>left</code>）</td>
</tr>
</tbody>
</table>
<h2 id="经典-leetcode-题目">经典 LeetCode 题目</h2>
<h3 id="题目一704.-二分查找">题目一：704. 二分查找</h3>
<p><strong>题目描述</strong>：给定一个 <code>n</code>
个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值
<code>target</code>，写一个函数搜索 <code>nums</code> 中的
<code>target</code>，如果目标值存在返回下标，否则返回
<code>-1</code>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：这是最基础的二分查找问题，直接使用模板一即可。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(\log
n)\)</span> <strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span></p>
<h3 id="题目二35.-搜索插入位置">题目二：35. 搜索插入位置</h3>
<p><strong>题目描述</strong>：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：这道题本质上是查找<strong>第一个大于等于目标值</strong>的位置，可以使用查找左边界的模板。</p>
<p><strong>思路</strong>：</p>
<ul>
<li>如果目标值存在，返回其索引</li>
<li>如果目标值不存在，返回它应该插入的位置（即第一个大于它的元素的位置）</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong>：</p>
<ul>
<li>当 <code>nums[mid] &lt; target</code>
时，目标值在右半部分，<code>left = mid + 1</code></li>
<li>当 <code>nums[mid] &gt;= target</code> 时，<code>mid</code>
可能是答案，但需要继续向左查找，<code>right = mid</code></li>
<li>循环结束后，<code>left</code> 指向第一个大于等于 <code>target</code>
的位置，这正是我们要找的插入位置</li>
</ul>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(\log
n)\)</span> <strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span></p>
<h3 id="题目三33.-搜索旋转排序数组">题目三：33. 搜索旋转排序数组</h3>
<p><strong>题目描述</strong>：整数数组 <code>nums</code>
按升序排列，数组中的值<strong>互不相同</strong>。在传递给函数之前，<code>nums</code>
在预先未知的某个下标
<code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了旋转。例如，<code>[0,1,2,4,5,6,7]</code>
在下标 <code>3</code> 处旋转后变为
<code>[4,5,6,7,0,1,2]</code>。给你旋转后的数组 <code>nums</code>
和一个整数 <code>target</code>，如果 <code>nums</code> 中存在这个目标值
<code>target</code>，则返回它的下标，否则返回 <code>-1</code>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：虽然数组被旋转了，但它仍然具有部分有序性。我们可以通过判断
<code>nums[mid]</code> 与 <code>nums[left]</code>
的关系来确定哪一半是有序的。</p>
<p><strong>思路</strong>：</p>
<ol type="1">
<li><p>计算中点 <code>mid</code></p></li>
<li><p>判断 <code>nums[left]</code> 到 <code>nums[mid]</code>
是否有序：</p>
<ul>
<li>如果 <code>nums[left] &lt;= nums[mid]</code>，说明左半部分有序
<ul>
<li>如果 <code>target</code> 在 <code>[nums[left], nums[mid]]</code>
范围内，在左半部分查找</li>
<li>否则在右半部分查找</li>
</ul></li>
<li>否则右半部分有序
<ul>
<li>如果 <code>target</code> 在 <code>[nums[mid], nums[right]]</code>
范围内，在右半部分查找</li>
<li>否则在左半部分查找</li>
</ul></li>
</ul></li>
</ol>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">          </span><br><span class="line">            <span class="comment"># 判断左半部分是否有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= nums[mid]:</span><br><span class="line">                <span class="comment"># 左半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    <span class="comment"># target 在左半部分</span></span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># target 在右半部分</span></span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 右半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    <span class="comment"># target 在右半部分</span></span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># target 在左半部分</span></span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>nums[left] &lt;= nums[mid]</code> 判断左半部分是否有序（注意是
<code>&lt;=</code>，因为 <code>left == mid</code>
时只有一个元素，也算有序）</li>
<li>在有序部分判断 <code>target</code>
是否在范围内时，要注意边界条件</li>
</ul>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(\log
n)\)</span> <strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span></p>
<h3 id="题目四162.-寻找峰值">题目四：162. 寻找峰值</h3>
<p><strong>题目描述</strong>：峰值元素是指其值严格大于左右相邻值的元素。给你一个整数数组
<code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回<strong>任何一个峰值</strong>所在位置即可。你可以假设
<code>nums[-1] = nums[n] = -\infty</code>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 3 是峰值元素，你的函数应该返回其索引 2。</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：这道题的关键在于理解：<strong>只要沿着上升的方向走，一定能找到峰值</strong>。</p>
<p><strong>思路</strong>：</p>
<ol type="1">
<li>如果
<code>nums[mid] &lt; nums[mid + 1]</code>，说明右边有更大的值，峰值在右半部分</li>
<li>否则，峰值在左半部分（包括 <code>mid</code> 本身）</li>
</ol>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 右边有更大的值，峰值在右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 峰值在左半部分（包括 mid）</span></span><br><span class="line">                right = mid</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong>：</p>
<ul>
<li>使用 <code>left &lt; right</code> 而不是
<code>left &lt;= right</code>，因为我们需要比较 <code>nums[mid]</code>
和 <code>nums[mid + 1]</code>，要确保 <code>mid + 1</code> 不越界</li>
<li>当 <code>nums[mid] &lt; nums[mid + 1]</code>
时，说明右边有上升趋势，峰值一定在右边</li>
<li>否则，峰值在左边（可能是 <code>mid</code> 本身）</li>
</ul>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(\log
n)\)</span> <strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span></p>
<h3 id="题目五74.-搜索二维矩阵">题目五：74. 搜索二维矩阵</h3>
<p><strong>题目描述</strong>：编写一个高效的算法来判断
<code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列</li>
<li>每行的第一个整数大于前一行的最后一个整数</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：这个二维矩阵可以看作一个一维有序数组。我们可以：</p>
<ol type="1">
<li>先确定目标值在哪一行（通过比较每行的第一个元素）</li>
<li>再在该行中进行二分查找</li>
</ol>
<p><strong>方法一：两次二分查找</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 第一步：确定在哪一行</span></span><br><span class="line">        row_left, row_right = <span class="number">0</span>, m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> row_left &lt;= row_right:</span><br><span class="line">            row_mid = row_left + (row_right - row_left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[row_mid][<span class="number">0</span>] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row_mid][<span class="number">0</span>] &lt; target:</span><br><span class="line">                row_left = row_mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row_right = row_mid - <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># row_right 指向目标值所在的行（如果存在）</span></span><br><span class="line">        <span class="keyword">if</span> row_right &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 第二步：在该行中查找</span></span><br><span class="line">        target_row = row_right</span><br><span class="line">        col_left, col_right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> col_left &lt;= col_right:</span><br><span class="line">            col_mid = col_left + (col_right - col_left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[target_row][col_mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[target_row][col_mid] &lt; target:</span><br><span class="line">                col_left = col_mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                col_right = col_mid - <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>方法二：一次二分查找（将二维矩阵视为一维数组）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        left, right = <span class="number">0</span>, m * n - <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 将一维索引转换为二维坐标</span></span><br><span class="line">            row = mid // n</span><br><span class="line">            col = mid % n</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][col] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>方法二的优势</strong>：只需要一次二分查找，代码更简洁。</p>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(\log(mn))\)</span>
<strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span></p>
<h2 id="二分答案技巧">二分答案技巧</h2>
<p>二分答案（Binary Search on
Answer）是一种常见的解题技巧，适用于<strong>在答案范围内进行二分查找</strong>的问题。这类问题的特点是：</p>
<ul>
<li>答案在一个确定的范围内</li>
<li>对于某个答案值，我们可以判断它是“太大”还是“太小”</li>
<li>答案具有单调性</li>
</ul>
<h3 id="适用场景">适用场景</h3>
<ol type="1">
<li><strong>最小化最大值</strong>：如“将数组分成 k
个子数组，使得最大子数组和最小”</li>
<li><strong>最大化最小值</strong>：如“在数组中放置 k
个元素，使得最小间距最大”</li>
<li><strong>判定性问题</strong>：如“是否存在某种方案满足条件”</li>
</ol>
<h3 id="解题模板">解题模板</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_answer</span>():</span><br><span class="line">    <span class="comment"># 1. 确定答案的范围</span></span><br><span class="line">    left, right = min_answer, max_answer</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 2. 二分查找答案</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:  <span class="comment"># 或 left &lt;= right，取决于问题</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 3. 判断 mid 是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> check(mid):</span><br><span class="line">            <span class="comment"># mid 满足条件，尝试更小的答案（或更大的，取决于问题）</span></span><br><span class="line">            right = mid  <span class="comment"># 或 left = mid + 1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># mid 不满足条件，需要更大的答案（或更小的）</span></span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># 或 right = mid - 1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># 或 right，取决于问题</span></span><br></pre></td></tr></table></figure>
<h3 id="经典例题875.-爱吃香蕉的珂珂">经典例题：875. 爱吃香蕉的珂珂</h3>
<p><strong>题目描述</strong>：珂珂喜欢吃香蕉。这里有 <code>n</code>
堆香蕉，第 <code>i</code> 堆有 <code>piles[i]</code>
根香蕉。警卫已经离开了，将在 <code>h</code>
小时后回来。珂珂可以决定她吃香蕉的速度
<code>k</code>（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉
<code>k</code> 根。如果这堆香蕉少于 <code>k</code>
根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。返回她可以在
<code>h</code> 小时内吃掉所有香蕉的<strong>最小速度</strong>
<code>k</code>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: piles = [3,6,7,11], h = 8</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<ul>
<li>答案范围：最小速度是 <span class="math inline">\(1\)</span>，最大速度是 <span class="math inline">\(\max(piles)\)</span>（因为速度再大也没有意义）</li>
<li>判断函数：给定速度
<code>k</code>，计算吃完所有香蕉需要的时间，判断是否 <span class="math inline">\(\leq h\)</span></li>
<li>单调性：速度越大，所需时间越少；我们要找最小的满足条件的速度</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minEatingSpeed</span>(<span class="params">self, piles: <span class="type">List</span>[<span class="built_in">int</span>], h: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">1</span>, <span class="built_in">max</span>(piles)</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment"># 计算以速度 mid 吃完所有香蕉需要的时间</span></span><br><span class="line">            time = <span class="built_in">sum</span>((pile + mid - <span class="number">1</span>) // mid <span class="keyword">for</span> pile <span class="keyword">in</span> piles)</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> time &lt;= h:</span><br><span class="line">                <span class="comment"># 时间满足要求，尝试更小的速度</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 时间不够，需要更大的速度</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>(pile + mid - 1) // mid</code> 是向上取整的技巧，等价于 <span class="math inline">\(\lceil \frac{pile}{mid} \rceil\)</span></li>
<li>使用 <code>left &lt; right</code> 和
<code>right = mid</code>，确保找到最小的满足条件的值</li>
</ul>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n
\log(\max(piles)))\)</span>，其中 <span class="math inline">\(n\)</span>
是数组长度 <strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span></p>
<h3 id="更多二分答案题目">更多二分答案题目</h3>
<ol type="1">
<li><strong>410. 分割数组的最大值</strong>：将数组分成 m
个子数组，使得最大子数组和最小</li>
<li><strong>1011. 在 D 天内送达包裹的能力</strong>：在 D
天内运送所有包裹的最小运载能力</li>
<li><strong>1482. 制作 m 束花所需的最少天数</strong>：制作 m
束花所需的最少天数</li>
</ol>
<h2 id="常见错误与调试">常见错误与调试</h2>
<h3 id="错误一死循环">错误一：死循环</h3>
<p><strong>原因</strong>：循环条件或索引更新不当，导致 <code>left</code>
和 <code>right</code> 无法收敛。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误示例</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">        left = mid  <span class="comment"># 错误：应该是 left = mid + 1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid</span><br></pre></td></tr></table></figure>
<p><strong>修复</strong>：确保每次循环都能缩小搜索范围。</p>
<h3 id="错误二索引越界">错误二：索引越界</h3>
<p><strong>原因</strong>：在访问 <code>nums[mid]</code> 或
<code>nums[left]</code>、<code>nums[right]</code> 时没有检查边界。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_left_boundary</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># 错误：没有检查 left 是否越界</span></span><br></pre></td></tr></table></figure>
<p><strong>修复</strong>：在返回前检查索引是否在有效范围内。</p>
<h3 id="错误三整数溢出">错误三：整数溢出</h3>
<p><strong>原因</strong>：使用 <code>(left + right) // 2</code>
计算中点，当 <code>left</code> 和 <code>right</code>
很大时可能溢出。</p>
<p><strong>修复</strong>：使用
<code>left + (right - left) // 2</code>。</p>
<h3 id="错误四边界条件处理不当">错误四：边界条件处理不当</h3>
<p><strong>原因</strong>：没有正确处理目标值不存在、数组为空、目标值在边界外等情况。</p>
<p><strong>调试技巧</strong>：</p>
<ol type="1">
<li><strong>打印中间状态</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;left=<span class="subst">&#123;left&#125;</span>, right=<span class="subst">&#123;right&#125;</span>, mid=<span class="subst">&#123;mid&#125;</span>, nums[mid]=<span class="subst">&#123;nums[mid]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p><strong>测试边界情况</strong>：</p>
<ul>
<li>空数组</li>
<li>只有一个元素</li>
<li>目标值在数组最左/最右</li>
<li>目标值不存在且小于最小值/大于最大值</li>
</ul></li>
<li><p><strong>使用断言</strong>：</p></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="number">0</span> &lt;= left &lt; <span class="built_in">len</span>(nums), <span class="string">f&quot;left=<span class="subst">&#123;left&#125;</span> out of range&quot;</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">0</span> &lt;= right &lt; <span class="built_in">len</span>(nums), <span class="string">f&quot;right=<span class="subst">&#123;right&#125;</span> out of range&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="qa-二分查找常见问题">❓ Q&amp;A: 二分查找常见问题</h2>
<h3 id="q1-什么时候使用-left-right什么时候使用-left-right">Q1:
什么时候使用 <code>left &lt;= right</code>，什么时候使用
<code>left &lt; right</code>？</h3>
<p><strong>A</strong>:</p>
<ul>
<li><strong><code>left &lt;= right</code></strong>：适用于左闭右闭区间
<code>[left, right]</code>。当 <code>left == right</code>
时，区间仍包含一个元素，需要继续查找。</li>
<li><strong><code>left &lt; right</code></strong>：适用于左闭右开区间
<code>[left, right)</code>。当 <code>left == right</code>
时，区间为空，查找结束。</li>
</ul>
<p>选择哪种方式主要看你的区间定义。如果使用左闭右闭，就用
<code>&lt;=</code>；如果使用左闭右开，就用 <code>&lt;</code>。</p>
<h3 id="q2-为什么查找左边界时numsmid-target-不直接返回">Q2:
为什么查找左边界时，<code>nums[mid] == target</code> 不直接返回？</h3>
<p><strong>A</strong>:
因为我们要找的是<strong>第一个</strong>出现的位置。如果直接返回，可能返回的是中间某个位置，而不是最左边的。正确的做法是继续向左查找，直到找到最左边的位置。</p>
<p>例如，在 <code>[1, 2, 2, 2, 3]</code> 中查找 <code>2</code>：</p>
<ul>
<li>如果 <code>mid=2</code> 时直接返回，得到索引 <code>2</code></li>
<li>但第一个 <code>2</code> 的索引是
<code>1</code>，所以应该继续向左查找</li>
</ul>
<h3 id="q3-二分查找一定比线性查找快吗">Q3:
二分查找一定比线性查找快吗？</h3>
<p><strong>A</strong>: 不一定。二分查找的时间复杂度是 <span class="math inline">\(O(\log n)\)</span>，线性查找是 <span class="math inline">\(O(n)\)</span>。但是：</p>
<ul>
<li><strong>预处理成本</strong>：二分查找要求数组有序，如果数组无序，需要先排序（<span class="math inline">\(O(n \log
n)\)</span>）。例如，如果只需要查找一次，排序的成本可能超过直接线性查找的成本。</li>
<li><strong>数据量小</strong>：当数据量很小时（如 <span class="math inline">\(n &lt;
10\)</span>），线性查找可能更快，因为常数因子更小。实际测试表明，当
<span class="math inline">\(n &lt; 8\)</span>
时，线性查找通常更快。</li>
<li><strong>缓存友好性</strong>：线性查找对 CPU
缓存更友好，访问连续内存。二分查找的跳跃访问可能导致缓存未命中，影响性能。</li>
</ul>
<p><strong>实际例子</strong>：</p>
<ul>
<li>场景一：数组已有序，需要查找 1000 次 →
二分查找更优（预处理一次，后续查找都是 <span class="math inline">\(O(\log n)\)</span>）</li>
<li>场景二：数组无序，只查找 1 次 → 线性查找更优（避免排序的 <span class="math inline">\(O(n \log n)\)</span> 成本）</li>
<li>场景三：数组很小（<span class="math inline">\(n = 5\)</span>）→
线性查找可能更快（常数因子更小）</li>
</ul>
<p>因此，如果数组已经有序或需要多次查找，二分查找更优；如果只查找一次且数组无序，线性查找可能更合适。</p>
<h3 id="q4-如何处理有重复元素的数组">Q4: 如何处理有重复元素的数组？</h3>
<p><strong>A</strong>: 使用查找左边界或右边界的模板：</p>
<ul>
<li><strong>查找第一个出现位置</strong>：使用查找左边界的模板</li>
<li><strong>查找最后一个出现位置</strong>：使用查找右边界的模板</li>
<li><strong>查找所有出现位置</strong>：先找左边界，再找右边界，然后返回
<code>[left_boundary, right_boundary]</code></li>
</ul>
<h3 id="q5-二分查找可以用于链表吗">Q5: 二分查找可以用于链表吗？</h3>
<p><strong>A</strong>: 理论上可以，但<strong>不推荐</strong>。因为：</p>
<ul>
<li>链表不支持随机访问，访问 <code>mid</code> 节点需要 <span class="math inline">\(O(n)\)</span> 时间</li>
<li>总时间复杂度会变成 <span class="math inline">\(O(n \log
n)\)</span>，不如直接遍历</li>
</ul>
<p>如果一定要用，可以先遍历一次链表，将节点指针存入数组，然后在数组中进行二分查找。</p>
<h3 id="q6-如何判断一个问题是否可以用二分查找">Q6:
如何判断一个问题是否可以用二分查找？</h3>
<p><strong>A</strong>: 满足以下条件之一即可：</p>
<ol type="1">
<li><strong>有序性</strong>：数组（或答案范围）具有单调性</li>
<li><strong>可判定性</strong>：对于某个值，可以判断它是“太大”还是“太小”</li>
<li><strong>范围性</strong>：答案在一个确定的范围内</li>
</ol>
<p>例如：</p>
<ul>
<li>有序数组查找 → 满足条件 1</li>
<li>旋转数组查找 → 满足条件 1（部分有序）</li>
<li>二分答案问题 → 满足条件 2 和 3</li>
</ul>
<h3 id="q7-mid-left-right-2-和-mid-left-right---left-2-有什么区别">Q7:
<code>mid = (left + right) // 2</code> 和
<code>mid = left + (right - left) // 2</code> 有什么区别？</h3>
<p><strong>A</strong>: 在 Python
中，两者在大多数情况下等价。但在其他语言（如 C++、Java）中：</p>
<ul>
<li><code>(left + right) // 2</code> 可能在 <code>left + right</code>
很大时溢出</li>
<li><code>left + (right - left) // 2</code> 避免了溢出风险</li>
</ul>
<p><strong>建议</strong>：统一使用
<code>left + (right - left) // 2</code>，这样代码更安全、可移植。</p>
<h3 id="q8-二分查找的变种有哪些">Q8: 二分查找的变种有哪些？</h3>
<p><strong>A</strong>: 常见的变种包括：</p>
<ol type="1">
<li><strong>查找插入位置</strong>：35. 搜索插入位置</li>
<li><strong>查找边界</strong>：34.
在排序数组中查找元素的第一个和最后一个位置</li>
<li><strong>旋转数组查找</strong>：33. 搜索旋转排序数组、81.
搜索旋转排序数组 II</li>
<li><strong>二维二分</strong>：74. 搜索二维矩阵、240. 搜索二维矩阵
II</li>
<li><strong>二分答案</strong>：875. 爱吃香蕉的珂珂、410.
分割数组的最大值</li>
<li><strong>峰值查找</strong>：162. 寻找峰值</li>
</ol>
<h3 id="q9-如何记忆二分查找的模板">Q9: 如何记忆二分查找的模板？</h3>
<p><strong>A</strong>: 建议：</p>
<ol type="1">
<li><strong>理解原理</strong>：理解为什么这样写，而不是死记硬背</li>
<li><strong>固定一种写法</strong>：选择一种区间定义（推荐左闭右开），然后一直用这种写法</li>
<li><strong>多练习</strong>：通过刷题加深理解，形成肌肉记忆</li>
<li><strong>画图辅助</strong>：遇到边界问题时，画图帮助理解</li>
</ol>
<h3 id="q10-二分查找在实际开发中的应用场景">Q10:
二分查找在实际开发中的应用场景？</h3>
<p><strong>A</strong>:</p>
<ol type="1">
<li><strong>数据库索引</strong>：B+
树索引使用二分查找定位数据页。例如，MySQL 的 InnoDB
引擎在查找索引时，会从根节点开始，通过二分查找快速定位到目标数据所在的叶子节点。</li>
<li><strong>系统调用</strong>：如 Linux 内核中的 <code>bsearch()</code>
函数，用于在有序数组中快速查找。许多系统库函数内部都使用二分查找优化性能。</li>
<li><strong>游戏开发</strong>：在有序数据中查找（如排行榜、装备属性）。例如，在排行榜系统中，需要根据分数快速定位玩家的排名，二分查找可以高效完成这个任务。</li>
<li><strong>算法优化</strong>：将 <span class="math inline">\(O(n)\)</span> 的查找优化为 <span class="math inline">\(O(\log
n)\)</span>。例如，在动态规划问题中，如果状态转移需要查找，可以用二分查找将时间复杂度从
<span class="math inline">\(O(n^2)\)</span> 优化到 <span class="math inline">\(O(n \log n)\)</span>。</li>
<li><strong>数值计算</strong>：求解方程的根、优化问题等。例如，使用二分法求解
<span class="math inline">\(f(x) = 0\)</span>
的根，当函数单调时，二分查找可以快速收敛到解。</li>
</ol>
<h2 id="变体与扩展问题">变体与扩展问题</h2>
<h3 id="变体一在旋转数组中查找">变体一：在旋转数组中查找</h3>
<p>旋转数组虽然整体无序，但至少有一半是有序的，可以利用这个性质进行二分查找。</p>
<p><strong>关键技巧</strong>：</p>
<ol type="1">
<li>判断哪一半是有序的：<code>nums[left] &lt;= nums[mid]</code>
说明左半部分有序</li>
<li>在有序部分判断目标是否在范围内</li>
<li>如果不在有序部分，在无序部分继续查找</li>
</ol>
<p><strong>扩展题目</strong>：</p>
<ul>
<li><ol start="33" type="1">
<li>搜索旋转排序数组（无重复）</li>
</ol></li>
<li><ol start="81" type="1">
<li>搜索旋转排序数组 II（有重复，需要特殊处理）</li>
</ol></li>
<li><ol start="153" type="1">
<li>寻找旋转排序数组中的最小值</li>
</ol></li>
<li><ol start="154" type="1">
<li>寻找旋转排序数组中的最小值 II（有重复）</li>
</ol></li>
</ul>
<h3 id="变体二二维二分查找">变体二：二维二分查找</h3>
<p>二维矩阵也可以进行二分查找，关键在于将二维索引转换为一维索引。</p>
<p><strong>转换公式</strong>：</p>
<ul>
<li>一维索引 <code>idx</code> →
二维坐标：<code>row = idx // n</code>，<code>col = idx % n</code></li>
<li>二维坐标 <code>(row, col)</code> →
一维索引：<code>idx = row * n + col</code></li>
</ul>
<p><strong>扩展题目</strong>：</p>
<ul>
<li><ol start="74" type="1">
<li>搜索二维矩阵（每行第一个数大于上一行最后一个数）</li>
</ol></li>
<li><ol start="240" type="1">
<li>搜索二维矩阵 II（每行每列都递增，更复杂）</li>
</ol></li>
</ul>
<h3 id="变体三二分答案">变体三：二分答案</h3>
<p>当答案在一个范围内，且可以判断某个值是否满足条件时，可以用二分查找在答案范围内搜索。</p>
<p><strong>解题步骤</strong>：</p>
<ol type="1">
<li>确定答案的范围 <code>[left, right]</code></li>
<li>写判断函数 <code>check(mid)</code>：判断 <code>mid</code>
是否满足条件</li>
<li>根据判断结果缩小搜索范围</li>
<li>返回最优答案</li>
</ol>
<p><strong>经典题目</strong>：</p>
<ul>
<li><ol start="875" type="1">
<li>爱吃香蕉的珂珂</li>
</ol></li>
<li><ol start="410" type="1">
<li>分割数组的最大值</li>
</ol></li>
<li><ol start="1011" type="1">
<li>在 D 天内送达包裹的能力</li>
</ol></li>
<li><ol start="1482" type="1">
<li>制作 m 束花所需的最少天数</li>
</ol></li>
</ul>
<h3 id="变体四查找峰值">变体四：查找峰值</h3>
<p>即使数组不完全有序，只要满足某些性质（如单峰、双峰），也可以用二分查找。</p>
<p><strong>关键思想</strong>：沿着上升的方向走，一定能找到峰值。</p>
<p><strong>扩展题目</strong>：</p>
<ul>
<li><ol start="162" type="1">
<li>寻找峰值</li>
</ol></li>
<li><ol start="852" type="1">
<li>山脉数组的峰顶索引</li>
</ol></li>
</ul>
<h2 id="常见错误与调试技巧">常见错误与调试技巧</h2>
<h3 id="错误一死循环-1">错误一：死循环</h3>
<p><strong>原因</strong>：循环条件与边界更新不匹配。</p>
<p><strong>错误示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误：使用 left &lt; right 但 right = mid - 1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid - <span class="number">1</span>  <span class="comment"># 可能导致死循环</span></span><br></pre></td></tr></table></figure>
<p><strong>修复方法</strong>：</p>
<ul>
<li>如果使用 <code>left &lt;= right</code>，用
<code>right = mid - 1</code></li>
<li>如果使用 <code>left &lt; right</code>，用
<code>right = mid</code></li>
</ul>
<h3 id="错误二索引越界-1">错误二：索引越界</h3>
<p><strong>原因</strong>：返回前没有检查索引是否在有效范围内。</p>
<p><strong>错误示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_left_boundary</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># 错误：没有检查 left 是否越界</span></span><br></pre></td></tr></table></figure>
<p><strong>修复方法</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查索引是否越界</span></span><br><span class="line"><span class="keyword">if</span> left &gt;= <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h3 id="错误三整数溢出-1">错误三：整数溢出</h3>
<p><strong>原因</strong>：使用 <code>(left + right) // 2</code>
计算中点。</p>
<p><strong>修复方法</strong>：统一使用
<code>left + (right - left) // 2</code></p>
<h3 id="错误四边界条件处理不当-1">错误四：边界条件处理不当</h3>
<p><strong>常见边界情况</strong>：</p>
<ul>
<li>空数组：<code>len(nums) == 0</code></li>
<li>单个元素：<code>len(nums) == 1</code></li>
<li>目标值在数组最左/最右</li>
<li>目标值不存在且小于最小值/大于最大值</li>
<li>数组中有重复元素</li>
</ul>
<p><strong>调试技巧</strong>：</p>
<ol type="1">
<li><strong>打印中间状态</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;left=<span class="subst">&#123;left&#125;</span>, right=<span class="subst">&#123;right&#125;</span>, mid=<span class="subst">&#123;mid&#125;</span>, nums[mid]=<span class="subst">&#123;nums[mid]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>使用断言</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="number">0</span> &lt;= left &lt; <span class="built_in">len</span>(nums), <span class="string">f&quot;left=<span class="subst">&#123;left&#125;</span> out of range&quot;</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">0</span> &lt;= right &lt; <span class="built_in">len</span>(nums), <span class="string">f&quot;right=<span class="subst">&#123;right&#125;</span> out of range&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><p><strong>测试用例</strong>：</p>
<ul>
<li><code>[]</code>（空数组）</li>
<li><code>[1]</code>（单个元素）</li>
<li><code>[1, 2, 3]</code>，target = 1（在边界）</li>
<li><code>[1, 2, 3]</code>，target = 0（不存在且小于最小值）</li>
<li><code>[1, 2, 2, 2, 3]</code>，target = 2（有重复）</li>
</ul></li>
</ol>
<h2 id="实战建议">实战建议</h2>
<h3 id="如何快速识别二分查找问题">如何快速识别二分查找问题</h3>
<p>看到以下特征时，考虑二分查找：</p>
<ol type="1">
<li><strong>有序数组</strong>：数组已经排序（或可以排序）</li>
<li><strong>查找目标</strong>：需要找到某个值、位置、或满足条件的值</li>
<li><strong>时间复杂度要求</strong>：要求 <span class="math inline">\(O(\log n)\)</span> 时间复杂度</li>
<li><strong>答案范围</strong>：答案在一个确定的范围内（二分答案）</li>
</ol>
<h3 id="选择模板的决策树">选择模板的决策树</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">问题要求什么？</span><br><span class="line">├─ 查找唯一目标值 → 使用标准模板</span><br><span class="line">├─ 查找第一个出现位置 → 使用左边界模板</span><br><span class="line">├─ 查找最后一个出现位置 → 使用右边界模板</span><br><span class="line">└─ 查找插入位置 → 使用左边界模板（返回 left）</span><br></pre></td></tr></table></figure>
<h3 id="解题步骤">解题步骤</h3>
<ol type="1">
<li><strong>确定搜索空间</strong>：是在数组中搜索，还是在答案范围内搜索？</li>
<li><strong>选择模板</strong>：根据问题要求选择合适的模板</li>
<li><strong>确定循环条件</strong>：<code>left &lt;= right</code> 还是
<code>left &lt; right</code>？</li>
<li><strong>写判断逻辑</strong>：如何根据 <code>nums[mid]</code> 和
<code>target</code> 的关系更新边界？</li>
<li><strong>处理边界情况</strong>：空数组、单个元素、目标不存在等</li>
<li><strong>验证答案</strong>：检查返回值的正确性</li>
</ol>
<h3 id="性能优化建议">性能优化建议</h3>
<ol type="1">
<li><strong>提前终止</strong>：如果找到目标值，可以立即返回</li>
<li><strong>减少比较次数</strong>：合并相似的条件判断</li>
<li><strong>空间优化</strong>：如果只需要索引，不需要存储完整数组</li>
</ol>
<h3 id="与其他算法的结合">与其他算法的结合</h3>
<ol type="1">
<li><strong>二分查找 +
滑动窗口</strong>：窗口大小不确定时，用二分查找确定最优大小</li>
<li><strong>二分查找 + 动态规划</strong>：DP
状态转移需要查找时，用二分优化</li>
<li><strong>二分查找 +
贪心</strong>：贪心策略需要验证时，用二分查找答案</li>
</ol>
<h2 id="总结">总结</h2>
<p>二分查找是一种高效且实用的算法，掌握它需要：</p>
<ol type="1">
<li><strong>理解核心思想</strong>：利用有序性，每次排除一半元素</li>
<li><strong>掌握边界处理</strong>：理解左闭右开和左闭右闭的区别</li>
<li><strong>熟练使用模板</strong>：基础查找、左边界、右边界三种模板</li>
<li><strong>灵活应用</strong>：能够识别可以使用二分查找的问题，包括二分答案类问题</li>
<li><strong>注意细节</strong>：防止溢出、处理边界条件、避免死循环</li>
</ol>
<p>通过系统学习和大量练习，你一定能在 LeetCode
中游刃有余地解决二分查找相关的问题。记住：<strong>理解原理比记忆模板更重要</strong>，只有真正理解了，才能灵活应对各种变种题目。</p>
<h2 id="二分查找在面试中的应用">二分查找在面试中的应用</h2>
<p>二分查找是技术面试中的高频考点，不仅考察算法实现能力，还考察对边界条件的处理和对问题本质的理解。掌握以下要点，能帮助你在面试中脱颖而出。</p>
<h3 id="面试官常问的问题类型">面试官常问的问题类型</h3>
<ol type="1">
<li><p><strong>基础实现类</strong>：直接要求实现二分查找</p>
<ul>
<li>考察点：边界处理、溢出防护、代码规范性</li>
<li>示例：LeetCode 704（二分查找）</li>
</ul></li>
<li><p><strong>边界查找类</strong>：查找第一个或最后一个出现位置</p>
<ul>
<li>考察点：理解左边界和右边界的区别，处理重复元素</li>
<li>示例：LeetCode 34（在排序数组中查找元素的第一个和最后一个位置）</li>
</ul></li>
<li><p><strong>变种问题类</strong>：旋转数组、二维矩阵、峰值查找</p>
<ul>
<li>考察点：能否识别可以使用二分查找的场景，灵活应用模板</li>
<li>示例：LeetCode 33（搜索旋转排序数组）、LeetCode 162（寻找峰值）</li>
</ul></li>
<li><p><strong>二分答案类</strong>：在答案范围内进行二分查找</p>
<ul>
<li>考察点：能否识别问题的单调性，设计判断函数</li>
<li>示例：LeetCode 875（爱吃香蕉的珂珂）、LeetCode
410（分割数组的最大值）</li>
</ul></li>
</ol>
<h3 id="面试中的常见陷阱">面试中的常见陷阱</h3>
<ol type="1">
<li><p><strong>边界条件处理</strong>：面试官可能会故意给出边界测试用例</p>
<ul>
<li>空数组：<code>[]</code></li>
<li>单个元素：<code>[1]</code></li>
<li>目标值在边界：<code>[1, 2, 3]</code>，target = 1 或 3</li>
<li>目标值不存在：<code>[1, 2, 3]</code>，target = 0 或 4</li>
</ul></li>
<li><p><strong>整数溢出</strong>：如果使用
<code>(left + right) // 2</code>，面试官可能会问为什么不用
<code>left + (right - left) // 2</code></p></li>
<li><p><strong>死循环问题</strong>：循环条件和边界更新不匹配，导致死循环</p></li>
</ol>
<h3 id="面试答题技巧">面试答题技巧</h3>
<ol type="1">
<li><p><strong>先确认理解</strong>：在开始编码前，先和面试官确认问题的理解，包括：</p>
<ul>
<li>数组是否有序？</li>
<li>是否有重复元素？</li>
<li>返回值的要求（索引、布尔值、插入位置等）？</li>
</ul></li>
<li><p><strong>说明思路</strong>：编码前先说明你的思路，包括：</p>
<ul>
<li>选择哪个模板（标准、左边界、右边界）</li>
<li>为什么选择这个模板</li>
<li>如何处理边界情况</li>
</ul></li>
<li><p><strong>边写边解释</strong>：编码时解释关键步骤，特别是：</p>
<ul>
<li>为什么选择这个循环条件（<code>left &lt;= right</code> vs
<code>left &lt; right</code>）</li>
<li>为什么这样更新边界（<code>right = mid - 1</code> vs
<code>right = mid</code>）</li>
<li>如何防止溢出</li>
</ul></li>
<li><p><strong>测试用例</strong>：编码完成后，主动提出测试用例：</p>
<ul>
<li>正常情况：目标值存在</li>
<li>边界情况：目标值在边界、不存在、数组为空</li>
<li>特殊情况：有重复元素</li>
</ul></li>
<li><p><strong>复杂度分析</strong>：主动分析时间和空间复杂度，展示你的算法分析能力</p></li>
</ol>
<h3 id="常见面试问题示例">常见面试问题示例</h3>
<p><strong>问题</strong>：在一个有序数组中查找目标值的第一个出现位置，如果不存在则返回
-1。</p>
<p><strong>回答思路</strong>：</p>
<ol type="1">
<li>这是典型的左边界查找问题，应该使用左边界模板</li>
<li>使用左闭右开区间 <code>[left, right)</code>，循环条件
<code>left &lt; right</code></li>
<li>当 <code>nums[mid] &gt;= target</code>
时，<code>right = mid</code>（保留 mid，因为可能是答案）</li>
<li>循环结束后，<code>left</code> 指向第一个大于等于 target 的位置</li>
<li>需要检查 <code>left</code> 是否越界，以及 <code>nums[left]</code>
是否等于 target</li>
</ol>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_first_occurrence</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> left == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(\log
n)\)</span>，每次循环排除一半元素</li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span>，只使用了常数个变量</li>
</ul>
<p>通过这样的回答，既展示了你的代码能力，又体现了你对算法原理的深入理解，这正是面试官希望看到的。</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>本文标题：LeetCode（五）—— 二分查找</li>
        <li>本文作者：Chen Kai</li>
        <li>创建时间：2023-06-15 00:00:00</li>
        <li>
            本文链接：https://www.chenk.top/LeetCode%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/LeetCode%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode（八）—— 栈与队列</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/LeetCode%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode（二）—— 双指针技巧</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情赞美帅气伟大的ck吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- 由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">1.</span> <span class="nav-text">二分查找的核心思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.</span> <span class="nav-text">为什么需要有序数组？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">算法流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">1.3.</span> <span class="nav-text">时间复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80-vs-%E5%B7%A6%E9%97%AD%E5%8F%B3%E9%97%AD"><span class="nav-number">2.</span> <span class="nav-text">边界处理：左闭右开 vs
左闭右闭</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E9%97%AD%E5%8F%B3%E9%97%AD%E5%8C%BA%E9%97%B4-left-right"><span class="nav-number">2.1.</span> <span class="nav-text">左闭右闭区间
[left, right]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80%E5%8C%BA%E9%97%B4-left-right"><span class="nav-number">2.2.</span> <span class="nav-text">左闭右开区间
[left, right)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">2.3.</span> <span class="nav-text">两种方式的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="nav-number">2.4.</span> <span class="nav-text">防止整数溢出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.</span> <span class="nav-text">二分查找模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%80%E5%9F%BA%E7%A1%80%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">3.1.</span> <span class="nav-text">模板一：基础二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%BA%8C%E6%9F%A5%E6%89%BE%E5%B7%A6%E8%BE%B9%E7%95%8C"><span class="nav-number">3.2.</span> <span class="nav-text">模板二：查找左边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%89%E6%9F%A5%E6%89%BE%E5%8F%B3%E8%BE%B9%E7%95%8C"><span class="nav-number">3.3.</span> <span class="nav-text">模板三：查找右边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97"><span class="nav-number">3.4.</span> <span class="nav-text">模板选择指南</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8-leetcode-%E9%A2%98%E7%9B%AE"><span class="nav-number">4.</span> <span class="nav-text">经典 LeetCode 题目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%80704.-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">4.1.</span> <span class="nav-text">题目一：704. 二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%8C35.-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="nav-number">4.2.</span> <span class="nav-text">题目二：35. 搜索插入位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%8933.-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">4.3.</span> <span class="nav-text">题目三：33. 搜索旋转排序数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%9B%9B162.-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="nav-number">4.4.</span> <span class="nav-text">题目四：162. 寻找峰值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%9474.-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="nav-number">4.5.</span> <span class="nav-text">题目五：74. 搜索二维矩阵</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E6%8A%80%E5%B7%A7"><span class="nav-number">5.</span> <span class="nav-text">二分答案技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.1.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.2.</span> <span class="nav-text">解题模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98875.-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82"><span class="nav-number">5.3.</span> <span class="nav-text">经典例题：875. 爱吃香蕉的珂珂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E9%A2%98%E7%9B%AE"><span class="nav-number">5.4.</span> <span class="nav-text">更多二分答案题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="nav-number">6.</span> <span class="nav-text">常见错误与调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%80%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="nav-number">6.1.</span> <span class="nav-text">错误一：死循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BA%8C%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C"><span class="nav-number">6.2.</span> <span class="nav-text">错误二：索引越界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%89%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="nav-number">6.3.</span> <span class="nav-text">错误三：整数溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%9B%9B%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86%E4%B8%8D%E5%BD%93"><span class="nav-number">6.4.</span> <span class="nav-text">错误四：边界条件处理不当</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qa-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">❓ Q&amp;A: 二分查找常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#q1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8-left-right%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8-left-right"><span class="nav-number">7.1.</span> <span class="nav-text">Q1:
什么时候使用 left &lt;&#x3D; right，什么时候使用
left &lt; right？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q2-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9F%A5%E6%89%BE%E5%B7%A6%E8%BE%B9%E7%95%8C%E6%97%B6numsmid-target-%E4%B8%8D%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E"><span class="nav-number">7.2.</span> <span class="nav-text">Q2:
为什么查找左边界时，nums[mid] &#x3D;&#x3D; target 不直接返回？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q3-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%80%E5%AE%9A%E6%AF%94%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E5%BF%AB%E5%90%97"><span class="nav-number">7.3.</span> <span class="nav-text">Q3:
二分查找一定比线性查找快吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q4-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">7.4.</span> <span class="nav-text">Q4: 如何处理有重复元素的数组？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q5-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E9%93%BE%E8%A1%A8%E5%90%97"><span class="nav-number">7.5.</span> <span class="nav-text">Q5: 二分查找可以用于链表吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q6-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">7.6.</span> <span class="nav-text">Q6:
如何判断一个问题是否可以用二分查找？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q7-mid-left-right-2-%E5%92%8C-mid-left-right---left-2-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">7.7.</span> <span class="nav-text">Q7:
mid &#x3D; (left + right) &#x2F;&#x2F; 2 和
mid &#x3D; left + (right - left) &#x2F;&#x2F; 2 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q8-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%8F%98%E7%A7%8D%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">7.8.</span> <span class="nav-text">Q8: 二分查找的变种有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q9-%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BF%86%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">7.9.</span> <span class="nav-text">Q9: 如何记忆二分查找的模板？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q10-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">7.10.</span> <span class="nav-text">Q10:
二分查找在实际开发中的应用场景？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%8E%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98"><span class="nav-number">8.</span> <span class="nav-text">变体与扩展问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%80%E5%9C%A8%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="nav-number">8.1.</span> <span class="nav-text">变体一：在旋转数组中查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%BA%8C%E4%BA%8C%E7%BB%B4%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">8.2.</span> <span class="nav-text">变体二：二维二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%89%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88"><span class="nav-number">8.3.</span> <span class="nav-text">变体三：二分答案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E5%9B%9B%E6%9F%A5%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="nav-number">8.4.</span> <span class="nav-text">变体四：查找峰值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">9.</span> <span class="nav-text">常见错误与调试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%80%E6%AD%BB%E5%BE%AA%E7%8E%AF-1"><span class="nav-number">9.1.</span> <span class="nav-text">错误一：死循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BA%8C%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C-1"><span class="nav-number">9.2.</span> <span class="nav-text">错误二：索引越界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%89%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA-1"><span class="nav-number">9.3.</span> <span class="nav-text">错误三：整数溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%9B%9B%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86%E4%B8%8D%E5%BD%93-1"><span class="nav-number">9.4.</span> <span class="nav-text">错误四：边界条件处理不当</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E5%BB%BA%E8%AE%AE"><span class="nav-number">10.</span> <span class="nav-text">实战建议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%AF%86%E5%88%AB%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98"><span class="nav-number">10.1.</span> <span class="nav-text">如何快速识别二分查找问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91"><span class="nav-number">10.2.</span> <span class="nav-text">选择模板的决策树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="nav-number">10.3.</span> <span class="nav-text">解题步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-number">10.4.</span> <span class="nav-text">性能优化建议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95%E7%9A%84%E7%BB%93%E5%90%88"><span class="nav-number">10.5.</span> <span class="nav-text">与其他算法的结合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">12.</span> <span class="nav-text">二分查找在面试中的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E5%B8%B8%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98%E7%B1%BB%E5%9E%8B"><span class="nav-number">12.1.</span> <span class="nav-text">面试官常问的问题类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1"><span class="nav-number">12.2.</span> <span class="nav-text">面试中的常见陷阱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E6%8A%80%E5%B7%A7"><span class="nav-number">12.3.</span> <span class="nav-text">面试答题技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E7%A4%BA%E4%BE%8B"><span class="nav-number">12.4.</span> <span class="nav-text">常见面试问题示例</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
