<!DOCTYPE html>



<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode (4): Sliding Window Technique |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"en","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/en/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode (4): Sliding Window Technique</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-05-29 00:00:00</span>
        <span class="mobile">2023-05-29 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/en/tags/Algorithms/">Algorithms</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>3.9k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>24 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>The sliding window technique is one of the most powerful and
frequently used patterns in array and string problems. It allows us to
efficiently solve problems that require examining contiguous subarrays
or substrings without recalculating everything from scratch. If you've
ever found yourself writing nested loops to check every possible
subarray, sliding window is likely the optimization you need.</p>
<span id="more"></span>
<h2 id="understanding-the-sliding-window-technique">Understanding the
Sliding Window Technique</h2>
<p>At its core, the sliding window technique maintains a "window" of
elements that slides through the array or string. Instead of checking
all possible subarrays independently, we intelligently expand and
contract the window based on certain conditions, reusing computations
from previous windows.</p>
<h3 id="why-use-sliding-window">Why Use Sliding Window?</h3>
<p>Consider a problem where you need to find the maximum sum of any
subarray of size <code>k</code>. A naive approach would iterate through
all possible subarrays:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">naive_max_sum</span>(<span class="params">arr, k</span>):</span><br><span class="line">    max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - k + <span class="number">1</span>):</span><br><span class="line">        current_sum = <span class="built_in">sum</span>(arr[i:i+k])</span><br><span class="line">        max_sum = <span class="built_in">max</span>(max_sum, current_sum)</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>
<p>This has time complexity <span class="math inline">\(O(n \cdot
k)\)</span> because for each starting position, we sum <code>k</code>
elements. With sliding window, we can achieve <span class="math inline">\(O(n)\)</span>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_window_max_sum</span>(<span class="params">arr, k</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; k:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calculate sum of first window</span></span><br><span class="line">    window_sum = <span class="built_in">sum</span>(arr[:k])</span><br><span class="line">    max_sum = window_sum</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Slide the window</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(arr)):</span><br><span class="line">        window_sum = window_sum - arr[i-k] + arr[i]</span><br><span class="line">        max_sum = <span class="built_in">max</span>(max_sum, window_sum)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>
<p>The key insight: when we slide the window one position to the right,
we don't need to recalculate the entire sum. We subtract the element
leaving the window and add the new element entering it.</p>
<h2 id="two-types-of-sliding-windows">Two Types of Sliding Windows</h2>
<p>Sliding window problems fall into two main categories:</p>
<h3 id="fixed-size-window">Fixed-Size Window</h3>
<p>The window size remains constant throughout the algorithm. These
problems are typically easier because we know exactly when to move the
window.</p>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Window size is predetermined (e.g., find maximum sum of subarray of
size <code>k</code>)</li>
<li>Window moves one position at a time</li>
<li>Usually involves maintaining a running sum or count</li>
</ul>
<p><strong>Template:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fixed_window_template</span>(<span class="params">arr, k</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; k:</span><br><span class="line">        <span class="keyword">return</span> []  <span class="comment"># or handle edge case</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize first window</span></span><br><span class="line">    window = arr[:k]</span><br><span class="line">    result = process_window(window)  <span class="comment"># or collect first result</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Slide window</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># Remove leftmost element</span></span><br><span class="line">        window.pop(<span class="number">0</span>)  <span class="comment"># or use deque for O(1)</span></span><br><span class="line">        <span class="comment"># Add new element</span></span><br><span class="line">        window.append(arr[i])</span><br><span class="line">        <span class="comment"># Process current window</span></span><br><span class="line">        result = update_result(window, result)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="variable-size-window">Variable-Size Window</h3>
<p>The window size changes dynamically based on conditions. These
problems are more complex and often require two pointers (left and
right) to track window boundaries.</p>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Window size varies based on problem constraints</li>
<li>Window expands when condition is not met</li>
<li>Window contracts when condition is satisfied</li>
<li>Often involves finding minimum/maximum window size</li>
</ul>
<p><strong>Template:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">variable_window_template</span>(<span class="params">s</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="number">0</span></span><br><span class="line">    window = &#123;&#125;  <span class="comment"># or Counter, or set</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="comment"># Expand window</span></span><br><span class="line">        add_to_window(s[right], window)</span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Contract window when condition is met</span></span><br><span class="line">        <span class="keyword">while</span> condition_satisfied(window):</span><br><span class="line">            <span class="comment"># Update result if needed</span></span><br><span class="line">            update_result(left, right)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Remove leftmost element</span></span><br><span class="line">            remove_from_window(s[left], window)</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="classic-problem-1-longest-substring-without-repeating-characters">Classic
Problem 1: Longest Substring Without Repeating Characters</h2>
<p><strong>Problem:</strong> Given a string <code>s</code>, find the
length of the longest substring without repeating characters.</p>
<p><strong>Example:</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure></p>
<p><strong>Analysis:</strong> This is a variable-size window problem. We
need to maintain a window where all characters are unique. When we
encounter a duplicate, we contract the window from the left until the
duplicate is removed.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    char_map = &#123;&#125;</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    max_length = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># If character is already in window, move left pointer</span></span><br><span class="line">        <span class="keyword">if</span> s[right] <span class="keyword">in</span> char_map <span class="keyword">and</span> char_map[s[right]] &gt;= left:</span><br><span class="line">            left = char_map[s[right]] + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        char_map[s[right]] = right</span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length, right - left + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure>
<p><strong>Java Version:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Character, Integer&gt; charMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="keyword">if</span> (charMap.containsKey(c) &amp;&amp; charMap.get(c) &gt;= left) &#123;</span><br><span class="line">            left = charMap.get(c) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        charMap.put(c, right);</span><br><span class="line">        maxLength = Math.max(maxLength, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Complexity Analysis:</strong></p>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span> - Each character is
visited at most twice (once by <code>right</code>, once by
<code>left</code>)</li>
<li>Space: <span class="math inline">\(O(min(m, n))\)</span> - Where
<code>m</code> is the size of the character set (e.g., 26 for lowercase
letters)</li>
</ul>
<h2 id="classic-problem-2-minimum-window-substring">Classic Problem 2:
Minimum Window Substring</h2>
<p><strong>Problem:</strong> Given two strings <code>s</code> and
<code>t</code>, return the minimum window substring of <code>s</code>
such that every character in <code>t</code> (including duplicates) is
included in the window. If there is no such substring, return the empty
string.</p>
<p><strong>Example:</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br><span class="line">Explanation: The minimum window substring &quot;BANC&quot; includes &#x27;A&#x27;, &#x27;B&#x27;, and &#x27;C&#x27; from string t.</span><br></pre></td></tr></table></figure></p>
<p><strong>Analysis:</strong> This is a variable-size window problem
where we need to find the smallest window containing all characters from
<code>t</code>. We expand the window until all required characters are
present, then contract to find the minimum valid window.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">s, t</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> t <span class="keyword">or</span> <span class="built_in">len</span>(s) &lt; <span class="built_in">len</span>(t):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Count characters in t</span></span><br><span class="line">    need = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> t:</span><br><span class="line">        need[char] = need.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Track current window</span></span><br><span class="line">    window = &#123;&#125;</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="number">0</span></span><br><span class="line">    valid = <span class="number">0</span>  <span class="comment"># Number of distinct characters that satisfy requirement</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="comment"># Expand window</span></span><br><span class="line">        c = s[right]</span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> need:</span><br><span class="line">            window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                valid += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Contract window when all characters are found</span></span><br><span class="line">        <span class="keyword">while</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">            <span class="comment"># Update minimum window</span></span><br><span class="line">            <span class="keyword">if</span> right - left &lt; min_len:</span><br><span class="line">                start = left</span><br><span class="line">                min_len = right - left</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Remove leftmost character</span></span><br><span class="line">            d = s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                    valid -= <span class="number">1</span></span><br><span class="line">                window[d] -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span> <span class="keyword">if</span> min_len == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> s[start:start + min_len]</span><br></pre></td></tr></table></figure>
<p><strong>Java Version:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || t == <span class="literal">null</span> || s.length() &lt; t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, minLen = Integer.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        right++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (window.get(c).equals(need.get(c))) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (valid == need.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; minLen) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                minLen = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window.get(d).equals(need.get(d))) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + minLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Complexity Analysis:</strong></p>
<ul>
<li>Time: <span class="math inline">\(O(|s| + |t|)\)</span> - Each
character in <code>s</code> is visited at most twice</li>
<li>Space: <span class="math inline">\(O(|s| + |t|)\)</span> - For the
hash maps</li>
</ul>
<h2 id="classic-problem-3-minimum-size-subarray-sum">Classic Problem 3:
Minimum Size Subarray Sum</h2>
<p><strong>Problem:</strong> Given an array of positive integers
<code>nums</code> and a positive integer <code>target</code>, return the
minimal length of a contiguous subarray whose sum is greater than or
equal to <code>target</code>. If there is no such subarray, return
0.</p>
<p><strong>Example:</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure></p>
<p><strong>Analysis:</strong> This is a variable-size window problem. We
expand the window until the sum meets or exceeds the target, then
contract to find the minimum valid window.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">target, nums</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    current_sum = <span class="number">0</span></span><br><span class="line">    min_length = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        current_sum += nums[right]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Contract window while sum is sufficient</span></span><br><span class="line">        <span class="keyword">while</span> current_sum &gt;= target:</span><br><span class="line">            min_length = <span class="built_in">min</span>(min_length, right - left + <span class="number">1</span>)</span><br><span class="line">            current_sum -= nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> min_length == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> min_length</span><br></pre></td></tr></table></figure>
<p><strong>Java Version:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">        currentSum += nums[right];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (currentSum &gt;= target) &#123;</span><br><span class="line">            minLength = Math.min(minLength, right - left + <span class="number">1</span>);</span><br><span class="line">            currentSum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> minLength == Integer.MAX_VALUE ? <span class="number">0</span> : minLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Complexity Analysis:</strong></p>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span> - Each element is
visited at most twice</li>
<li>Space: <span class="math inline">\(O(1)\)</span> - Only using a few
variables</li>
</ul>
<h2 id="classic-problem-4-permutation-in-string">Classic Problem 4:
Permutation in String</h2>
<p><strong>Problem:</strong> Given two strings <code>s1</code> and
<code>s2</code>, return <code>true</code> if <code>s2</code> contains a
permutation of <code>s1</code>, or <code>false</code> otherwise.</p>
<p><strong>Example:</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 = &quot;ab&quot;, s2 = &quot;eidbaooo&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure></p>
<p><strong>Analysis:</strong> This is a fixed-size window problem. We
need to check if any window of size <code>len(s1)</code> in
<code>s2</code> contains the same character frequencies as
<code>s1</code>.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s1) &gt; <span class="built_in">len</span>(s2):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Count characters in s1</span></span><br><span class="line">    s1_count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s1:</span><br><span class="line">        s1_count[char] = s1_count.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize window</span></span><br><span class="line">    window_count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)):</span><br><span class="line">        char = s2[i]</span><br><span class="line">        window_count[char] = window_count.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Check first window</span></span><br><span class="line">    <span class="keyword">if</span> window_count == s1_count:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Slide window</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)):</span><br><span class="line">        <span class="comment"># Add new character</span></span><br><span class="line">        new_char = s2[i]</span><br><span class="line">        window_count[new_char] = window_count.get(new_char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Remove old character</span></span><br><span class="line">        old_char = s2[i - <span class="built_in">len</span>(s1)]</span><br><span class="line">        window_count[old_char] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> window_count[old_char] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">del</span> window_count[old_char]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Check if window matches</span></span><br><span class="line">        <span class="keyword">if</span> window_count == s1_count:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>Optimized Version (using array instead of dict):</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s1) &gt; <span class="built_in">len</span>(s2):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    s1_count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    window_count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Count s1 and first window of s2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)):</span><br><span class="line">        s1_count[<span class="built_in">ord</span>(s1[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        window_count[<span class="built_in">ord</span>(s2[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    matches = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>) <span class="keyword">if</span> s1_count[i] == window_count[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)):</span><br><span class="line">        <span class="keyword">if</span> matches == <span class="number">26</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Add new character</span></span><br><span class="line">        r = <span class="built_in">ord</span>(s2[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        window_count[r] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> window_count[r] == s1_count[r]:</span><br><span class="line">            matches += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> window_count[r] == s1_count[r] + <span class="number">1</span>:</span><br><span class="line">            matches -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Remove old character</span></span><br><span class="line">        l = <span class="built_in">ord</span>(s2[i - <span class="built_in">len</span>(s1)]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        window_count[l] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> window_count[l] == s1_count[l]:</span><br><span class="line">            matches += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> window_count[l] == s1_count[l] - <span class="number">1</span>:</span><br><span class="line">            matches -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> matches == <span class="number">26</span></span><br></pre></td></tr></table></figure>
<p><strong>Complexity Analysis:</strong></p>
<ul>
<li>Time: <span class="math inline">\(O(|s2|)\)</span> - We slide
through <code>s2</code> once</li>
<li>Space: <span class="math inline">\(O(1)\)</span> - Using fixed-size
arrays (26 for lowercase letters)</li>
</ul>
<h2 id="classic-problem-5-find-all-anagrams-in-a-string">Classic Problem
5: Find All Anagrams in a String</h2>
<p><strong>Problem:</strong> Given two strings <code>s</code> and
<code>p</code>, return an array of all the start indices of
<code>p</code>'s anagrams in <code>s</code>.</p>
<p><strong>Example:</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">Output: [0,6]</span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line">The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure></p>
<p><strong>Analysis:</strong> This is similar to the permutation problem
but we need to find all occurrences. We use a fixed-size window and
check each position.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">s, p</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    p_count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    window_count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Count p and first window</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)):</span><br><span class="line">        p_count[<span class="built_in">ord</span>(p[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        window_count[<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    matches = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>) <span class="keyword">if</span> p_count[i] == window_count[i])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Check first window</span></span><br><span class="line">    <span class="keyword">if</span> matches == <span class="number">26</span>:</span><br><span class="line">        result.append(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Slide window</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p), <span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># Add new character</span></span><br><span class="line">        r = <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        window_count[r] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> window_count[r] == p_count[r]:</span><br><span class="line">            matches += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> window_count[r] == p_count[r] + <span class="number">1</span>:</span><br><span class="line">            matches -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Remove old character</span></span><br><span class="line">        l = <span class="built_in">ord</span>(s[i - <span class="built_in">len</span>(p)]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        window_count[l] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> window_count[l] == p_count[l]:</span><br><span class="line">            matches += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> window_count[l] == p_count[l] - <span class="number">1</span>:</span><br><span class="line">            matches -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Check if current window is anagram</span></span><br><span class="line">        <span class="keyword">if</span> matches == <span class="number">26</span>:</span><br><span class="line">            result.append(i - <span class="built_in">len</span>(p) + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Java Version:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (p.length() &gt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] windowCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">        pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        windowCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">matches</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pCount[i] == windowCount[i]) &#123;</span><br><span class="line">            matches++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (matches == <span class="number">26</span>) &#123;</span><br><span class="line">        result.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> p.length(); i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        windowCount[r]++;</span><br><span class="line">        <span class="keyword">if</span> (windowCount[r] == pCount[r]) &#123;</span><br><span class="line">            matches++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowCount[r] == pCount[r] + <span class="number">1</span>) &#123;</span><br><span class="line">            matches--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.charAt(i - p.length()) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        windowCount[l]--;</span><br><span class="line">        <span class="keyword">if</span> (windowCount[l] == pCount[l]) &#123;</span><br><span class="line">            matches++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowCount[l] == pCount[l] - <span class="number">1</span>) &#123;</span><br><span class="line">            matches--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (matches == <span class="number">26</span>) &#123;</span><br><span class="line">            result.add(i - p.length() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Complexity Analysis:</strong></p>
<ul>
<li>Time: <span class="math inline">\(O(|s| + |p|)\)</span> - Linear
time complexity</li>
<li>Space: <span class="math inline">\(O(1)\)</span> - Fixed-size
arrays</li>
</ul>
<h2 id="advanced-problem-longest-substring-with-at-most-k-distinct-characters">Advanced
Problem: Longest Substring with At Most K Distinct Characters</h2>
<p><strong>Problem:</strong> Given a string <code>s</code> and an
integer <code>k</code>, return the length of the longest substring of
<code>s</code> that contains at most <code>k</code> distinct
characters.</p>
<p><strong>Example:</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;eceba&quot;, k = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The substring is &quot;ece&quot; with length 3.</span><br></pre></td></tr></table></figure></p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstringKDistinct</span>(<span class="params">s, k</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    char_count = &#123;&#125;</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    max_length = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># Add character to window</span></span><br><span class="line">        char_count[s[right]] = char_count.get(s[right], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Contract window if distinct characters exceed k</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(char_count) &gt; k:</span><br><span class="line">            char_count[s[left]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> char_count[s[left]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> char_count[s[left]]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length, right - left + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure>
<p><strong>Complexity Analysis:</strong></p>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span> - Each character
visited at most twice</li>
<li>Space: <span class="math inline">\(O(k)\)</span> - Hash map stores
at most <code>k+1</code> distinct characters</li>
</ul>
<h2 id="complexity-analysis-patterns">Complexity Analysis Patterns</h2>
<p>Understanding time and space complexity for sliding window
problems:</p>
<h3 id="time-complexity">Time Complexity</h3>
<p><strong>Fixed-size window:</strong></p>
<ul>
<li>Typically <span class="math inline">\(O(n)\)</span> where
<code>n</code> is the array/string length</li>
<li>Each element enters and leaves the window exactly once</li>
</ul>
<p><strong>Variable-size window:</strong></p>
<ul>
<li>Typically <span class="math inline">\(O(n)\)</span> - Each element
visited at most twice (once by right pointer, once by left pointer)</li>
<li>This is because the left pointer never moves backward</li>
</ul>
<p><strong>Why <span class="math inline">\(O(n)\)</span> and not <span class="math inline">\(O(n^2)\)</span>?</strong> Even though we have
nested loops, the inner <code>while</code> loop doesn't reset
<code>left</code> to 0. The <code>left</code> pointer only moves
forward, so the total number of iterations is bounded by <span class="math inline">\(2n\)</span>.</p>
<h3 id="space-complexity">Space Complexity</h3>
<p><strong>Using hash maps/dictionaries:</strong></p>
<ul>
<li><span class="math inline">\(O(k)\)</span> where <code>k</code> is
the number of distinct characters/elements in the window</li>
<li>For lowercase letters: <span class="math inline">\(O(26) =
O(1)\)</span></li>
<li>For general characters: <span class="math inline">\(O(min(m,
n))\)</span> where <code>m</code> is character set size</li>
</ul>
<p><strong>Using arrays:</strong></p>
<ul>
<li><span class="math inline">\(O(1)\)</span> if using fixed-size arrays
(e.g., 26 for lowercase letters)</li>
<li><span class="math inline">\(O(k)\)</span> if array size depends on
input range</li>
</ul>
<h2 id="common-pitfalls-and-debugging-tips">Common Pitfalls and
Debugging Tips</h2>
<h3 id="pitfall-1-off-by-one-errors">Pitfall 1: Off-by-One Errors</h3>
<p><strong>Problem:</strong> Incorrect window boundaries when
calculating length.</p>
<p><strong>Wrong:</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_length = <span class="built_in">max</span>(max_length, right - left)  <span class="comment"># Missing +1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Correct:</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_length = <span class="built_in">max</span>(max_length, right - left + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>Tip:</strong> Remember that <code>right - left + 1</code>
gives the length of substring from <code>left</code> to
<code>right</code> (inclusive).</p>
<h3 id="pitfall-2-not-handling-empty-inputs">Pitfall 2: Not Handling
Empty Inputs</h3>
<p><strong>Problem:</strong> Forgetting to check for empty strings or
arrays.</p>
<p><strong>Solution:</strong> Always add edge case checks:
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># or appropriate default</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pitfall-3-incorrect-window-contraction-condition">Pitfall 3:
Incorrect Window Contraction Condition</h3>
<p><strong>Problem:</strong> Contracting window at wrong time or not
contracting enough.</p>
<p><strong>Example - Wrong:</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">    <span class="comment"># Only moves left once, might not be enough</span></span><br><span class="line">    left += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Example - Correct:</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">    <span class="comment"># Properly remove element and update state</span></span><br><span class="line">    remove_from_window(s[left])</span><br><span class="line">    left += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pitfall-4-using-list-instead-of-deque-for-fixed-window">Pitfall
4: Using List Instead of Deque for Fixed Window</h3>
<p><strong>Problem:</strong> Using <code>list.pop(0)</code> which is
<span class="math inline">\(O(n)\)</span> instead of <span class="math inline">\(O(1)\)</span>.</p>
<p><strong>Wrong:</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window = []</span><br><span class="line">window.pop(<span class="number">0</span>)  <span class="comment"># O(n) operation</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Correct:</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">window = deque()</span><br><span class="line">window.popleft()  <span class="comment"># O(1) operation</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pitfall-5-not-updating-result-at-correct-time">Pitfall 5: Not
Updating Result at Correct Time</h3>
<p><strong>Problem:</strong> Updating result before window is valid or
after it becomes invalid.</p>
<p><strong>Tip:</strong> Think carefully about when the window satisfies
the condition:</p>
<ul>
<li>For "at least" conditions: Update result when condition is first
met, then contract</li>
<li>For "at most" conditions: Update result continuously as window
expands</li>
</ul>
<h3 id="debugging-tips">Debugging Tips</h3>
<ol type="1">
<li><p><strong>Print window state:</strong> Add print statements to
track <code>left</code>, <code>right</code>, and window contents
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;left=<span class="subst">&#123;left&#125;</span>, right=<span class="subst">&#123;right&#125;</span>, window=<span class="subst">&#123;s[left:right+<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Track character counts:</strong> For problems involving
character frequencies, print the count map <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;char_count: <span class="subst">&#123;char_count&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Use small test cases:</strong> Start with simple examples
to verify logic <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> lengthOfLongestSubstring(<span class="string">&quot;abc&quot;</span>) == <span class="number">3</span></span><br><span class="line"><span class="keyword">assert</span> lengthOfLongestSubstring(<span class="string">&quot;aaa&quot;</span>) == <span class="number">1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Check boundary conditions:</strong> Test with empty
strings, single characters, and edge cases</p></li>
<li><p><strong>Verify window invariants:</strong> Ensure your window
always maintains the required properties</p></li>
</ol>
<h2 id="when-to-use-sliding-window">When to Use Sliding Window</h2>
<p>Sliding window is appropriate when:</p>
<ol type="1">
<li><strong>Contiguous subarrays/substrings:</strong> Problem asks about
contiguous sequences</li>
<li><strong>Optimization problems:</strong> Finding min/max length, sum,
or count</li>
<li><strong>Frequency/count problems:</strong> Involving character or
element frequencies</li>
<li><strong>Avoiding recomputation:</strong> When naive approach
recalculates overlapping regions</li>
</ol>
<p><strong>Signs that sliding window might help:</strong></p>
<ul>
<li>Problem mentions "subarray" or "substring"</li>
<li>Need to find "minimum" or "maximum" window</li>
<li>Involves "at most k" or "at least k" constraints</li>
<li>Naive solution has nested loops checking all subarrays</li>
</ul>
<h2 id="template-summary">Template Summary</h2>
<h3 id="fixed-size-window-template">Fixed-Size Window Template</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fixed_window</span>(<span class="params">arr, k</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; k:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize first window</span></span><br><span class="line">    window_sum = <span class="built_in">sum</span>(arr[:k])  <span class="comment"># or initialize window state</span></span><br><span class="line">    result = window_sum  <span class="comment"># or process first window</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Slide window</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(arr)):</span><br><span class="line">        window_sum = window_sum - arr[i-k] + arr[i]</span><br><span class="line">        result = <span class="built_in">max</span>(result, window_sum)  <span class="comment"># or update result</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="variable-size-window-template">Variable-Size Window
Template</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">variable_window</span>(<span class="params">s</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    window = &#123;&#125;  <span class="comment"># or Counter, set, etc.</span></span><br><span class="line">    result = <span class="number">0</span>  <span class="comment"># or []</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># Expand window</span></span><br><span class="line">        add_to_window(s[right], window)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Contract window while condition violated</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_valid(window):</span><br><span class="line">            remove_from_window(s[left], window)</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Update result</span></span><br><span class="line">        result = update_result(left, right, result)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="qa-section">Q&amp;A Section</h2>
<h3 id="q1-how-do-i-know-if-a-problem-is-a-sliding-window-problem">Q1:
How do I know if a problem is a sliding window problem?</h3>
<p><strong>A:</strong> Look for these indicators:</p>
<ul>
<li>Problem asks about contiguous subarrays or substrings</li>
<li>Need to find minimum/maximum length or sum</li>
<li>Involves constraints like "at most k distinct characters" or "sum
&gt;= target"</li>
<li>Naive solution would check all possible subarrays (suggesting
optimization needed)</li>
</ul>
<h3 id="q2-whats-the-difference-between-fixed-and-variable-window">Q2:
What's the difference between fixed and variable window?</h3>
<p><strong>A:</strong></p>
<ul>
<li><strong>Fixed window:</strong> Size is predetermined (e.g., "find
max sum of subarray of size k")</li>
<li><strong>Variable window:</strong> Size changes based on conditions
(e.g., "find minimum window containing all characters")</li>
</ul>
<p>Fixed windows are simpler - you know exactly when to move. Variable
windows require tracking when conditions are met.</p>
<h3 id="q3-why-is-sliding-window-on-and-not-on">Q3: Why is sliding
window O(n) and not O(n)?</h3>
<p><strong>A:</strong> Even with nested loops, the left pointer never
moves backward. Each element is visited at most twice (once by right
pointer expanding, once by left pointer contracting). Total iterations:
<span class="math inline">\(2n = O(n)\)</span>.</p>
<h3 id="q4-should-i-use-a-hash-map-or-array-for-character-counting">Q4:
Should I use a hash map or array for character counting?</h3>
<p><strong>A:</strong></p>
<ul>
<li><strong>Array:</strong> When character set is small and known (e.g.,
lowercase letters: 26, digits: 10)</li>
<li><strong>Hash map:</strong> When character set is large or unknown
(e.g., Unicode characters)</li>
</ul>
<p>Arrays are more efficient for small, fixed character sets.</p>
<h3 id="q5-how-do-i-handle-duplicate-characters-in-the-window">Q5: How
do I handle duplicate characters in the window?</h3>
<p><strong>A:</strong> Use a count map (dictionary or array) instead of
a set. Track frequency of each character: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char_count = &#123;&#125;</span><br><span class="line">char_count[char] = char_count.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>When removing, decrement count and delete key when count reaches
0.</p>
<h3 id="q6-what-if-the-window-condition-is-complex-multiple-constraints">Q6:
What if the window condition is complex (multiple constraints)?</h3>
<p><strong>A:</strong> Break it down: 1. Identify all constraints 2.
Track state for each constraint 3. Expand window until all constraints
might be satisfied 4. Contract until at least one constraint is violated
5. Update result when all constraints are satisfied</p>
<h3 id="q7-can-sliding-window-work-with-negative-numbers">Q7: Can
sliding window work with negative numbers?</h3>
<p><strong>A:</strong> Yes, but be careful:</p>
<ul>
<li>For "sum &gt;= target" problems, contracting might not always reduce
sum</li>
<li>May need to track minimum sum ending at each position instead</li>
<li>Consider using prefix sums or Kadane's algorithm for some cases</li>
</ul>
<h3 id="q8-how-do-i-find-all-valid-windows-not-just-one">Q8: How do I
find all valid windows, not just one?</h3>
<p><strong>A:</strong> Instead of returning early, collect all valid
windows: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">    <span class="keyword">if</span> window_valid:</span><br><span class="line">        result.append(s[left:right+<span class="number">1</span>])  <span class="comment"># or append indices</span></span><br><span class="line">    <span class="comment"># Continue sliding</span></span><br></pre></td></tr></table></figure></p>
<h3 id="q9-whats-the-best-way-to-compare-two-frequency-maps">Q9: What's
the best way to compare two frequency maps?</h3>
<p><strong>A:</strong> For small character sets, use arrays and compare
directly: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s1_count == window_count:  <span class="comment"># Works for lists</span></span><br></pre></td></tr></table></figure></p>
<p>For hash maps, compare key-value pairs: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">all</span>(window.get(k, <span class="number">0</span>) == v <span class="keyword">for</span> k, v <span class="keyword">in</span> need.items()):</span><br></pre></td></tr></table></figure></p>
<p>Or use a <code>matches</code> counter to track how many characters
match.</p>
<h3 id="q10-how-do-i-optimize-space-complexity">Q10: How do I optimize
space complexity?</h3>
<p><strong>A:</strong></p>
<ul>
<li>Use arrays instead of hash maps when possible (fixed character
set)</li>
<li>Use a single variable to track "matches" instead of comparing entire
maps</li>
<li>Reuse variables instead of creating new data structures</li>
<li>For some problems, you only need to track differences, not absolute
counts</li>
</ul>
<h2 id="related-leetcode-problems">Related LeetCode Problems</h2>
<p>Here are more problems to practice sliding window:</p>
<p><strong>Easy:</strong></p>
<ul>
<li>Maximum Average Subarray I</li>
<li>Contains Duplicate II</li>
<li>Best Time to Buy and Sell Stock</li>
</ul>
<p><strong>Medium:</strong></p>
<ul>
<li>Longest Repeating Character Replacement</li>
<li>Subarray Product Less Than K</li>
<li>Maximum Points You Can Obtain from Cards</li>
<li>Fruit Into Baskets</li>
<li>Grumpy Bookstore Owner</li>
<li>Max Consecutive Ones III</li>
</ul>
<p><strong>Hard:</strong></p>
<ul>
<li>Sliding Window Maximum</li>
<li>Minimum Window Subsequence</li>
<li>Substring with Concatenation of All Words</li>
</ul>
<h2 id="practice-recommendations">Practice Recommendations</h2>
<ol type="1">
<li><strong>Start with fixed-size windows:</strong> Master the simpler
pattern first</li>
<li><strong>Practice variable windows:</strong> Work through problems
requiring dynamic sizing</li>
<li><strong>Focus on one language:</strong> Get comfortable with
templates in Python or Java</li>
<li><strong>Draw it out:</strong> Visualize the window sliding on paper
for complex problems</li>
<li><strong>Time yourself:</strong> Practice solving problems within
20-30 minutes</li>
<li><strong>Review edge cases:</strong> Always test with empty inputs,
single elements, and boundary conditions</li>
</ol>
<h2 id="summary">Summary</h2>
<p>The sliding window technique is a powerful optimization for problems
involving contiguous subarrays or substrings. Key takeaways:</p>
<ol type="1">
<li><strong>Two types:</strong> Fixed-size (predetermined) and
variable-size (dynamic based on conditions)</li>
<li><strong>Time complexity:</strong> Typically <span class="math inline">\(O(n)\)</span> because each element is visited at
most twice</li>
<li><strong>Space complexity:</strong> <span class="math inline">\(O(k)\)</span> where <code>k</code> is the number
of distinct elements, often <span class="math inline">\(O(1)\)</span>
for fixed character sets</li>
<li><strong>Common patterns:</strong> Use hash maps or arrays to track
window state, expand until condition met, contract to optimize</li>
<li><strong>Templates:</strong> Memorize the basic templates and adapt
them to specific problems</li>
</ol>
<p>Mastering sliding window will help you solve many array and string
problems efficiently. The key is recognizing when to use it and
correctly implementing the expand/contract logic. Practice with the
problems listed above, and soon you'll be able to identify and solve
sliding window problems quickly.</p>
<p>Remember: if you find yourself checking all possible subarrays with
nested loops, sliding window is likely the optimization you need. The
technique transforms <span class="math inline">\(O(n^2)\)</span> or
<span class="math inline">\(O(n \cdot k)\)</span> solutions into <span class="math inline">\(O(n)\)</span> solutions, making it essential for
efficient algorithm design.</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>Post titleLeetCode (4): Sliding Window Technique</li>
        <li>Post authorChen Kai</li>
        <li>Create time2023-05-29 00:00:00</li>
        <li>
            Post linkhttps://www.chenk.top/en/leetcode-sliding-window/
        </li>
        <li>
            Copyright NoticeAll articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/en/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/en/tags/Algorithms/">#Algorithms</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/en/leetcode-linked-list-operations/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode (3): Linked List Operations - Reversal, Cycle Detection &amp; Merging</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/en/leetcode-two-pointers/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode (2): Two Pointers - Collision, Fast-Slow &amp; Sliding Window Complete Guide</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: ' ck~',
                    lang: 'en'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#understanding-the-sliding-window-technique"><span class="nav-number">1.</span> <span class="nav-text">Understanding the
Sliding Window Technique</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#why-use-sliding-window"><span class="nav-number">1.1.</span> <span class="nav-text">Why Use Sliding Window?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#two-types-of-sliding-windows"><span class="nav-number">2.</span> <span class="nav-text">Two Types of Sliding Windows</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fixed-size-window"><span class="nav-number">2.1.</span> <span class="nav-text">Fixed-Size Window</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#variable-size-window"><span class="nav-number">2.2.</span> <span class="nav-text">Variable-Size Window</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#classic-problem-1-longest-substring-without-repeating-characters"><span class="nav-number">3.</span> <span class="nav-text">Classic
Problem 1: Longest Substring Without Repeating Characters</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#classic-problem-2-minimum-window-substring"><span class="nav-number">4.</span> <span class="nav-text">Classic Problem 2:
Minimum Window Substring</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#classic-problem-3-minimum-size-subarray-sum"><span class="nav-number">5.</span> <span class="nav-text">Classic Problem 3:
Minimum Size Subarray Sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#classic-problem-4-permutation-in-string"><span class="nav-number">6.</span> <span class="nav-text">Classic Problem 4:
Permutation in String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#classic-problem-5-find-all-anagrams-in-a-string"><span class="nav-number">7.</span> <span class="nav-text">Classic Problem
5: Find All Anagrams in a String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#advanced-problem-longest-substring-with-at-most-k-distinct-characters"><span class="nav-number">8.</span> <span class="nav-text">Advanced
Problem: Longest Substring with At Most K Distinct Characters</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#complexity-analysis-patterns"><span class="nav-number">9.</span> <span class="nav-text">Complexity Analysis Patterns</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#time-complexity"><span class="nav-number">9.1.</span> <span class="nav-text">Time Complexity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#space-complexity"><span class="nav-number">9.2.</span> <span class="nav-text">Space Complexity</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#common-pitfalls-and-debugging-tips"><span class="nav-number">10.</span> <span class="nav-text">Common Pitfalls and
Debugging Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pitfall-1-off-by-one-errors"><span class="nav-number">10.1.</span> <span class="nav-text">Pitfall 1: Off-by-One Errors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pitfall-2-not-handling-empty-inputs"><span class="nav-number">10.2.</span> <span class="nav-text">Pitfall 2: Not Handling
Empty Inputs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pitfall-3-incorrect-window-contraction-condition"><span class="nav-number">10.3.</span> <span class="nav-text">Pitfall 3:
Incorrect Window Contraction Condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pitfall-4-using-list-instead-of-deque-for-fixed-window"><span class="nav-number">10.4.</span> <span class="nav-text">Pitfall
4: Using List Instead of Deque for Fixed Window</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pitfall-5-not-updating-result-at-correct-time"><span class="nav-number">10.5.</span> <span class="nav-text">Pitfall 5: Not
Updating Result at Correct Time</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#debugging-tips"><span class="nav-number">10.6.</span> <span class="nav-text">Debugging Tips</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#when-to-use-sliding-window"><span class="nav-number">11.</span> <span class="nav-text">When to Use Sliding Window</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#template-summary"><span class="nav-number">12.</span> <span class="nav-text">Template Summary</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fixed-size-window-template"><span class="nav-number">12.1.</span> <span class="nav-text">Fixed-Size Window Template</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#variable-size-window-template"><span class="nav-number">12.2.</span> <span class="nav-text">Variable-Size Window
Template</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qa-section"><span class="nav-number">13.</span> <span class="nav-text">Q&amp;A Section</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#q1-how-do-i-know-if-a-problem-is-a-sliding-window-problem"><span class="nav-number">13.1.</span> <span class="nav-text">Q1:
How do I know if a problem is a sliding window problem?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q2-whats-the-difference-between-fixed-and-variable-window"><span class="nav-number">13.2.</span> <span class="nav-text">Q2:
What&#39;s the difference between fixed and variable window?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q3-why-is-sliding-window-on-and-not-on%C2%B2"><span class="nav-number">13.3.</span> <span class="nav-text">Q3: Why is sliding
window O(n) and not O(n)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q4-should-i-use-a-hash-map-or-array-for-character-counting"><span class="nav-number">13.4.</span> <span class="nav-text">Q4:
Should I use a hash map or array for character counting?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q5-how-do-i-handle-duplicate-characters-in-the-window"><span class="nav-number">13.5.</span> <span class="nav-text">Q5: How
do I handle duplicate characters in the window?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q6-what-if-the-window-condition-is-complex-multiple-constraints"><span class="nav-number">13.6.</span> <span class="nav-text">Q6:
What if the window condition is complex (multiple constraints)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q7-can-sliding-window-work-with-negative-numbers"><span class="nav-number">13.7.</span> <span class="nav-text">Q7: Can
sliding window work with negative numbers?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q8-how-do-i-find-all-valid-windows-not-just-one"><span class="nav-number">13.8.</span> <span class="nav-text">Q8: How do I
find all valid windows, not just one?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q9-whats-the-best-way-to-compare-two-frequency-maps"><span class="nav-number">13.9.</span> <span class="nav-text">Q9: What&#39;s
the best way to compare two frequency maps?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q10-how-do-i-optimize-space-complexity"><span class="nav-number">13.10.</span> <span class="nav-text">Q10: How do I optimize
space complexity?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#related-leetcode-problems"><span class="nav-number">14.</span> <span class="nav-text">Related LeetCode Problems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#practice-recommendations"><span class="nav-number">15.</span> <span class="nav-text">Practice Recommendations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#summary"><span class="nav-number">16.</span> <span class="nav-text">Summary</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
