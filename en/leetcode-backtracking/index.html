<!DOCTYPE html>



<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode (7): Backtracking Algorithm |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"en","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/en/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode (7): Backtracking Algorithm</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-03-19 00:00:00</span>
        <span class="mobile">2023-03-19 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/en/tags/Algorithms/">Algorithms</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/en/tags/Backtracking/">Backtracking</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>3.6k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>22 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>Backtracking is one of the most elegant and powerful algorithmic paradigms for solving constraint satisfaction problems. Unlike brute force that blindly explores all possibilities, backtracking builds solutions incrementally and abandons partial solutions (‚Äúbacktracks‚Äù) as soon as they cannot lead to a valid answer. This makes it perfect for problems like generating permutations, finding combinations, solving puzzles (N-Queens, Sudoku), and exploring decision trees. This guide teaches you the backtracking framework through five classic LeetCode problems, shows you how to identify when to use backtracking, demonstrates pruning techniques to optimize your solutions, and provides a reusable template that works across 90% of backtracking problems. We‚Äôll also cover complexity analysis, common pitfalls, and answer 10 frequently asked questions.</p>
<span id="more"></span>
<h1>Series Navigation</h1>
<p>üìö <strong>LeetCode Algorithm Masterclass Series</strong> (10 Parts):</p>
<ol>
<li>Hash Tables (Two Sum, Longest Consecutive, Group Anagrams)</li>
<li>Two Pointers Techniques (Collision pointers, fast-slow, sliding window)</li>
<li>Linked List Operations (Reverse, cycle detection, merge)</li>
<li>Binary Tree Traversal &amp; Recursion (Inorder/Preorder/Postorder, LCA)</li>
<li>Dynamic Programming Intro (1D/2D DP, state transition)</li>
<li>Binary Search Advanced (Integer/Real binary search, answer binary search)</li>
<li><strong>‚Üí Backtracking Algorithms</strong> (Permutations, combinations, pruning) ‚Üê <em>You are here</em></li>
<li>Stack &amp; Queue (Monotonic stack, priority queue, deque)</li>
<li>Graph Algorithms (BFS/DFS, topological sort, union-find)</li>
<li>Greedy &amp; Bit Manipulation (Greedy strategies, bitwise tricks)</li>
</ol>
<hr>
<h1>What is Backtracking?</h1>
<p>Backtracking is a systematic method for solving problems by trying partial solutions and then abandoning them (‚Äúbacktracking‚Äù) if they cannot be completed to a valid solution. It‚Äôs essentially a refined form of brute force search that uses constraints to prune the search space.</p>
<p><strong>Key characteristics</strong>:</p>
<ul>
<li><strong>Incremental construction</strong>: Builds solutions step by step</li>
<li><strong>Constraint checking</strong>: Validates partial solutions before continuing</li>
<li><strong>Pruning</strong>: Abandons paths that cannot lead to valid solutions</li>
<li><strong>Recursive exploration</strong>: Uses recursion to explore the solution space</li>
</ul>
<p><strong>When to use backtracking</strong>:</p>
<ul>
<li>Problems asking for ‚Äúall possible‚Äù solutions (permutations, combinations, subsets)</li>
<li>Constraint satisfaction problems (N-Queens, Sudoku)</li>
<li>Problems with exponential search space that can be pruned</li>
<li>Decision problems where you need to explore multiple paths</li>
</ul>
<hr>
<h1>Backtracking vs DFS: Understanding the Relationship</h1>
<p>Many beginners confuse backtracking with DFS (Depth-First Search). Here‚Äôs the key distinction:</p>
<h2 id="DFS-Depth-First-Search"><a class="header-anchor" href="#DFS-Depth-First-Search">¬∂</a>DFS (Depth-First Search)</h2>
<ul>
<li><strong>Purpose</strong>: Traverse or search a graph/tree structure</li>
<li><strong>Focus</strong>: Visit all nodes, find paths, explore structure</li>
<li><strong>State</strong>: Usually doesn‚Äôt modify the graph structure</li>
<li><strong>Example</strong>: Finding if a path exists from node A to node B</li>
</ul>
<h2 id="Backtracking"><a class="header-anchor" href="#Backtracking">¬∂</a>Backtracking</h2>
<ul>
<li><strong>Purpose</strong>: Solve constraint satisfaction problems</li>
<li><strong>Focus</strong>: Build valid solutions incrementally</li>
<li><strong>State</strong>: <strong>Modifies and restores state</strong> (this is crucial!)</li>
<li><strong>Example</strong>: Finding all valid N-Queen placements</li>
</ul>
<p><strong>The relationship</strong>: Backtracking <strong>uses</strong> DFS as its exploration mechanism, but adds:</p>
<ol>
<li><strong>State modification</strong>: Make a choice (add element to solution)</li>
<li><strong>Constraint checking</strong>: Verify if current path is valid</li>
<li><strong>State restoration</strong>: Undo the choice (backtrack) if invalid or after exploring</li>
</ol>
<p><strong>Visual analogy</strong>:</p>
<ul>
<li><strong>DFS</strong>: Walking through a maze, marking visited rooms</li>
<li><strong>Backtracking</strong>: Placing chess pieces on a board, removing them if the placement leads to an invalid configuration</li>
</ul>
<hr>
<h1>The Three Essential Elements of Backtracking</h1>
<p>Every backtracking problem has three core components:</p>
<h2 id="1-Choices-What-decisions-can-we-make"><a class="header-anchor" href="#1-Choices-What-decisions-can-we-make">¬∂</a>1. Choices (What decisions can we make?)</h2>
<p>At each step, identify what choices are available. For example:</p>
<ul>
<li><strong>Permutations</strong>: Which number to place at position $i$?</li>
<li><strong>N-Queens</strong>: Which column to place the queen in row $i$?</li>
<li><strong>Subsets</strong>: Include the current element or not?</li>
</ul>
<h2 id="2-Constraints-What-makes-a-choice-valid"><a class="header-anchor" href="#2-Constraints-What-makes-a-choice-valid">¬∂</a>2. Constraints (What makes a choice valid?)</h2>
<p>Define what makes a partial solution valid:</p>
<ul>
<li><strong>Permutations</strong>: No duplicates in the current path</li>
<li><strong>N-Queens</strong>: No two queens attack each other</li>
<li><strong>Combination Sum</strong>: Sum doesn‚Äôt exceed target, no duplicates</li>
</ul>
<h2 id="3-Goal-When-have-we-found-a-solution"><a class="header-anchor" href="#3-Goal-When-have-we-found-a-solution">¬∂</a>3. Goal (When have we found a solution?)</h2>
<p>Determine when a complete solution is found:</p>
<ul>
<li><strong>Permutations</strong>: All positions filled</li>
<li><strong>N-Queens</strong>: All $n$ queens placed</li>
<li><strong>Subsets</strong>: All elements processed (or sum equals target)</li>
</ul>
<p><strong>Template thinking</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def backtrack(path, choices):</span><br><span class="line">    # Goal: Is this a complete solution?</span><br><span class="line">    if is_goal(path):</span><br><span class="line">        result.append(path.copy())  # Save solution</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    # Explore choices</span><br><span class="line">    for choice in choices:</span><br><span class="line">        # Constraint: Is this choice valid?</span><br><span class="line">        if is_valid(choice, path):</span><br><span class="line">            # Make choice</span><br><span class="line">            path.append(choice)</span><br><span class="line">            # Recurse</span><br><span class="line">            backtrack(path, updated_choices)</span><br><span class="line">            # Backtrack: undo choice</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure>
<hr>
<h1>Universal Backtracking Template</h1>
<p>Here‚Äôs a reusable template that works for most backtracking problems:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack_template</span>():</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">        <span class="comment"># Base case: goal reached</span></span><br><span class="line">        <span class="keyword">if</span> is_goal(path):</span><br><span class="line">            result.append(path[:])  <span class="comment"># Copy, don&#x27;t reference!</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Explore all choices</span></span><br><span class="line">        <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">            <span class="comment"># Pruning: skip invalid choices early</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_valid(choice, path):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Make choice</span></span><br><span class="line">            path.append(choice)</span><br><span class="line">            <span class="comment"># Update choices for next level (if needed)</span></span><br><span class="line">            new_choices = update_choices(choices, choice)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Recurse</span></span><br><span class="line">            backtrack(path, new_choices)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Backtrack: undo choice</span></span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack([], initial_choices)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Critical points</strong>:</p>
<ol>
<li><strong>Copy paths</strong>: Use <code>path[:]</code> or <code>path.copy()</code> when saving solutions</li>
<li><strong>Restore state</strong>: Always undo changes after recursion (<code>path.pop()</code>)</li>
<li><strong>Prune early</strong>: Check constraints before recursing</li>
<li><strong>Update choices</strong>: Some problems require modifying available choices</li>
</ol>
<hr>
<h1>Problem 1: Permutations</h1>
<h2 id="Problem-Statement-v10"><a class="header-anchor" href="#Problem-Statement-v10">¬∂</a>Problem Statement</h2>
<p>Given an array <code>nums</code> of distinct integers, return all possible permutations. You can return the answer in any order.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>nums = [1,2,3]</code></li>
<li>Output: <code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></li>
</ul>
<p><strong>Constraints</strong>:</p>
<ul>
<li>$1 \leq \texttt{nums.length} \leq 6$</li>
<li>$-10 \leq \texttt{nums[i]} \leq 10$</li>
<li>All integers are distinct</li>
</ul>
<h2 id="Analysis"><a class="header-anchor" href="#Analysis">¬∂</a>Analysis</h2>
<p><strong>Three elements</strong>:</p>
<ul>
<li><strong>Choices</strong>: Which number to place at the current position?</li>
<li><strong>Constraints</strong>: The number must not already be in the current path</li>
<li><strong>Goal</strong>: All positions filled (path length equals <code>nums.length</code>)</li>
</ul>
<p><strong>Key insight</strong>: Use a set or boolean array to track which elements are already used.</p>
<h2 id="Solution"><a class="header-anchor" href="#Solution">¬∂</a>Solution</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>):</span><br><span class="line">        <span class="comment"># Goal: all positions filled</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == n:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Try each number</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># Constraint: not already used</span></span><br><span class="line">            <span class="keyword">if</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Make choice</span></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Recurse</span></span><br><span class="line">            backtrack(path, used)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Backtrack</span></span><br><span class="line">            path.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    backtrack([], [<span class="literal">False</span>] * n)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Alternative using set</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute_set</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> path:  <span class="comment"># Constraint check</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(num)</span><br><span class="line">            backtrack(path)</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack([])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Complexity</strong>:</p>
<ul>
<li><strong>Time</strong>: $O(n! \times n)$ - There are $n!$ permutations, and each takes $O(n)$ to copy</li>
<li><strong>Space</strong>: $O(n)$ - Recursion depth and path storage</li>
</ul>
<hr>
<h1>Problem 2: Combination Sum</h1>
<h2 id="Problem-Statement-v11"><a class="header-anchor" href="#Problem-Statement-v11">¬∂</a>Problem Statement</h2>
<p>Given an array of distinct integers <code>candidates</code> and a target integer <code>target</code>, return a list of all unique combinations of <code>candidates</code> where the chosen numbers sum to <code>target</code>. You may return the combinations in any order. The same number may be chosen from <code>candidates</code> an unlimited number of times.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>candidates = [2,3,6,7]</code>, <code>target = 7</code></li>
<li>Output: <code>[[2,2,3],[7]]</code></li>
</ul>
<p><strong>Constraints</strong>:</p>
<ul>
<li>$1 \leq \texttt{candidates.length} \leq 30$</li>
<li>$2 \leq \texttt{candidates[i]} \leq 40$</li>
<li>All elements are distinct</li>
<li>$1 \leq \texttt{target} \leq 500$</li>
</ul>
<h2 id="Analysis-v2"><a class="header-anchor" href="#Analysis-v2">¬∂</a>Analysis</h2>
<p><strong>Three elements</strong>:</p>
<ul>
<li><strong>Choices</strong>: Which candidate to add next? (Can reuse same number)</li>
<li><strong>Constraints</strong>:
<ul>
<li>Sum must not exceed target</li>
<li>To avoid duplicates, only consider candidates from current index onward</li>
</ul>
</li>
<li><strong>Goal</strong>: Sum equals target</li>
</ul>
<p><strong>Key insight</strong>:</p>
<ul>
<li>Allow reusing elements by not incrementing index</li>
<li>Prevent duplicates by only considering <code>candidates[i:]</code> after choosing <code>candidates[i]</code></li>
</ul>
<h2 id="Solution-v2"><a class="header-anchor" href="#Solution-v2">¬∂</a>Solution</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">candidates, target</span>):</span><br><span class="line">    result = []</span><br><span class="line">    n = <span class="built_in">len</span>(candidates)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, start, current_sum</span>):</span><br><span class="line">        <span class="comment"># Goal: sum equals target</span></span><br><span class="line">        <span class="keyword">if</span> current_sum == target:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Pruning: sum already exceeds target</span></span><br><span class="line">        <span class="keyword">if</span> current_sum &gt; target:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Try each candidate from start index</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">            num = candidates[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Make choice</span></span><br><span class="line">            path.append(num)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Recurse: can reuse same element, so start stays i</span></span><br><span class="line">            backtrack(path, i, current_sum + num)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Backtrack</span></span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack([], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Why <code>start</code> parameter?</strong></p>
<ul>
<li>Prevents duplicates: <code>[2,3]</code> and <code>[3,2]</code> are the same combination</li>
<li>By only considering <code>candidates[i:]</code> after choosing <code>candidates[i]</code>, we ensure combinations are generated in sorted order</li>
</ul>
<p><strong>Complexity</strong>:</p>
<ul>
<li><strong>Time</strong>: $O(2^t)$ where $t$ is target (worst case, exponential)</li>
<li><strong>Space</strong>: $O(t)$ - Recursion depth (target divided by minimum candidate)</li>
</ul>
<hr>
<h1>Problem 3: Subsets</h1>
<h2 id="Problem-Statement-v12"><a class="header-anchor" href="#Problem-Statement-v12">¬∂</a>Problem Statement</h2>
<p>Given an integer array <code>nums</code> of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>nums = [1,2,3]</code></li>
<li>Output: <code>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></li>
</ul>
<p><strong>Constraints</strong>:</p>
<ul>
<li>$1 \leq \texttt{nums.length} \leq 10$</li>
<li>$-10 \leq \texttt{nums[i]} \leq 10$</li>
<li>All elements are unique</li>
</ul>
<h2 id="Analysis-v3"><a class="header-anchor" href="#Analysis-v3">¬∂</a>Analysis</h2>
<p><strong>Three elements</strong>:</p>
<ul>
<li><strong>Choices</strong>: Include current element or skip it?</li>
<li><strong>Constraints</strong>: No constraints (all subsets are valid)</li>
<li><strong>Goal</strong>: Processed all elements</li>
</ul>
<p><strong>Key insight</strong>: At each element, we have two choices: include it or exclude it. This creates a binary tree of decisions.</p>
<h2 id="Solution-v3"><a class="header-anchor" href="#Solution-v3">¬∂</a>Solution</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, start</span>):</span><br><span class="line">        <span class="comment"># Goal: save current subset (all paths are valid)</span></span><br><span class="line">        result.append(path[:])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Try including each remaining element</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            backtrack(path, i + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack([], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Alternative: binary decision approach</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsets_binary</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, index</span>):</span><br><span class="line">        <span class="comment"># Goal: processed all elements</span></span><br><span class="line">        <span class="keyword">if</span> index == n:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Choice 1: skip current element</span></span><br><span class="line">        backtrack(path, index + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Choice 2: include current element</span></span><br><span class="line">        path.append(nums[index])</span><br><span class="line">        backtrack(path, index + <span class="number">1</span>)</span><br><span class="line">        path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack([], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Complexity</strong>:</p>
<ul>
<li><strong>Time</strong>: $O(2^n \times n)$ - $2^n$ subsets, each copied in $O(n)$</li>
<li><strong>Space</strong>: $O(n)$ - Recursion depth</li>
</ul>
<hr>
<h1>Problem 4: N-Queens</h1>
<h2 id="Problem-Statement-v13"><a class="header-anchor" href="#Problem-Statement-v13">¬∂</a>Problem Statement</h2>
<p>The n-queens puzzle is the problem of placing $n$ queens on an $n \times n$ chessboard such that no two queens attack each other. Given an integer $n$, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.</p>
<p>Each solution contains a distinct board configuration of the n-queens‚Äô placement, where <code>'Q'</code> and <code>'.'</code> indicate a queen and an empty space, respectively.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>n = 4</code></li>
<li>Output: <code>[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</code></li>
</ul>
<p><strong>Constraints</strong>:</p>
<ul>
<li>$1 \leq n \leq 9$</li>
</ul>
<h2 id="Analysis-v4"><a class="header-anchor" href="#Analysis-v4">¬∂</a>Analysis</h2>
<p><strong>Three elements</strong>:</p>
<ul>
<li><strong>Choices</strong>: Which column to place queen in row $i$?</li>
<li><strong>Constraints</strong>:
<ul>
<li>No two queens in same column</li>
<li>No two queens in same diagonal (both main and anti-diagonal)</li>
</ul>
</li>
<li><strong>Goal</strong>: All $n$ queens placed</li>
</ul>
<p><strong>Key insight</strong>:</p>
<ul>
<li>Place queens row by row (one per row)</li>
<li>Track used columns and diagonals</li>
<li>Diagonals: <code>row - col</code> (main) and <code>row + col</code> (anti-diagonal) are constant</li>
</ul>
<h2 id="Solution-v4"><a class="header-anchor" href="#Solution-v4">¬∂</a>Solution</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">n</span>):</span><br><span class="line">    result = []</span><br><span class="line">    board = [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Track constraints</span></span><br><span class="line">    used_cols = <span class="built_in">set</span>()</span><br><span class="line">    used_diag1 = <span class="built_in">set</span>()  <span class="comment"># row - col</span></span><br><span class="line">    used_diag2 = <span class="built_in">set</span>()  <span class="comment"># row + col</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row</span>):</span><br><span class="line">        <span class="comment"># Goal: all queens placed</span></span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            <span class="comment"># Convert board to required format</span></span><br><span class="line">            solution = [<span class="string">&#x27;&#x27;</span>.join(row) <span class="keyword">for</span> row <span class="keyword">in</span> board]</span><br><span class="line">            result.append(solution)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Try each column</span></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            diag1 = row - col</span><br><span class="line">            diag2 = row + col</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Constraint check</span></span><br><span class="line">            <span class="keyword">if</span> col <span class="keyword">in</span> used_cols <span class="keyword">or</span> diag1 <span class="keyword">in</span> used_diag1 <span class="keyword">or</span> diag2 <span class="keyword">in</span> used_diag2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Make choice</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">            used_cols.add(col)</span><br><span class="line">            used_diag1.add(diag1)</span><br><span class="line">            used_diag2.add(diag2)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Recurse</span></span><br><span class="line">            backtrack(row + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Backtrack</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">            used_cols.remove(col)</span><br><span class="line">            used_diag1.remove(diag1)</span><br><span class="line">            used_diag2.remove(diag2)</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Optimization</strong>: Using boolean arrays instead of sets (faster for small $n$):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solveNQueens_optimized</span>(<span class="params">n</span>):</span><br><span class="line">    result = []</span><br><span class="line">    board = [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    used_cols = [<span class="literal">False</span>] * n</span><br><span class="line">    used_diag1 = [<span class="literal">False</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)  <span class="comment"># row - col ranges from -(n-1) to (n-1)</span></span><br><span class="line">    used_diag2 = [<span class="literal">False</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)  <span class="comment"># row + col ranges from 0 to 2(n-1)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row</span>):</span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            result.append([<span class="string">&#x27;&#x27;</span>.join(row) <span class="keyword">for</span> row <span class="keyword">in</span> board])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            diag1 = row - col + n - <span class="number">1</span>  <span class="comment"># Shift to non-negative index</span></span><br><span class="line">            diag2 = row + col</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> used_cols[col] <span class="keyword">or</span> used_diag1[diag1] <span class="keyword">or</span> used_diag2[diag2]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">            used_cols[col] = <span class="literal">True</span></span><br><span class="line">            used_diag1[diag1] = <span class="literal">True</span></span><br><span class="line">            used_diag2[diag2] = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            backtrack(row + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">            used_cols[col] = <span class="literal">False</span></span><br><span class="line">            used_diag1[diag1] = <span class="literal">False</span></span><br><span class="line">            used_diag2[diag2] = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Complexity</strong>:</p>
<ul>
<li><strong>Time</strong>: $O(n!)$ - First row has $n$ choices, second has at most $n-1$, etc.</li>
<li><strong>Space</strong>: $O(n^2)$ - Board storage + $O(n)$ recursion depth</li>
</ul>
<hr>
<h1>Problem 5: Generate Parentheses</h1>
<h2 id="Problem-Statement-v14"><a class="header-anchor" href="#Problem-Statement-v14">¬∂</a>Problem Statement</h2>
<p>Given $n$ pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>n = 3</code></li>
<li>Output: <code>[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></li>
</ul>
<p><strong>Constraints</strong>:</p>
<ul>
<li>$1 \leq n \leq 8$</li>
</ul>
<h2 id="Analysis-v5"><a class="header-anchor" href="#Analysis-v5">¬∂</a>Analysis</h2>
<p><strong>Three elements</strong>:</p>
<ul>
<li><strong>Choices</strong>: Add <code>'('</code> or <code>')'</code>?</li>
<li><strong>Constraints</strong>:
<ul>
<li>Can only add <code>'('</code> if count of <code>'('</code> &lt; $n$</li>
<li>Can only add <code>')'</code> if count of <code>')'</code> &lt; count of <code>'('</code></li>
</ul>
</li>
<li><strong>Goal</strong>: Length equals $2n$ and string is valid</li>
</ul>
<p><strong>Key insight</strong>: Track counts of open and close parentheses. Only add <code>')'</code> when there are unmatched <code>'('</code>.</p>
<h2 id="Solution-v5"><a class="header-anchor" href="#Solution-v5">¬∂</a>Solution</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">n</span>):</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, open_count, close_count</span>):</span><br><span class="line">        <span class="comment"># Goal: length is 2n</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">2</span> * n:</span><br><span class="line">            result.append(<span class="string">&#x27;&#x27;</span>.join(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Choice 1: add &#x27;(&#x27; if possible</span></span><br><span class="line">        <span class="keyword">if</span> open_count &lt; n:</span><br><span class="line">            path.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            backtrack(path, open_count + <span class="number">1</span>, close_count)</span><br><span class="line">            path.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Choice 2: add &#x27;)&#x27; if valid (more opens than closes)</span></span><br><span class="line">        <span class="keyword">if</span> close_count &lt; open_count:</span><br><span class="line">            path.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            backtrack(path, open_count, close_count + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack([], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Alternative using string concatenation</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateParenthesis_string</span>(<span class="params">n</span>):</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">s, open_count, close_count</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">2</span> * n:</span><br><span class="line">            result.append(s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> open_count &lt; n:</span><br><span class="line">            backtrack(s + <span class="string">&#x27;(&#x27;</span>, open_count + <span class="number">1</span>, close_count)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> close_count &lt; open_count:</span><br><span class="line">            backtrack(s + <span class="string">&#x27;)&#x27;</span>, open_count, close_count + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Why this works</strong>: By ensuring <code>close_count &lt; open_count</code> before adding <code>')'</code>, we guarantee that every <code>')'</code> has a matching <code>'('</code> to its left, making all generated strings valid.</p>
<p><strong>Complexity</strong>:</p>
<ul>
<li><strong>Time</strong>: $O(\frac{4^n}{\sqrt{n}})$ - Catalan number $C_n = \frac{1}{n+1}\binom{2n}{n} \approx \frac{4<sup>n}{n</sup>{3/2}\sqrt{\pi}}$</li>
<li><strong>Space</strong>: $O(n)$ - Recursion depth</li>
</ul>
<hr>
<h1>Pruning Optimization Techniques</h1>
<p>Pruning is crucial for making backtracking efficient. Here are common techniques:</p>
<h2 id="1-Early-Termination"><a class="header-anchor" href="#1-Early-Termination">¬∂</a>1. Early Termination</h2>
<p>Stop exploring when constraints are violated:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: Combination Sum</span></span><br><span class="line"><span class="keyword">if</span> current_sum &gt; target:</span><br><span class="line">    <span class="keyword">return</span>  <span class="comment"># Prune: can never reach target</span></span><br></pre></td></tr></table></figure>
<h2 id="2-Constraint-Propagation"><a class="header-anchor" href="#2-Constraint-Propagation">¬∂</a>2. Constraint Propagation</h2>
<p>Use constraints to reduce choices:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: N-Queens</span></span><br><span class="line"><span class="comment"># Only try columns not in used_cols</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span> col <span class="keyword">in</span> used_cols:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># Skip invalid columns</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Memoization-for-overlapping-subproblems"><a class="header-anchor" href="#3-Memoization-for-overlapping-subproblems">¬∂</a>3. Memoization (for overlapping subproblems)</h2>
<p>Cache results of subproblems:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: Word Break II (advanced)</span></span><br><span class="line">memo = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">s, wordDict</span>):</span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="keyword">return</span> memo[s]</span><br><span class="line">    <span class="comment"># ... backtrack logic</span></span><br><span class="line">    memo[s] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="4-Sort-and-Skip-Duplicates"><a class="header-anchor" href="#4-Sort-and-Skip-Duplicates">¬∂</a>4. Sort and Skip Duplicates</h2>
<p>Sort input and skip duplicate choices:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: Combination Sum II (with duplicates)</span></span><br><span class="line">candidates.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">    <span class="comment"># Skip duplicates</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> candidates[i] == candidates[i-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<h2 id="5-Bounds-Checking"><a class="header-anchor" href="#5-Bounds-Checking">¬∂</a>5. Bounds Checking</h2>
<p>Check if remaining choices can satisfy constraints:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: Subset Sum</span></span><br><span class="line">remaining_sum = <span class="built_in">sum</span>(nums[start:])</span><br><span class="line"><span class="keyword">if</span> current_sum + remaining_sum &lt; target:</span><br><span class="line">    <span class="keyword">return</span>  <span class="comment"># Prune: even using all remaining elements won&#x27;t reach target</span></span><br></pre></td></tr></table></figure>
<hr>
<h1>Complexity Analysis</h1>
<p>Understanding backtracking complexity is crucial for interviews:</p>
<h2 id="Time-Complexity-v3"><a class="header-anchor" href="#Time-Complexity-v3">¬∂</a>Time Complexity</h2>
<p><strong>General formula</strong>: $O(b^d \times c)$ where:</p>
<ul>
<li>$b$ = branching factor (choices per node)</li>
<li>$d$ = depth of recursion</li>
<li>$c$ = cost per solution (usually copying)</li>
</ul>
<p><strong>Examples</strong>:</p>
<ul>
<li><strong>Permutations</strong>: $O(n! \times n)$ - $n!$ leaves, $O(n)$ to copy each</li>
<li><strong>Subsets</strong>: $O(2^n \times n)$ - $2^n$ subsets, $O(n)$ to copy each</li>
<li><strong>N-Queens</strong>: $O(n!)$ - Pruned significantly from $n^n$</li>
<li><strong>Generate Parentheses</strong>: $O(\frac{4^n}{\sqrt{n}})$ - Catalan number</li>
</ul>
<h2 id="Space-Complexity-v4"><a class="header-anchor" href="#Space-Complexity-v4">¬∂</a>Space Complexity</h2>
<p><strong>Components</strong>:</p>
<ol>
<li><strong>Recursion stack</strong>: $O(d)$ where $d$ is depth</li>
<li><strong>Path storage</strong>: $O(d)$ for current path</li>
<li><strong>Auxiliary structures</strong>: $O(n)$ for tracking (used sets, arrays)</li>
<li><strong>Result storage</strong>: $O(s \times c)$ where $s$ is number of solutions, $c$ is size per solution</li>
</ol>
<p><strong>Total</strong>: Usually $O(d + n)$ excluding result storage</p>
<hr>
<h1>Common Pitfalls and Debugging Tips</h1>
<h2 id="Pitfall-1-Not-Copying-Paths"><a class="header-anchor" href="#Pitfall-1-Not-Copying-Paths">¬∂</a>Pitfall 1: Not Copying Paths</h2>
<p><strong>Wrong</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.append(path)  <span class="comment"># Adds reference, not copy!</span></span><br></pre></td></tr></table></figure>
<p><strong>Correct</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.append(path[:])  <span class="comment"># or path.copy()</span></span><br></pre></td></tr></table></figure>
<h2 id="Pitfall-2-Forgetting-to-Backtrack"><a class="header-anchor" href="#Pitfall-2-Forgetting-to-Backtrack">¬∂</a>Pitfall 2: Forgetting to Backtrack</h2>
<p><strong>Wrong</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.append(choice)</span><br><span class="line">backtrack(path, choices)</span><br><span class="line"><span class="comment"># Missing: path.pop()</span></span><br></pre></td></tr></table></figure>
<p><strong>Correct</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.append(choice)</span><br><span class="line">backtrack(path, choices)</span><br><span class="line">path.pop()  <span class="comment"># Always restore state!</span></span><br></pre></td></tr></table></figure>
<h2 id="Pitfall-3-Modifying-Choices-Incorrectly"><a class="header-anchor" href="#Pitfall-3-Modifying-Choices-Incorrectly">¬∂</a>Pitfall 3: Modifying Choices Incorrectly</h2>
<p><strong>Wrong</strong> (for permutations):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">choices.remove(choice)  <span class="comment"># Modifies original list</span></span><br><span class="line">backtrack(path, choices)</span><br><span class="line">choices.append(choice)  <span class="comment"># Hard to restore</span></span><br></pre></td></tr></table></figure>
<p><strong>Correct</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">used[i] = <span class="literal">True</span></span><br><span class="line">backtrack(path, used)</span><br><span class="line">used[i] = <span class="literal">False</span>  <span class="comment"># Easy to restore</span></span><br></pre></td></tr></table></figure>
<h2 id="Pitfall-4-Wrong-Constraint-Checking-Order"><a class="header-anchor" href="#Pitfall-4-Wrong-Constraint-Checking-Order">¬∂</a>Pitfall 4: Wrong Constraint Checking Order</h2>
<p>Always check constraints <strong>before</strong> making the choice:</p>
<p><strong>Wrong</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.append(choice)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> is_valid(path):  <span class="comment"># Too late!</span></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p><strong>Correct</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> is_valid(choice, path):</span><br><span class="line">    <span class="keyword">continue</span>  <span class="comment"># Skip before adding</span></span><br><span class="line">path.append(choice)</span><br></pre></td></tr></table></figure>
<h2 id="Debugging-Checklist-v3"><a class="header-anchor" href="#Debugging-Checklist-v3">¬∂</a>Debugging Checklist</h2>
<ol>
<li>‚úÖ Are you copying paths when saving solutions?</li>
<li>‚úÖ Are you restoring state after recursion?</li>
<li>‚úÖ Are constraints checked before making choices?</li>
<li>‚úÖ Are you pruning invalid paths early?</li>
<li>‚úÖ Is the base case correct?</li>
<li>‚úÖ Are choices being updated correctly for next level?</li>
</ol>
<hr>
<h1>Q&amp;A: 10 Frequently Asked Questions</h1>
<h2 id="Q1-When-should-I-use-backtracking-vs-dynamic-programming"><a class="header-anchor" href="#Q1-When-should-I-use-backtracking-vs-dynamic-programming">¬∂</a>Q1: When should I use backtracking vs dynamic programming?</h2>
<p><strong>A</strong>: Use <strong>backtracking</strong> when:</p>
<ul>
<li>You need <strong>all solutions</strong> (not just count/optimal)</li>
<li>Problem has <strong>exponential search space</strong> that can be pruned</li>
<li>Constraints can be checked <strong>incrementally</strong></li>
</ul>
<p>Use <strong>dynamic programming</strong> when:</p>
<ul>
<li>You need <strong>count or optimal value</strong> (not all solutions)</li>
<li>Problem has <strong>overlapping subproblems</strong></li>
<li>Optimal substructure exists</li>
</ul>
<p><strong>Example</strong>:</p>
<ul>
<li><strong>All paths</strong> ‚Üí Backtracking</li>
<li><strong>Number of paths</strong> ‚Üí DP</li>
<li><strong>Shortest path</strong> ‚Üí DP or BFS</li>
</ul>
<h2 id="Q2-How-do-I-avoid-duplicate-solutions"><a class="header-anchor" href="#Q2-How-do-I-avoid-duplicate-solutions">¬∂</a>Q2: How do I avoid duplicate solutions?</h2>
<p><strong>A</strong>: Common strategies:</p>
<ol>
<li><strong>Sort input and skip duplicates</strong>:</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">    <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>Use start index</strong> (for combinations):</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Only consider elements from start onward</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">    backtrack(path, i + <span class="number">1</span>)  <span class="comment"># Next start is i+1</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>Track used elements</strong> (for permutations):</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">used = [<span class="literal">False</span>] * n</span><br><span class="line"><span class="keyword">if</span> used[i]:</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<h2 id="Q3-Why-is-my-solution-too-slow"><a class="header-anchor" href="#Q3-Why-is-my-solution-too-slow">¬∂</a>Q3: Why is my solution too slow?</h2>
<p><strong>A</strong>: Check these:</p>
<ol>
<li><strong>Not pruning early</strong>: Add constraint checks before recursion</li>
<li><strong>Copying unnecessarily</strong>: Only copy when saving final solutions</li>
<li><strong>Inefficient data structures</strong>: Use sets/arrays instead of lists for lookups</li>
<li><strong>Redundant work</strong>: Memoize if subproblems overlap</li>
</ol>
<p><strong>Example optimization</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Slow: checking in O(n) list</span></span><br><span class="line"><span class="keyword">if</span> choice <span class="keyword">in</span> path:  <span class="comment"># O(n) lookup</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fast: checking in O(1) set</span></span><br><span class="line"><span class="keyword">if</span> choice <span class="keyword">in</span> used_set:  <span class="comment"># O(1) lookup</span></span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<h2 id="Q4-Can-I-use-iteration-instead-of-recursion"><a class="header-anchor" href="#Q4-Can-I-use-iteration-instead-of-recursion">¬∂</a>Q4: Can I use iteration instead of recursion?</h2>
<p><strong>A</strong>: Yes, but recursion is usually cleaner for backtracking. Iterative approach uses an explicit stack:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">iterative_backtrack</span>():</span><br><span class="line">    stack = [([], initial_state)]</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        path, state = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> is_goal(path):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> choice <span class="keyword">in</span> get_choices(state):</span><br><span class="line">            <span class="keyword">if</span> is_valid(choice, path):</span><br><span class="line">                new_path = path + [choice]</span><br><span class="line">                new_state = update_state(state, choice)</span><br><span class="line">                stack.append((new_path, new_state))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Trade-off</strong>: Iteration avoids stack overflow but is more verbose.</p>
<h2 id="Q5-How-do-I-handle-problems-with-multiple-constraints"><a class="header-anchor" href="#Q5-How-do-I-handle-problems-with-multiple-constraints">¬∂</a>Q5: How do I handle problems with multiple constraints?</h2>
<p><strong>A</strong>: Track all constraints separately and check them all:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: N-Queens</span></span><br><span class="line">used_cols = <span class="built_in">set</span>()</span><br><span class="line">used_diag1 = <span class="built_in">set</span>()</span><br><span class="line">used_diag2 = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_valid</span>(<span class="params">row, col</span>):</span><br><span class="line">    <span class="keyword">return</span> (col <span class="keyword">not</span> <span class="keyword">in</span> used_cols <span class="keyword">and</span> </span><br><span class="line">            (row - col) <span class="keyword">not</span> <span class="keyword">in</span> used_diag1 <span class="keyword">and</span></span><br><span class="line">            (row + col) <span class="keyword">not</span> <span class="keyword">in</span> used_diag2)</span><br></pre></td></tr></table></figure>
<h2 id="Q6-What‚Äôs-the-difference-between-permutations-and-combinations"><a class="header-anchor" href="#Q6-What‚Äôs-the-difference-between-permutations-and-combinations">¬∂</a>Q6: What‚Äôs the difference between permutations and combinations?</h2>
<p><strong>A</strong>:</p>
<ul>
<li><strong>Permutations</strong>: Order matters. <code>[1,2]</code> ‚â† <code>[2,1]</code></li>
<li><strong>Combinations</strong>: Order doesn‚Äôt matter. <code>[1,2]</code> = <code>[2,1]</code></li>
</ul>
<p><strong>Implementation difference</strong>:</p>
<ul>
<li><strong>Permutations</strong>: Can choose any unused element</li>
<li><strong>Combinations</strong>: Use <code>start</code> index, only consider <code>nums[start:]</code></li>
</ul>
<h2 id="Q7-How-do-I-optimize-for-‚Äúfind-one-solution‚Äù-vs-‚Äúfind-all-solutions‚Äù"><a class="header-anchor" href="#Q7-How-do-I-optimize-for-‚Äúfind-one-solution‚Äù-vs-‚Äúfind-all-solutions‚Äù">¬∂</a>Q7: How do I optimize for ‚Äúfind one solution‚Äù vs ‚Äúfind all solutions‚Äù?</h2>
<p><strong>A</strong>: Return early when first solution found:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_one_solution</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">        <span class="keyword">if</span> is_goal(path):</span><br><span class="line">            <span class="keyword">return</span> path[:]  <span class="comment"># Return immediately</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_valid(choice, path):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(choice)</span><br><span class="line">            result = backtrack(path, updated_choices)</span><br><span class="line">            <span class="keyword">if</span> result:  <span class="comment"># Found solution</span></span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h2 id="Q8-Can-backtracking-solve-optimization-problems"><a class="header-anchor" href="#Q8-Can-backtracking-solve-optimization-problems">¬∂</a>Q8: Can backtracking solve optimization problems?</h2>
<p><strong>A</strong>: Yes, but usually DP is better. For backtracking:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">best_solution = <span class="literal">None</span></span><br><span class="line">best_value = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">    <span class="keyword">if</span> is_goal(path):</span><br><span class="line">        value = evaluate(path)</span><br><span class="line">        <span class="keyword">if</span> value &lt; best_value:</span><br><span class="line">            best_value = value</span><br><span class="line">            best_solution = path[:]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ... explore choices</span></span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: This explores all solutions. Use DP if you only need optimal value.</p>
<h2 id="Q9-How-do-I-handle-problems-with-variable-length-solutions"><a class="header-anchor" href="#Q9-How-do-I-handle-problems-with-variable-length-solutions">¬∂</a>Q9: How do I handle problems with variable-length solutions?</h2>
<p><strong>A</strong>: Save solutions at multiple points, not just at base case:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: Subsets - save at every step</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, start</span>):</span><br><span class="line">    result.append(path[:])  <span class="comment"># Save current subset</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">        path.append(nums[i])</span><br><span class="line">        backtrack(path, i + <span class="number">1</span>)</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>
<h2 id="Q10-What‚Äôs-the-best-way-to-practice-backtracking"><a class="header-anchor" href="#Q10-What‚Äôs-the-best-way-to-practice-backtracking">¬∂</a>Q10: What‚Äôs the best way to practice backtracking?</h2>
<p><strong>A</strong>:</p>
<ol>
<li><strong>Start with template</strong>: Memorize the universal template</li>
<li><strong>Solve classic problems</strong>: Permutations, combinations, subsets, N-Queens</li>
<li><strong>Identify patterns</strong>: Notice similarities across problems</li>
<li><strong>Focus on constraints</strong>: Practice identifying and checking constraints</li>
<li><strong>Optimize gradually</strong>: First get it working, then add pruning</li>
</ol>
<p><strong>Recommended progression</strong>:</p>
<ol>
<li>Permutations (basic)</li>
<li>Subsets (binary choices)</li>
<li>Combination Sum (reuse + constraints)</li>
<li>N-Queens (multiple constraints)</li>
<li>Generate Parentheses (custom constraints)</li>
<li>Word Break II (advanced, with memoization)</li>
</ol>
<hr>
<h1>Summary</h1>
<p>Backtracking is a powerful paradigm for solving constraint satisfaction problems. Here are the key takeaways:</p>
<h2 id="Core-Concepts-v2"><a class="header-anchor" href="#Core-Concepts-v2">¬∂</a>Core Concepts</h2>
<ol>
<li><strong>Framework</strong>: Make choice ‚Üí Recurse ‚Üí Backtrack (undo choice)</li>
<li><strong>Three elements</strong>: Choices, Constraints, Goal</li>
<li><strong>Relationship with DFS</strong>: Backtracking uses DFS but modifies and restores state</li>
</ol>
<h2 id="Template-Pattern"><a class="header-anchor" href="#Template-Pattern">¬∂</a>Template Pattern</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">    <span class="keyword">if</span> is_goal(path):</span><br><span class="line">        result.append(path[:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_valid(choice, path):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        path.append(choice)</span><br><span class="line">        backtrack(path, update_choices(choices, choice))</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>
<h2 id="Key-Techniques"><a class="header-anchor" href="#Key-Techniques">¬∂</a>Key Techniques</h2>
<ol>
<li><strong>Early pruning</strong>: Check constraints before recursing</li>
<li><strong>State management</strong>: Always restore state after recursion</li>
<li><strong>Avoid duplicates</strong>: Sort and skip, or use start index</li>
<li><strong>Efficient tracking</strong>: Use sets/arrays for O(1) lookups</li>
</ol>
<h2 id="Problem-Patterns"><a class="header-anchor" href="#Problem-Patterns">¬∂</a>Problem Patterns</h2>
<ul>
<li><strong>Permutations</strong>: Track used elements</li>
<li><strong>Combinations</strong>: Use start index to avoid duplicates</li>
<li><strong>Subsets</strong>: Save at every step</li>
<li><strong>Constraint satisfaction</strong>: Track all constraints separately</li>
<li><strong>String generation</strong>: Track counts (like parentheses)</li>
</ul>
<h2 id="Complexity-v2"><a class="header-anchor" href="#Complexity-v2">¬∂</a>Complexity</h2>
<ul>
<li><strong>Time</strong>: Usually exponential ($O(2^n)$ or $O(n!)$) but pruned significantly</li>
<li><strong>Space</strong>: $O(d)$ recursion depth + $O(n)$ auxiliary structures</li>
</ul>
<h2 id="Best-Practices-v3"><a class="header-anchor" href="#Best-Practices-v3">¬∂</a>Best Practices</h2>
<ol>
<li>‚úÖ Copy paths when saving: <code>result.append(path[:])</code></li>
<li>‚úÖ Always backtrack: <code>path.pop()</code> after recursion</li>
<li>‚úÖ Check constraints early: Before making choice</li>
<li>‚úÖ Use efficient data structures: Sets for membership, arrays for tracking</li>
<li>‚úÖ Prune aggressively: Skip invalid paths immediately</li>
</ol>
<p>Master backtracking by practicing the classic problems, internalizing the template, and learning to identify when backtracking is the right approach. With these tools, you‚Äôll be able to tackle a wide range of LeetCode problems efficiently!</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>Post titleÔºöLeetCode (7): Backtracking Algorithm</li>
        <li>Post authorÔºöChen Kai</li>
        <li>Create timeÔºö2023-03-19 00:00:00</li>
        <li>
            Post linkÔºöhttps://www.chenk.top/en/leetcode-backtracking/
        </li>
        <li>
            Copyright NoticeÔºöAll articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/en/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/en/tags/Algorithms/">#Algorithms</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/en/tags/Backtracking/">#Backtracking</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/en/linux-basics/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Linux Basics: Core Concepts and Essential Commands</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/en/leetcode-dynamic-programming-basics/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode (6): Dynamic Programming Basics</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: 'üòú Â∞ΩÊÉÖËµûÁæéÂ∏ÖÊ∞î‰ºüÂ§ßÁöÑckÂêß~',
                    lang: 'en'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return 'Âçö‰∏ª';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">Series Navigation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">What is Backtracking?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">Backtracking vs DFS: Understanding the Relationship</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS-Depth-First-Search"><span class="nav-number">3.1.</span> <span class="nav-text">DFS (Depth-First Search)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Backtracking"><span class="nav-number">3.2.</span> <span class="nav-text">Backtracking</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">The Three Essential Elements of Backtracking</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Choices-What-decisions-can-we-make"><span class="nav-number">4.1.</span> <span class="nav-text">1. Choices (What decisions can we make?)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Constraints-What-makes-a-choice-valid"><span class="nav-number">4.2.</span> <span class="nav-text">2. Constraints (What makes a choice valid?)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Goal-When-have-we-found-a-solution"><span class="nav-number">4.3.</span> <span class="nav-text">3. Goal (When have we found a solution?)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">5.</span> <span class="nav-text">Universal Backtracking Template</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">6.</span> <span class="nav-text">Problem 1: Permutations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-Statement-v10"><span class="nav-number">6.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Analysis"><span class="nav-number">6.2.</span> <span class="nav-text">Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution"><span class="nav-number">6.3.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">7.</span> <span class="nav-text">Problem 2: Combination Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-Statement-v11"><span class="nav-number">7.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Analysis-v2"><span class="nav-number">7.2.</span> <span class="nav-text">Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-v2"><span class="nav-number">7.3.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">8.</span> <span class="nav-text">Problem 3: Subsets</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-Statement-v12"><span class="nav-number">8.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Analysis-v3"><span class="nav-number">8.2.</span> <span class="nav-text">Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-v3"><span class="nav-number">8.3.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">9.</span> <span class="nav-text">Problem 4: N-Queens</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-Statement-v13"><span class="nav-number">9.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Analysis-v4"><span class="nav-number">9.2.</span> <span class="nav-text">Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-v4"><span class="nav-number">9.3.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">10.</span> <span class="nav-text">Problem 5: Generate Parentheses</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-Statement-v14"><span class="nav-number">10.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Analysis-v5"><span class="nav-number">10.2.</span> <span class="nav-text">Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-v5"><span class="nav-number">10.3.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">11.</span> <span class="nav-text">Pruning Optimization Techniques</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Early-Termination"><span class="nav-number">11.1.</span> <span class="nav-text">1. Early Termination</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Constraint-Propagation"><span class="nav-number">11.2.</span> <span class="nav-text">2. Constraint Propagation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Memoization-for-overlapping-subproblems"><span class="nav-number">11.3.</span> <span class="nav-text">3. Memoization (for overlapping subproblems)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Sort-and-Skip-Duplicates"><span class="nav-number">11.4.</span> <span class="nav-text">4. Sort and Skip Duplicates</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Bounds-Checking"><span class="nav-number">11.5.</span> <span class="nav-text">5. Bounds Checking</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">12.</span> <span class="nav-text">Complexity Analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Time-Complexity-v3"><span class="nav-number">12.1.</span> <span class="nav-text">Time Complexity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Space-Complexity-v4"><span class="nav-number">12.2.</span> <span class="nav-text">Space Complexity</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">13.</span> <span class="nav-text">Common Pitfalls and Debugging Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Pitfall-1-Not-Copying-Paths"><span class="nav-number">13.1.</span> <span class="nav-text">Pitfall 1: Not Copying Paths</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pitfall-2-Forgetting-to-Backtrack"><span class="nav-number">13.2.</span> <span class="nav-text">Pitfall 2: Forgetting to Backtrack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pitfall-3-Modifying-Choices-Incorrectly"><span class="nav-number">13.3.</span> <span class="nav-text">Pitfall 3: Modifying Choices Incorrectly</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pitfall-4-Wrong-Constraint-Checking-Order"><span class="nav-number">13.4.</span> <span class="nav-text">Pitfall 4: Wrong Constraint Checking Order</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Debugging-Checklist-v3"><span class="nav-number">13.5.</span> <span class="nav-text">Debugging Checklist</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">14.</span> <span class="nav-text">Q&amp;A: 10 Frequently Asked Questions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q1-When-should-I-use-backtracking-vs-dynamic-programming"><span class="nav-number">14.1.</span> <span class="nav-text">Q1: When should I use backtracking vs dynamic programming?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q2-How-do-I-avoid-duplicate-solutions"><span class="nav-number">14.2.</span> <span class="nav-text">Q2: How do I avoid duplicate solutions?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q3-Why-is-my-solution-too-slow"><span class="nav-number">14.3.</span> <span class="nav-text">Q3: Why is my solution too slow?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q4-Can-I-use-iteration-instead-of-recursion"><span class="nav-number">14.4.</span> <span class="nav-text">Q4: Can I use iteration instead of recursion?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q5-How-do-I-handle-problems-with-multiple-constraints"><span class="nav-number">14.5.</span> <span class="nav-text">Q5: How do I handle problems with multiple constraints?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q6-What%E2%80%99s-the-difference-between-permutations-and-combinations"><span class="nav-number">14.6.</span> <span class="nav-text">Q6: What‚Äôs the difference between permutations and combinations?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q7-How-do-I-optimize-for-%E2%80%9Cfind-one-solution%E2%80%9D-vs-%E2%80%9Cfind-all-solutions%E2%80%9D"><span class="nav-number">14.7.</span> <span class="nav-text">Q7: How do I optimize for ‚Äúfind one solution‚Äù vs ‚Äúfind all solutions‚Äù?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q8-Can-backtracking-solve-optimization-problems"><span class="nav-number">14.8.</span> <span class="nav-text">Q8: Can backtracking solve optimization problems?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q9-How-do-I-handle-problems-with-variable-length-solutions"><span class="nav-number">14.9.</span> <span class="nav-text">Q9: How do I handle problems with variable-length solutions?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q10-What%E2%80%99s-the-best-way-to-practice-backtracking"><span class="nav-number">14.10.</span> <span class="nav-text">Q10: What‚Äôs the best way to practice backtracking?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">15.</span> <span class="nav-text">Summary</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Core-Concepts-v2"><span class="nav-number">15.1.</span> <span class="nav-text">Core Concepts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Template-Pattern"><span class="nav-number">15.2.</span> <span class="nav-text">Template Pattern</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Key-Techniques"><span class="nav-number">15.3.</span> <span class="nav-text">Key Techniques</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-Patterns"><span class="nav-number">15.4.</span> <span class="nav-text">Problem Patterns</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Complexity-v2"><span class="nav-number">15.5.</span> <span class="nav-text">Complexity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Best-Practices-v3"><span class="nav-number">15.6.</span> <span class="nav-text">Best Practices</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
