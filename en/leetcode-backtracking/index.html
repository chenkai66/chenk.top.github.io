<!DOCTYPE html>



<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode (8): Backtracking Algorithm |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"en","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/en/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode (8): Backtracking Algorithm</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-07-28 00:00:00</span>
        <span class="mobile">2023-07-28 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/en/tags/Algorithms/">Algorithms</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/en/tags/Backtracking/">Backtracking</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>4.5k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>28 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>Backtracking is one of the most elegant and powerful algorithmic
paradigms for solving constraint satisfaction problems. Unlike brute
force that blindly explores all possibilities, backtracking builds
solutions incrementally and abandons partial solutions ("backtracks") as
soon as they cannot lead to a valid answer. This makes it perfect for
problems like generating permutations, finding combinations, solving
puzzles (N-Queens, Sudoku), and exploring decision trees. This guide
teaches you the backtracking framework through five classic LeetCode
problems, shows you how to identify when to use backtracking,
demonstrates pruning techniques to optimize your solutions, and provides
a reusable template that works across 90% of backtracking problems.
We'll also cover complexity analysis, common pitfalls, and answer 10
frequently asked questions.</p>
<span id="more"></span>
<h1 id="series-navigation">Series Navigation</h1>
<p>üìö <strong>LeetCode Algorithm Masterclass Series</strong> (10 Parts):
1. Hash Tables (Two Sum, Longest Consecutive, Group Anagrams) 2. Two
Pointers Techniques (Collision pointers, fast-slow, sliding window) 3.
Linked List Operations (Reverse, cycle detection, merge) 4. Binary Tree
Traversal &amp; Recursion (Inorder/Preorder/Postorder, LCA) 5. Dynamic
Programming Intro (1D/2D DP, state transition) 6. Binary Search Advanced
(Integer/Real binary search, answer binary search) 7. <strong>‚Üí
Backtracking Algorithms</strong> (Permutations, combinations, pruning) ‚Üê
<em>You are here</em> 8. Stack &amp; Queue (Monotonic stack, priority
queue, deque) 9. Graph Algorithms (BFS/DFS, topological sort,
union-find) 10. Greedy &amp; Bit Manipulation (Greedy strategies,
bitwise tricks)</p>
<hr>
<h1 id="what-is-backtracking">What is Backtracking?</h1>
<p>Backtracking is a systematic method for solving problems by trying
partial solutions and then abandoning them ("backtracking") if they
cannot be completed to a valid solution. It's essentially a refined form
of brute force search that uses constraints to prune the search
space.</p>
<p><strong>Key characteristics</strong>:</p>
<ul>
<li><strong>Incremental construction</strong>: Builds solutions step by
step</li>
<li><strong>Constraint checking</strong>: Validates partial solutions
before continuing</li>
<li><strong>Pruning</strong>: Abandons paths that cannot lead to valid
solutions</li>
<li><strong>Recursive exploration</strong>: Uses recursion to explore
the solution space</li>
</ul>
<p><strong>When to use backtracking</strong>:</p>
<ul>
<li>Problems asking for "all possible" solutions (permutations,
combinations, subsets)</li>
<li>Constraint satisfaction problems (N-Queens, Sudoku)</li>
<li>Problems with exponential search space that can be pruned</li>
<li>Decision problems where you need to explore multiple paths</li>
</ul>
<hr>
<h1 id="backtracking-vs-dfs-understanding-the-relationship">Backtracking
vs DFS: Understanding the Relationship</h1>
<p>Many beginners confuse backtracking with DFS (Depth-First Search).
Here's the key distinction:</p>
<h2 id="dfs-depth-first-search">DFS (Depth-First Search)</h2>
<ul>
<li><strong>Purpose</strong>: Traverse or search a graph/tree
structure</li>
<li><strong>Focus</strong>: Visit all nodes, find paths, explore
structure</li>
<li><strong>State</strong>: Usually doesn't modify the graph
structure</li>
<li><strong>Example</strong>: Finding if a path exists from node A to
node B</li>
</ul>
<h2 id="backtracking">Backtracking</h2>
<ul>
<li><strong>Purpose</strong>: Solve constraint satisfaction
problems</li>
<li><strong>Focus</strong>: Build valid solutions incrementally</li>
<li><strong>State</strong>: <strong>Modifies and restores state</strong>
(this is crucial!)</li>
<li><strong>Example</strong>: Finding all valid N-Queen placements</li>
</ul>
<p><strong>The relationship</strong>: Backtracking <strong>uses</strong>
DFS as its exploration mechanism, but adds: 1. <strong>State
modification</strong>: Make a choice (add element to solution) 2.
<strong>Constraint checking</strong>: Verify if current path is valid 3.
<strong>State restoration</strong>: Undo the choice (backtrack) if
invalid or after exploring</p>
<p><strong>Visual analogy</strong>:</p>
<ul>
<li><strong>DFS</strong>: Walking through a maze, marking visited
rooms</li>
<li><strong>Backtracking</strong>: Placing chess pieces on a board,
removing them if the placement leads to an invalid configuration</li>
</ul>
<hr>
<h1 id="the-three-essential-elements-of-backtracking">The Three
Essential Elements of Backtracking</h1>
<p>Every backtracking problem has three core components:</p>
<h2 id="choices-what-decisions-can-we-make">1. Choices (What decisions
can we make?)</h2>
<p>At each step, identify what choices are available. For example:</p>
<ul>
<li><strong>Permutations</strong>: Which number to place at position
<span class="math inline">\(i\)</span>?</li>
<li><strong>N-Queens</strong>: Which column to place the queen in row
<span class="math inline">\(i\)</span>?</li>
<li><strong>Subsets</strong>: Include the current element or not?</li>
</ul>
<h2 id="constraints-what-makes-a-choice-valid">2. Constraints (What
makes a choice valid?)</h2>
<p>Define what makes a partial solution valid:</p>
<ul>
<li><strong>Permutations</strong>: No duplicates in the current
path</li>
<li><strong>N-Queens</strong>: No two queens attack each other</li>
<li><strong>Combination Sum</strong>: Sum doesn't exceed target, no
duplicates</li>
</ul>
<h2 id="goal-when-have-we-found-a-solution">3. Goal (When have we found
a solution?)</h2>
<p>Determine when a complete solution is found:</p>
<ul>
<li><strong>Permutations</strong>: All positions filled</li>
<li><strong>N-Queens</strong>: All <span class="math inline">\(n\)</span> queens placed</li>
<li><strong>Subsets</strong>: All elements processed (or sum equals
target)</li>
</ul>
<p><strong>Template thinking</strong>: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def backtrack(path, choices):</span><br><span class="line">    # Goal: Is this a complete solution?</span><br><span class="line">    if is_goal(path):</span><br><span class="line">        result.append(path.copy())  # Save solution</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    # Explore choices</span><br><span class="line">    for choice in choices:</span><br><span class="line">        # Constraint: Is this choice valid?</span><br><span class="line">        if is_valid(choice, path):</span><br><span class="line">            # Make choice</span><br><span class="line">            path.append(choice)</span><br><span class="line">            # Recurse</span><br><span class="line">            backtrack(path, updated_choices)</span><br><span class="line">            # Backtrack: undo choice</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="universal-backtracking-template">Universal Backtracking
Template</h1>
<p>Here's a reusable template that works for most backtracking
problems:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack_template</span>():</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">        <span class="comment"># Base case: goal reached</span></span><br><span class="line">        <span class="keyword">if</span> is_goal(path):</span><br><span class="line">            result.append(path[:])  <span class="comment"># Copy, don&#x27;t reference!</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Explore all choices</span></span><br><span class="line">        <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">            <span class="comment"># Pruning: skip invalid choices early</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_valid(choice, path):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Make choice</span></span><br><span class="line">            path.append(choice)</span><br><span class="line">            <span class="comment"># Update choices for next level (if needed)</span></span><br><span class="line">            new_choices = update_choices(choices, choice)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Recurse</span></span><br><span class="line">            backtrack(path, new_choices)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Backtrack: undo choice</span></span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack([], initial_choices)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Critical points</strong>: 1. <strong>Copy paths</strong>: Use
<code>path[:]</code> or <code>path.copy()</code> when saving solutions
2. <strong>Restore state</strong>: Always undo changes after recursion
(<code>path.pop()</code>) 3. <strong>Prune early</strong>: Check
constraints before recursing 4. <strong>Update choices</strong>: Some
problems require modifying available choices</p>
<hr>
<h1 id="problem-1-permutations">Problem 1: Permutations</h1>
<h2 id="problem-statement">Problem Statement</h2>
<p>Given an array <code>nums</code> of distinct integers, return all
possible permutations. You can return the answer in any order.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>nums = [1,2,3]</code></li>
<li>Output:
<code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></li>
</ul>
<p><strong>Constraints</strong>:</p>
<ul>
<li><span class="math inline">\(1 \leq \texttt{nums.length} \leq
6\)</span></li>
<li><span class="math inline">\(-10 \leq \texttt{nums[i]} \leq
10\)</span></li>
<li>All integers are distinct</li>
</ul>
<h2 id="problem-analysis">Problem Analysis</h2>
<p>Permutations problem requires generating all possible orderings of
array elements. For <span class="math inline">\(n\)</span> distinct
elements, there are <span class="math inline">\(n!\)</span>
permutations.</p>
<p><strong>Core Challenges</strong>:</p>
<ol type="1">
<li><strong>Avoiding duplicate selections</strong>: Each element can
appear only once in each permutation</li>
<li><strong>Systematically exploring all possibilities</strong>: Need to
try all possible permutation combinations</li>
<li><strong>Efficient backtracking</strong>: When a path cannot
continue, need to undo choices and try alternatives</li>
</ol>
<p><strong>Use Cases</strong>:</p>
<ul>
<li>Password cracking: Try all possible password combinations</li>
<li>Task scheduling: Arrange task execution order</li>
<li>Game solving: Explore all possible game states</li>
</ul>
<h2 id="solution-approach">Solution Approach</h2>
<p><strong>Three Elements Analysis</strong>:</p>
<ul>
<li><strong>Choices</strong>: Which number to place at current position?
(All unused numbers)</li>
<li><strong>Constraints</strong>: Cannot select numbers already used
(tracked by <code>used</code> array)</li>
<li><strong>Goal</strong>: Path length equals array length (complete
permutation generated)</li>
</ul>
<p><strong>Algorithm Flow</strong>:</p>
<ol type="1">
<li>Use <code>used</code> array to mark which numbers have been
used</li>
<li>Use <code>path</code> list to record current path (partial
permutation)</li>
<li>Recursive function <code>backtrack()</code>:
<ul>
<li>If <code>path</code> length equals <code>nums</code> length, save
result and return</li>
<li>Iterate through all numbers, if unused:
<ul>
<li>Mark as used</li>
<li>Add to <code>path</code></li>
<li>Recursively process next position</li>
<li>Backtrack: undo mark and choice</li>
</ul></li>
</ul></li>
</ol>
<h2 id="complexity-analysis">Complexity Analysis</h2>
<p><strong>Time Complexity</strong>: <span class="math inline">\(O(n
\times n!)\)</span></p>
<ul>
<li>Total <span class="math inline">\(n!\)</span> permutations (leaf
nodes)</li>
<li>Each permutation takes <span class="math inline">\(O(n)\)</span>
time to copy to result</li>
<li>Total time: <span class="math inline">\(O(n \times n!)\)</span></li>
</ul>
<p><strong>Space Complexity</strong>: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>Recursion stack depth: <span class="math inline">\(O(n)\)</span> (at
most <span class="math inline">\(n\)</span> levels)</li>
<li><code>path</code> array: <span class="math inline">\(O(n)\)</span></li>
<li><code>used</code> array: <span class="math inline">\(O(n)\)</span></li>
<li>Result array: <span class="math inline">\(O(n \times n!)\)</span>
(output space, not counted)</li>
</ul>
<p><strong>Complexity Proof</strong>:</p>
<p>For permutation of <span class="math inline">\(n\)</span> elements: -
Level 1 has <span class="math inline">\(n\)</span> choices - Level 2 has
<span class="math inline">\(n-1\)</span> choices - ... - Level <span class="math inline">\(n\)</span> has <span class="math inline">\(1\)</span> choice</p>
<p>Total permutations: <span class="math inline">\(n \times (n-1) \times
\cdots \times 1 = n!\)</span></p>
<p>Each permutation needs <span class="math inline">\(O(n)\)</span> time
to copy, so total time complexity is <span class="math inline">\(O(n
\times n!)\)</span>.</p>
<h2 id="solution">Solution</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Generate all permutations of array</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Algorithm Steps:</span></span><br><span class="line"><span class="string">        1. Initialize result list, path list, and used array</span></span><br><span class="line"><span class="string">        2. Define backtrack function:</span></span><br><span class="line"><span class="string">           a. Termination: path length equals array length, save result</span></span><br><span class="line"><span class="string">           b. Iterate through all numbers, skip used ones</span></span><br><span class="line"><span class="string">           c. Make choice: mark used, add to path</span></span><br><span class="line"><span class="string">           d. Recurse: process next position</span></span><br><span class="line"><span class="string">           e. Undo choice: restore mark, remove from path</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Boundary Conditions:</span></span><br><span class="line"><span class="string">        - Empty array: return [[]]</span></span><br><span class="line"><span class="string">        - Single element: return [[element]]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Optimization Techniques:</span></span><br><span class="line"><span class="string">        - Use used array to avoid duplicate selection (O(1) lookup)</span></span><br><span class="line"><span class="string">        - Use path[:] to create copy when saving result (avoid reference issue)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Variable Meanings:</span></span><br><span class="line"><span class="string">        - result: List storing all permutations</span></span><br><span class="line"><span class="string">        - path: Current permutation being built</span></span><br><span class="line"><span class="string">        - used: Boolean array, used[i] indicates if nums[i] is used</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        path = []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)  <span class="comment"># Mark which numbers are used</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>():</span><br><span class="line">            <span class="comment"># Termination: path length equals array length</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                result.append(path[:])  <span class="comment"># Create copy, avoid reference issue</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Iterate through all possible choices</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># Constraint check: skip used numbers</span></span><br><span class="line">                <span class="keyword">if</span> used[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Make choice</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Recurse: process next position</span></span><br><span class="line">                backtrack()</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Undo choice (backtrack)</span></span><br><span class="line">                path.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Alternative using set</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute_set</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> path:  <span class="comment"># Constraint check</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(num)</span><br><span class="line">            backtrack(path)</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack([])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Complexity</strong>:</p>
<ul>
<li><strong>Time</strong>: <span class="math inline">\(O(n! \times
n)\)</span> - There are <span class="math inline">\(n!\)</span>
permutations, and each takes <span class="math inline">\(O(n)\)</span>
to copy</li>
<li><strong>Space</strong>: <span class="math inline">\(O(n)\)</span> -
Recursion depth and path storage</li>
</ul>
<hr>
<h1 id="problem-2-combination-sum">Problem 2: Combination Sum</h1>
<h2 id="problem-statement-1">Problem Statement</h2>
<p>Given an array of distinct integers <code>candidates</code> and a
target integer <code>target</code>, return a list of all unique
combinations of <code>candidates</code> where the chosen numbers sum to
<code>target</code>. You may return the combinations in any order. The
same number may be chosen from <code>candidates</code> an unlimited
number of times.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>candidates = [2,3,6,7]</code>,
<code>target = 7</code></li>
<li>Output: <code>[[2,2,3],[7]]</code></li>
</ul>
<p><strong>Constraints</strong>:</p>
<ul>
<li><span class="math inline">\(1 \leq \texttt{candidates.length} \leq
30\)</span></li>
<li><span class="math inline">\(2 \leq \texttt{candidates[i]} \leq
40\)</span></li>
<li>All elements are distinct</li>
<li><span class="math inline">\(1 \leq \texttt{target} \leq
500\)</span></li>
</ul>
<h2 id="problem-analysis-1">Problem Analysis</h2>
<p>Combination Sum requires finding all combinations that sum to target,
with each number reusable unlimited times.</p>
<p><strong>Core Challenges</strong>:</p>
<ol type="1">
<li><strong>Avoiding duplicate combinations</strong>: <code>[2,3]</code>
and <code>[3,2]</code> are the same combination</li>
<li><strong>Controlling search space</strong>: Early termination when
remaining value becomes negative</li>
<li><strong>Allowing reuse</strong>: Same number can appear multiple
times in combination</li>
</ol>
<p><strong>Key Insight</strong>:</p>
<p>By <strong>limiting choice range</strong> (starting from
<code>start</code>), we avoid duplicates. Always starting from array
beginning would produce both <code>[2,3]</code> and <code>[3,2]</code>.
By only choosing from current position onward, we ensure numbers in
combination follow array order, avoiding duplicates.</p>
<h2 id="solution-approach-1">Solution Approach</h2>
<p><strong>Three Elements Analysis</strong>:</p>
<ul>
<li><strong>Choices</strong>: Which number to add to current
combination? (Starting from <code>start</code> position)</li>
<li><strong>Constraints</strong>:
<ul>
<li>Combination sum cannot exceed <code>target</code>
(<code>remain &gt;= 0</code>)</li>
<li>Only choose from current position onward (avoid duplicates)</li>
</ul></li>
<li><strong>Goal</strong>: Combination sum equals <code>target</code>
(<code>remain == 0</code>)</li>
</ul>
<p><strong>Algorithm Flow</strong>:</p>
<ol type="1">
<li>Define backtrack function <code>backtrack(start, remain)</code>:
<ul>
<li><code>start</code>: Starting index for current choices</li>
<li><code>remain</code>: Remaining target sum</li>
</ul></li>
<li>Termination conditions:
<ul>
<li><code>remain == 0</code>: Found valid combination, save result</li>
<li><code>remain &lt; 0</code>: Current path invalid, return
immediately</li>
</ul></li>
<li>Iterate through all candidates starting from <code>start</code>:
<ul>
<li>Add to current path</li>
<li>Recurse: <code>backtrack(i, remain - candidates[i])</code> (start
from <code>i</code>, allow reuse)</li>
<li>Backtrack: Remove current choice</li>
</ul></li>
</ol>
<h2 id="complexity-analysis-1">Complexity Analysis</h2>
<p><strong>Time Complexity</strong>: <span class="math inline">\(O(2^N)\)</span>, where <span class="math inline">\(N = \lceil \texttt{target} /
\min(\texttt{candidates}) \rceil\)</span></p>
<ul>
<li>Worst case, each position has two choices (select or not)</li>
<li>Due to reuse allowed, actual search space may be larger</li>
<li>Pruning can significantly reduce actual nodes searched</li>
</ul>
<p><strong>Space Complexity</strong>: <span class="math inline">\(O(\texttt{target})\)</span></p>
<ul>
<li>Recursion stack depth at most <code>target</code> (when always
selecting smallest number)</li>
<li><code>path</code> array length at most <code>target</code></li>
</ul>
<p><strong>Complexity Proof</strong>:</p>
<p>Assuming minimum candidate is <span class="math inline">\(m\)</span>,
need to select at most <span class="math inline">\(\lceil
\texttt{target} / m \rceil\)</span> numbers. Each position has <span class="math inline">\(|\texttt{candidates}|\)</span> choices, but due to
pruning and reuse constraints, actual complexity is between <span class="math inline">\(O(2^N)\)</span> and <span class="math inline">\(O(k^N)\)</span>, where <span class="math inline">\(k = |\texttt{candidates}|\)</span>.</p>
<h2 id="solution-1">Solution</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Find all combinations summing to target (numbers reusable)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Algorithm Steps:</span></span><br><span class="line"><span class="string">        1. Define backtrack function backtrack(start, remain):</span></span><br><span class="line"><span class="string">           a. Termination 1: remain == 0, save result</span></span><br><span class="line"><span class="string">           b. Termination 2: remain &lt; 0, prune and return</span></span><br><span class="line"><span class="string">           c. Iterate candidates starting from start</span></span><br><span class="line"><span class="string">           d. Make choice: add to path</span></span><br><span class="line"><span class="string">           e. Recurse: backtrack(i, remain - candidates[i]) (from i, allow reuse)</span></span><br><span class="line"><span class="string">           f. Undo choice: remove from path</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Boundary Conditions:</span></span><br><span class="line"><span class="string">        - Empty array: return []</span></span><br><span class="line"><span class="string">        - target is 0: return [[]]</span></span><br><span class="line"><span class="string">        - All candidates &gt; target: return []</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Optimization Techniques:</span></span><br><span class="line"><span class="string">        - Use start parameter to avoid duplicate combinations</span></span><br><span class="line"><span class="string">        - Prune early when remain &lt; 0, reduce invalid search</span></span><br><span class="line"><span class="string">        - Sorting enables further optimization (see optimized version below)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Variable Meanings:</span></span><br><span class="line"><span class="string">        - result: List storing all valid combinations</span></span><br><span class="line"><span class="string">        - path: Current combination being built</span></span><br><span class="line"><span class="string">        - start: Starting index for current choices (avoid duplicates)</span></span><br><span class="line"><span class="string">        - remain: Remaining target sum</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        path = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start, remain</span>):</span><br><span class="line">            <span class="comment"># Termination 1: Found valid combination</span></span><br><span class="line">            <span class="keyword">if</span> remain == <span class="number">0</span>:</span><br><span class="line">                result.append(path[:])  <span class="comment"># Save result</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Termination 2: Current path invalid (pruning)</span></span><br><span class="line">            <span class="keyword">if</span> remain &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Choose from start onward, avoid duplicate combinations</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="comment"># Make choice</span></span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Recurse: Start from i (not i+1), allow reuse</span></span><br><span class="line">                backtrack(i, remain - candidates[i])</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Undo choice (backtrack)</span></span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="number">0</span>, target)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Algorithm Principle</strong>:</p>
<p><strong>Why starting from <code>start</code> avoids
duplicates</strong>:</p>
<p>Assume <code>candidates = [2,3,6,7]</code>,
<code>target = 7</code>:</p>
<ul>
<li>If starting from 0: May produce <code>[2,3]</code> and
<code>[3,2]</code> (duplicate)</li>
<li>If starting from <code>start</code>:
<ul>
<li>After selecting 2, <code>start=0</code>, can only select 2,3,6,7 ‚Üí
produces <code>[2,2,3]</code>, <code>[2,3]</code> etc.</li>
<li>After selecting 3, <code>start=1</code>, can only select 3,6,7 ‚Üí
produces <code>[3,3]</code> etc.</li>
<li>Won't produce <code>[3,2]</code> because when selecting 3,
<code>start=1</code>, won't select 2 again</li>
</ul></li>
</ul>
<p><strong>Why recurse from <code>i</code> (not
<code>i+1</code>)</strong>:</p>
<p>Because problem allows reusing same number. If starting from
<code>i+1</code>, each number can be used only once, which becomes
"Combination Sum II" problem.</p>
<p><strong>Common Pitfalls</strong>:</p>
<h3 id="pitfall-1-starting-from-0-causes-duplicates">Pitfall 1: Starting
from 0 causes duplicates</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ‚ùå Wrong</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(candidates)):  <span class="comment"># Always starting from 0</span></span><br><span class="line">    backtrack(i, remain - candidates[i])</span><br><span class="line"><span class="comment"># Produces duplicates like [2,3] and [3,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ‚úÖ Correct</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(candidates)):  <span class="comment"># Start from start</span></span><br><span class="line">    backtrack(i, remain - candidates[i])</span><br></pre></td></tr></table></figure>
<h3 id="pitfall-2-using-i1-prevents-reuse">Pitfall 2: Using
<code>i+1</code> prevents reuse</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ‚ùå Wrong</span></span><br><span class="line">backtrack(i + <span class="number">1</span>, remain - candidates[i])  <span class="comment"># Each number usable once</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ‚úÖ Correct</span></span><br><span class="line">backtrack(i, remain - candidates[i])  <span class="comment"># Allow reuse</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="problem-3-subsets">Problem 3: Subsets</h1>
<h2 id="problem-statement-2">Problem Statement</h2>
<p>Given an integer array <code>nums</code> of unique elements, return
all possible subsets (the power set). The solution set must not contain
duplicate subsets. Return the solution in any order.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>nums = [1,2,3]</code></li>
<li>Output: <code>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></li>
</ul>
<p><strong>Constraints</strong>:</p>
<ul>
<li><span class="math inline">\(1 \leq \texttt{nums.length} \leq
10\)</span></li>
<li><span class="math inline">\(-10 \leq \texttt{nums[i]} \leq
10\)</span></li>
<li>All elements are unique</li>
</ul>
<h2 id="analysis">Analysis</h2>
<p><strong>Three elements</strong>:</p>
<ul>
<li><strong>Choices</strong>: Include current element or skip it?</li>
<li><strong>Constraints</strong>: No constraints (all subsets are
valid)</li>
<li><strong>Goal</strong>: Processed all elements</li>
</ul>
<p><strong>Key insight</strong>: At each element, we have two choices:
include it or exclude it. This creates a binary tree of decisions.</p>
<h2 id="solution-2">Solution</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, start</span>):</span><br><span class="line">        <span class="comment"># Goal: save current subset (all paths are valid)</span></span><br><span class="line">        result.append(path[:])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Try including each remaining element</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            backtrack(path, i + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack([], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Alternative: binary decision approach</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsets_binary</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, index</span>):</span><br><span class="line">        <span class="comment"># Goal: processed all elements</span></span><br><span class="line">        <span class="keyword">if</span> index == n:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Choice 1: skip current element</span></span><br><span class="line">        backtrack(path, index + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Choice 2: include current element</span></span><br><span class="line">        path.append(nums[index])</span><br><span class="line">        backtrack(path, index + <span class="number">1</span>)</span><br><span class="line">        path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack([], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Complexity</strong>:</p>
<ul>
<li><strong>Time</strong>: <span class="math inline">\(O(2^n \times
n)\)</span> - <span class="math inline">\(2^n\)</span> subsets, each
copied in <span class="math inline">\(O(n)\)</span></li>
<li><strong>Space</strong>: <span class="math inline">\(O(n)\)</span> -
Recursion depth</li>
</ul>
<hr>
<h1 id="problem-4-n-queens">Problem 4: N-Queens</h1>
<h2 id="problem-statement-3">Problem Statement</h2>
<p>The n-queens puzzle is the problem of placing <span class="math inline">\(n\)</span> queens on an <span class="math inline">\(n \times n\)</span> chessboard such that no two
queens attack each other. Given an integer <span class="math inline">\(n\)</span>, return all distinct solutions to the
n-queens puzzle. You may return the answer in any order.</p>
<p>Each solution contains a distinct board configuration of the
n-queens' placement, where <code>'Q'</code> and <code>'.'</code>
indicate a queen and an empty space, respectively.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>n = 4</code></li>
<li>Output:
<code>[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]</code></li>
</ul>
<p><strong>Constraints</strong>:</p>
<ul>
<li><span class="math inline">\(1 \leq n \leq 9\)</span></li>
</ul>
<h2 id="analysis-1">Analysis</h2>
<p><strong>Three elements</strong>:</p>
<ul>
<li><strong>Choices</strong>: Which column to place queen in row <span class="math inline">\(i\)</span>?</li>
<li><strong>Constraints</strong>:
<ul>
<li>No two queens in same column</li>
<li>No two queens in same diagonal (both main and anti-diagonal)</li>
</ul></li>
<li><strong>Goal</strong>: All <span class="math inline">\(n\)</span>
queens placed</li>
</ul>
<p><strong>Key insight</strong>:</p>
<ul>
<li>Place queens row by row (one per row)</li>
<li>Track used columns and diagonals</li>
<li>Diagonals: <code>row - col</code> (main) and <code>row + col</code>
(anti-diagonal) are constant</li>
</ul>
<h2 id="solution-3">Solution</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">n</span>):</span><br><span class="line">    result = []</span><br><span class="line">    board = [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Track constraints</span></span><br><span class="line">    used_cols = <span class="built_in">set</span>()</span><br><span class="line">    used_diag1 = <span class="built_in">set</span>()  <span class="comment"># row - col</span></span><br><span class="line">    used_diag2 = <span class="built_in">set</span>()  <span class="comment"># row + col</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row</span>):</span><br><span class="line">        <span class="comment"># Goal: all queens placed</span></span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            <span class="comment"># Convert board to required format</span></span><br><span class="line">            solution = [<span class="string">&#x27;&#x27;</span>.join(row) <span class="keyword">for</span> row <span class="keyword">in</span> board]</span><br><span class="line">            result.append(solution)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Try each column</span></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            diag1 = row - col</span><br><span class="line">            diag2 = row + col</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Constraint check</span></span><br><span class="line">            <span class="keyword">if</span> col <span class="keyword">in</span> used_cols <span class="keyword">or</span> diag1 <span class="keyword">in</span> used_diag1 <span class="keyword">or</span> diag2 <span class="keyword">in</span> used_diag2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Make choice</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">            used_cols.add(col)</span><br><span class="line">            used_diag1.add(diag1)</span><br><span class="line">            used_diag2.add(diag2)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Recurse</span></span><br><span class="line">            backtrack(row + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Backtrack</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">            used_cols.remove(col)</span><br><span class="line">            used_diag1.remove(diag1)</span><br><span class="line">            used_diag2.remove(diag2)</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Optimization</strong>: Using boolean arrays instead of sets
(faster for small <span class="math inline">\(n\)</span>):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solveNQueens_optimized</span>(<span class="params">n</span>):</span><br><span class="line">    result = []</span><br><span class="line">    board = [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    used_cols = [<span class="literal">False</span>] * n</span><br><span class="line">    used_diag1 = [<span class="literal">False</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)  <span class="comment"># row - col ranges from -(n-1) to (n-1)</span></span><br><span class="line">    used_diag2 = [<span class="literal">False</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)  <span class="comment"># row + col ranges from 0 to 2(n-1)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row</span>):</span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            result.append([<span class="string">&#x27;&#x27;</span>.join(row) <span class="keyword">for</span> row <span class="keyword">in</span> board])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            diag1 = row - col + n - <span class="number">1</span>  <span class="comment"># Shift to non-negative index</span></span><br><span class="line">            diag2 = row + col</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> used_cols[col] <span class="keyword">or</span> used_diag1[diag1] <span class="keyword">or</span> used_diag2[diag2]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">            used_cols[col] = <span class="literal">True</span></span><br><span class="line">            used_diag1[diag1] = <span class="literal">True</span></span><br><span class="line">            used_diag2[diag2] = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            backtrack(row + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">            used_cols[col] = <span class="literal">False</span></span><br><span class="line">            used_diag1[diag1] = <span class="literal">False</span></span><br><span class="line">            used_diag2[diag2] = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Complexity</strong>:</p>
<ul>
<li><strong>Time</strong>: <span class="math inline">\(O(n!)\)</span> -
First row has <span class="math inline">\(n\)</span> choices, second has
at most <span class="math inline">\(n-1\)</span>, etc.</li>
<li><strong>Space</strong>: <span class="math inline">\(O(n^2)\)</span>
- Board storage + <span class="math inline">\(O(n)\)</span> recursion
depth</li>
</ul>
<hr>
<h1 id="problem-5-generate-parentheses">Problem 5: Generate
Parentheses</h1>
<h2 id="problem-statement-4">Problem Statement</h2>
<p>Given <span class="math inline">\(n\)</span> pairs of parentheses,
write a function to generate all combinations of well-formed
parentheses.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>n = 3</code></li>
<li>Output:
<code>["((()))","(()())","(())()","()(())","()()()"]</code></li>
</ul>
<p><strong>Constraints</strong>:</p>
<ul>
<li><span class="math inline">\(1 \leq n \leq 8\)</span></li>
</ul>
<h2 id="analysis-2">Analysis</h2>
<p><strong>Three elements</strong>:</p>
<ul>
<li><strong>Choices</strong>: Add <code>'('</code> or
<code>')'</code>?</li>
<li><strong>Constraints</strong>:
<ul>
<li>Can only add <code>'('</code> if count of <code>'('</code> &lt;
<span class="math inline">\(n\)</span></li>
<li>Can only add <code>')'</code> if count of <code>')'</code> &lt;
count of <code>'('</code></li>
</ul></li>
<li><strong>Goal</strong>: Length equals <span class="math inline">\(2n\)</span> and string is valid</li>
</ul>
<p><strong>Key insight</strong>: Track counts of open and close
parentheses. Only add <code>')'</code> when there are unmatched
<code>'('</code>.</p>
<h2 id="solution-4">Solution</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">n</span>):</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, open_count, close_count</span>):</span><br><span class="line">        <span class="comment"># Goal: length is 2n</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">2</span> * n:</span><br><span class="line">            result.append(<span class="string">&#x27;&#x27;</span>.join(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Choice 1: add &#x27;(&#x27; if possible</span></span><br><span class="line">        <span class="keyword">if</span> open_count &lt; n:</span><br><span class="line">            path.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            backtrack(path, open_count + <span class="number">1</span>, close_count)</span><br><span class="line">            path.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Choice 2: add &#x27;)&#x27; if valid (more opens than closes)</span></span><br><span class="line">        <span class="keyword">if</span> close_count &lt; open_count:</span><br><span class="line">            path.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            backtrack(path, open_count, close_count + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack([], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Alternative using string concatenation</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateParenthesis_string</span>(<span class="params">n</span>):</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">s, open_count, close_count</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">2</span> * n:</span><br><span class="line">            result.append(s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> open_count &lt; n:</span><br><span class="line">            backtrack(s + <span class="string">&#x27;(&#x27;</span>, open_count + <span class="number">1</span>, close_count)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> close_count &lt; open_count:</span><br><span class="line">            backtrack(s + <span class="string">&#x27;)&#x27;</span>, open_count, close_count + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Why this works</strong>: By ensuring
<code>close_count &lt; open_count</code> before adding <code>')'</code>,
we guarantee that every <code>')'</code> has a matching <code>'('</code>
to its left, making all generated strings valid.</p>
<p><strong>Complexity</strong>:</p>
<ul>
<li><strong>Time</strong>: <span class="math inline">\(O(\frac{4^n}{\sqrt{n}})\)</span> - Catalan number
<span class="math inline">\(C_n = \frac{1}{n+1}\binom{2n}{n} \approx
\frac{4^n}{n^{3/2}\sqrt{\pi}}\)</span></li>
<li><strong>Space</strong>: <span class="math inline">\(O(n)\)</span> -
Recursion depth</li>
</ul>
<hr>
<h1 id="pruning-optimization-techniques">Pruning Optimization
Techniques</h1>
<p>Pruning is crucial for making backtracking efficient. Here are common
techniques:</p>
<h2 id="early-termination">1. Early Termination</h2>
<p>Stop exploring when constraints are violated:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: Combination Sum</span></span><br><span class="line"><span class="keyword">if</span> current_sum &gt; target:</span><br><span class="line">    <span class="keyword">return</span>  <span class="comment"># Prune: can never reach target</span></span><br></pre></td></tr></table></figure>
<h2 id="constraint-propagation">2. Constraint Propagation</h2>
<p>Use constraints to reduce choices:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: N-Queens</span></span><br><span class="line"><span class="comment"># Only try columns not in used_cols</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span> col <span class="keyword">in</span> used_cols:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># Skip invalid columns</span></span><br></pre></td></tr></table></figure>
<h2 id="memoization-for-overlapping-subproblems">3. Memoization (for
overlapping subproblems)</h2>
<p>Cache results of subproblems:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: Word Break II (advanced)</span></span><br><span class="line">memo = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">s, wordDict</span>):</span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="keyword">return</span> memo[s]</span><br><span class="line">    <span class="comment"># ... backtrack logic</span></span><br><span class="line">    memo[s] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="sort-and-skip-duplicates">4. Sort and Skip Duplicates</h2>
<p>Sort input and skip duplicate choices:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: Combination Sum II (with duplicates)</span></span><br><span class="line">candidates.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">    <span class="comment"># Skip duplicates</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> candidates[i] == candidates[i-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<h2 id="bounds-checking">5. Bounds Checking</h2>
<p>Check if remaining choices can satisfy constraints:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: Subset Sum</span></span><br><span class="line">remaining_sum = <span class="built_in">sum</span>(nums[start:])</span><br><span class="line"><span class="keyword">if</span> current_sum + remaining_sum &lt; target:</span><br><span class="line">    <span class="keyword">return</span>  <span class="comment"># Prune: even using all remaining elements won&#x27;t reach target</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="complexity-analysis-2">Complexity Analysis</h1>
<p>Understanding backtracking complexity is crucial for interviews:</p>
<h2 id="time-complexity">Time Complexity</h2>
<p><strong>General formula</strong>: <span class="math inline">\(O(b^d
\times c)\)</span> where:</p>
<ul>
<li><span class="math inline">\(b\)</span> = branching factor (choices
per node)</li>
<li><span class="math inline">\(d\)</span> = depth of recursion</li>
<li><span class="math inline">\(c\)</span> = cost per solution (usually
copying)</li>
</ul>
<p><strong>Examples</strong>:</p>
<ul>
<li><strong>Permutations</strong>: <span class="math inline">\(O(n!
\times n)\)</span> - <span class="math inline">\(n!\)</span> leaves,
<span class="math inline">\(O(n)\)</span> to copy each</li>
<li><strong>Subsets</strong>: <span class="math inline">\(O(2^n \times
n)\)</span> - <span class="math inline">\(2^n\)</span> subsets, <span class="math inline">\(O(n)\)</span> to copy each</li>
<li><strong>N-Queens</strong>: <span class="math inline">\(O(n!)\)</span> - Pruned significantly from <span class="math inline">\(n^n\)</span></li>
<li><strong>Generate Parentheses</strong>: <span class="math inline">\(O(\frac{4^n}{\sqrt{n}})\)</span> - Catalan
number</li>
</ul>
<h2 id="space-complexity">Space Complexity</h2>
<p><strong>Components</strong>: 1. <strong>Recursion stack</strong>:
<span class="math inline">\(O(d)\)</span> where <span class="math inline">\(d\)</span> is depth 2. <strong>Path
storage</strong>: <span class="math inline">\(O(d)\)</span> for current
path 3. <strong>Auxiliary structures</strong>: <span class="math inline">\(O(n)\)</span> for tracking (used sets, arrays) 4.
<strong>Result storage</strong>: <span class="math inline">\(O(s \times
c)\)</span> where <span class="math inline">\(s\)</span> is number of
solutions, <span class="math inline">\(c\)</span> is size per
solution</p>
<p><strong>Total</strong>: Usually <span class="math inline">\(O(d +
n)\)</span> excluding result storage</p>
<hr>
<h1 id="common-pitfalls-and-debugging-tips">Common Pitfalls and
Debugging Tips</h1>
<h2 id="pitfall-1-not-copying-paths">Pitfall 1: Not Copying Paths</h2>
<p><strong>Wrong</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.append(path)  <span class="comment"># Adds reference, not copy!</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Correct</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.append(path[:])  <span class="comment"># or path.copy()</span></span><br></pre></td></tr></table></figure></p>
<h2 id="pitfall-2-forgetting-to-backtrack">Pitfall 2: Forgetting to
Backtrack</h2>
<p><strong>Wrong</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.append(choice)</span><br><span class="line">backtrack(path, choices)</span><br><span class="line"><span class="comment"># Missing: path.pop()</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Correct</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.append(choice)</span><br><span class="line">backtrack(path, choices)</span><br><span class="line">path.pop()  <span class="comment"># Always restore state!</span></span><br></pre></td></tr></table></figure></p>
<h2 id="pitfall-3-modifying-choices-incorrectly">Pitfall 3: Modifying
Choices Incorrectly</h2>
<p><strong>Wrong</strong> (for permutations): <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">choices.remove(choice)  <span class="comment"># Modifies original list</span></span><br><span class="line">backtrack(path, choices)</span><br><span class="line">choices.append(choice)  <span class="comment"># Hard to restore</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Correct</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">used[i] = <span class="literal">True</span></span><br><span class="line">backtrack(path, used)</span><br><span class="line">used[i] = <span class="literal">False</span>  <span class="comment"># Easy to restore</span></span><br></pre></td></tr></table></figure></p>
<h2 id="pitfall-4-wrong-constraint-checking-order">Pitfall 4: Wrong
Constraint Checking Order</h2>
<p>Always check constraints <strong>before</strong> making the
choice:</p>
<p><strong>Wrong</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.append(choice)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> is_valid(path):  <span class="comment"># Too late!</span></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Correct</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> is_valid(choice, path):</span><br><span class="line">    <span class="keyword">continue</span>  <span class="comment"># Skip before adding</span></span><br><span class="line">path.append(choice)</span><br></pre></td></tr></table></figure></p>
<h2 id="debugging-checklist">Debugging Checklist</h2>
<ol type="1">
<li>‚úÖ Are you copying paths when saving solutions?</li>
<li>‚úÖ Are you restoring state after recursion?</li>
<li>‚úÖ Are constraints checked before making choices?</li>
<li>‚úÖ Are you pruning invalid paths early?</li>
<li>‚úÖ Is the base case correct?</li>
<li>‚úÖ Are choices being updated correctly for next level?</li>
</ol>
<hr>
<h1 id="qa-10-frequently-asked-questions">Q&amp;A: 10 Frequently Asked
Questions</h1>
<h2 id="q1-when-should-i-use-backtracking-vs-dynamic-programming">Q1:
When should I use backtracking vs dynamic programming?</h2>
<p><strong>A</strong>: Use <strong>backtracking</strong> when:</p>
<ul>
<li>You need <strong>all solutions</strong> (not just
count/optimal)</li>
<li>Problem has <strong>exponential search space</strong> that can be
pruned</li>
<li>Constraints can be checked <strong>incrementally</strong></li>
</ul>
<p>Use <strong>dynamic programming</strong> when:</p>
<ul>
<li>You need <strong>count or optimal value</strong> (not all
solutions)</li>
<li>Problem has <strong>overlapping subproblems</strong></li>
<li>Optimal substructure exists</li>
</ul>
<p><strong>Example</strong>:</p>
<ul>
<li><strong>All paths</strong> ‚Üí Backtracking</li>
<li><strong>Number of paths</strong> ‚Üí DP</li>
<li><strong>Shortest path</strong> ‚Üí DP or BFS</li>
</ul>
<h2 id="q2-how-do-i-avoid-duplicate-solutions">Q2: How do I avoid
duplicate solutions?</h2>
<p><strong>A</strong>: Common strategies:</p>
<ol type="1">
<li><p><strong>Sort input and skip duplicates</strong>:
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">    <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Use start index</strong> (for combinations):
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Only consider elements from start onward</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">    backtrack(path, i + <span class="number">1</span>)  <span class="comment"># Next start is i+1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Track used elements</strong> (for permutations):
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">used = [<span class="literal">False</span>] * n</span><br><span class="line"><span class="keyword">if</span> used[i]:</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="q3-why-is-my-solution-too-slow">Q3: Why is my solution too
slow?</h2>
<p><strong>A</strong>: Check these:</p>
<ol type="1">
<li><strong>Not pruning early</strong>: Add constraint checks before
recursion</li>
<li><strong>Copying unnecessarily</strong>: Only copy when saving final
solutions</li>
<li><strong>Inefficient data structures</strong>: Use sets/arrays
instead of lists for lookups</li>
<li><strong>Redundant work</strong>: Memoize if subproblems overlap</li>
</ol>
<p><strong>Example optimization</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Slow: checking in O(n) list</span></span><br><span class="line"><span class="keyword">if</span> choice <span class="keyword">in</span> path:  <span class="comment"># O(n) lookup</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fast: checking in O(1) set</span></span><br><span class="line"><span class="keyword">if</span> choice <span class="keyword">in</span> used_set:  <span class="comment"># O(1) lookup</span></span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure></p>
<h2 id="q4-can-i-use-iteration-instead-of-recursion">Q4: Can I use
iteration instead of recursion?</h2>
<p><strong>A</strong>: Yes, but recursion is usually cleaner for
backtracking. Iterative approach uses an explicit stack:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">iterative_backtrack</span>():</span><br><span class="line">    stack = [([], initial_state)]</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        path, state = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> is_goal(path):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> choice <span class="keyword">in</span> get_choices(state):</span><br><span class="line">            <span class="keyword">if</span> is_valid(choice, path):</span><br><span class="line">                new_path = path + [choice]</span><br><span class="line">                new_state = update_state(state, choice)</span><br><span class="line">                stack.append((new_path, new_state))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Trade-off</strong>: Iteration avoids stack overflow but is
more verbose.</p>
<h2 id="q5-how-do-i-handle-problems-with-multiple-constraints">Q5: How
do I handle problems with multiple constraints?</h2>
<p><strong>A</strong>: Track all constraints separately and check them
all:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: N-Queens</span></span><br><span class="line">used_cols = <span class="built_in">set</span>()</span><br><span class="line">used_diag1 = <span class="built_in">set</span>()</span><br><span class="line">used_diag2 = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_valid</span>(<span class="params">row, col</span>):</span><br><span class="line">    <span class="keyword">return</span> (col <span class="keyword">not</span> <span class="keyword">in</span> used_cols <span class="keyword">and</span> </span><br><span class="line">            (row - col) <span class="keyword">not</span> <span class="keyword">in</span> used_diag1 <span class="keyword">and</span></span><br><span class="line">            (row + col) <span class="keyword">not</span> <span class="keyword">in</span> used_diag2)</span><br></pre></td></tr></table></figure>
<h2 id="q6-whats-the-difference-between-permutations-and-combinations">Q6:
What's the difference between permutations and combinations?</h2>
<p><strong>A</strong>:</p>
<ul>
<li><strong>Permutations</strong>: Order matters. <code>[1,2]</code> ‚â†
<code>[2,1]</code></li>
<li><strong>Combinations</strong>: Order doesn't matter.
<code>[1,2]</code> = <code>[2,1]</code></li>
</ul>
<p><strong>Implementation difference</strong>:</p>
<ul>
<li><strong>Permutations</strong>: Can choose any unused element</li>
<li><strong>Combinations</strong>: Use <code>start</code> index, only
consider <code>nums[start:]</code></li>
</ul>
<h2 id="q7-how-do-i-optimize-for-find-one-solution-vs-find-all-solutions">Q7:
How do I optimize for "find one solution" vs "find all solutions"?</h2>
<p><strong>A</strong>: Return early when first solution found:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_one_solution</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">        <span class="keyword">if</span> is_goal(path):</span><br><span class="line">            <span class="keyword">return</span> path[:]  <span class="comment"># Return immediately</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_valid(choice, path):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(choice)</span><br><span class="line">            result = backtrack(path, updated_choices)</span><br><span class="line">            <span class="keyword">if</span> result:  <span class="comment"># Found solution</span></span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h2 id="q8-can-backtracking-solve-optimization-problems">Q8: Can
backtracking solve optimization problems?</h2>
<p><strong>A</strong>: Yes, but usually DP is better. For
backtracking:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">best_solution = <span class="literal">None</span></span><br><span class="line">best_value = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">    <span class="keyword">if</span> is_goal(path):</span><br><span class="line">        value = evaluate(path)</span><br><span class="line">        <span class="keyword">if</span> value &lt; best_value:</span><br><span class="line">            best_value = value</span><br><span class="line">            best_solution = path[:]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ... explore choices</span></span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: This explores all solutions. Use DP if you
only need optimal value.</p>
<h2 id="q9-how-do-i-handle-problems-with-variable-length-solutions">Q9:
How do I handle problems with variable-length solutions?</h2>
<p><strong>A</strong>: Save solutions at multiple points, not just at
base case:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: Subsets - save at every step</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, start</span>):</span><br><span class="line">    result.append(path[:])  <span class="comment"># Save current subset</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">        path.append(nums[i])</span><br><span class="line">        backtrack(path, i + <span class="number">1</span>)</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>
<h2 id="q10-whats-the-best-way-to-practice-backtracking">Q10: What's the
best way to practice backtracking?</h2>
<p><strong>A</strong>: 1. <strong>Start with template</strong>: Memorize
the universal template 2. <strong>Solve classic problems</strong>:
Permutations, combinations, subsets, N-Queens 3. <strong>Identify
patterns</strong>: Notice similarities across problems 4. <strong>Focus
on constraints</strong>: Practice identifying and checking constraints
5. <strong>Optimize gradually</strong>: First get it working, then add
pruning</p>
<p><strong>Recommended progression</strong>: 1. Permutations (basic) 2.
Subsets (binary choices) 3. Combination Sum (reuse + constraints) 4.
N-Queens (multiple constraints) 5. Generate Parentheses (custom
constraints) 6. Word Break II (advanced, with memoization)</p>
<hr>
<h1 id="summary">Summary</h1>
<p>Backtracking is a powerful paradigm for solving constraint
satisfaction problems. Here are the key takeaways:</p>
<h2 id="core-concepts">Core Concepts</h2>
<ol type="1">
<li><strong>Framework</strong>: Make choice ‚Üí Recurse ‚Üí Backtrack (undo
choice)</li>
<li><strong>Three elements</strong>: Choices, Constraints, Goal</li>
<li><strong>Relationship with DFS</strong>: Backtracking uses DFS but
modifies and restores state</li>
</ol>
<h2 id="template-pattern">Template Pattern</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">    <span class="keyword">if</span> is_goal(path):</span><br><span class="line">        result.append(path[:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_valid(choice, path):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        path.append(choice)</span><br><span class="line">        backtrack(path, update_choices(choices, choice))</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>
<h2 id="key-techniques">Key Techniques</h2>
<ol type="1">
<li><strong>Early pruning</strong>: Check constraints before
recursing</li>
<li><strong>State management</strong>: Always restore state after
recursion</li>
<li><strong>Avoid duplicates</strong>: Sort and skip, or use start
index</li>
<li><strong>Efficient tracking</strong>: Use sets/arrays for O(1)
lookups</li>
</ol>
<h2 id="problem-patterns">Problem Patterns</h2>
<ul>
<li><strong>Permutations</strong>: Track used elements</li>
<li><strong>Combinations</strong>: Use start index to avoid
duplicates</li>
<li><strong>Subsets</strong>: Save at every step</li>
<li><strong>Constraint satisfaction</strong>: Track all constraints
separately</li>
<li><strong>String generation</strong>: Track counts (like
parentheses)</li>
</ul>
<h2 id="complexity">Complexity</h2>
<ul>
<li><strong>Time</strong>: Usually exponential (<span class="math inline">\(O(2^n)\)</span> or <span class="math inline">\(O(n!)\)</span>) but pruned significantly</li>
<li><strong>Space</strong>: <span class="math inline">\(O(d)\)</span>
recursion depth + <span class="math inline">\(O(n)\)</span> auxiliary
structures</li>
</ul>
<h2 id="best-practices">Best Practices</h2>
<ol type="1">
<li>‚úÖ Copy paths when saving: <code>result.append(path[:])</code></li>
<li>‚úÖ Always backtrack: <code>path.pop()</code> after recursion</li>
<li>‚úÖ Check constraints early: Before making choice</li>
<li>‚úÖ Use efficient data structures: Sets for membership, arrays for
tracking</li>
<li>‚úÖ Prune aggressively: Skip invalid paths immediately</li>
</ol>
<p>Master backtracking by practicing the classic problems, internalizing
the template, and learning to identify when backtracking is the right
approach. With these tools, you'll be able to tackle a wide range of
LeetCode problems efficiently!</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>Post titleÔºöLeetCode (8): Backtracking Algorithm</li>
        <li>Post authorÔºöChen Kai</li>
        <li>Create timeÔºö2023-07-28 00:00:00</li>
        <li>
            Post linkÔºöhttps://www.chenk.top/en/leetcode-backtracking/
        </li>
        <li>
            Copyright NoticeÔºöAll articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/en/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/en/tags/Algorithms/">#Algorithms</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/en/tags/Backtracking/">#Backtracking</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/leetcode-9-greedy-algorithms/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode (9) ‚Äî Greedy Algorithms</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/en/leetcode-two-pointers/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode (2): Two Pointers - Collision, Fast-Slow &amp; Sliding Window Complete Guide</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: 'üòú Â∞ΩÊÉÖËµûÁæéÂ∏ÖÊ∞î‰ºüÂ§ßÁöÑckÂêß~',
                    lang: 'en'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return 'Âçö‰∏ª';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#series-navigation"><span class="nav-number">1.</span> <span class="nav-text">Series Navigation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#what-is-backtracking"><span class="nav-number">2.</span> <span class="nav-text">What is Backtracking?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#backtracking-vs-dfs-understanding-the-relationship"><span class="nav-number">3.</span> <span class="nav-text">Backtracking
vs DFS: Understanding the Relationship</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dfs-depth-first-search"><span class="nav-number">3.1.</span> <span class="nav-text">DFS (Depth-First Search)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#backtracking"><span class="nav-number">3.2.</span> <span class="nav-text">Backtracking</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#the-three-essential-elements-of-backtracking"><span class="nav-number">4.</span> <span class="nav-text">The Three
Essential Elements of Backtracking</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#choices-what-decisions-can-we-make"><span class="nav-number">4.1.</span> <span class="nav-text">1. Choices (What decisions
can we make?)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constraints-what-makes-a-choice-valid"><span class="nav-number">4.2.</span> <span class="nav-text">2. Constraints (What
makes a choice valid?)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#goal-when-have-we-found-a-solution"><span class="nav-number">4.3.</span> <span class="nav-text">3. Goal (When have we found
a solution?)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#universal-backtracking-template"><span class="nav-number">5.</span> <span class="nav-text">Universal Backtracking
Template</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#problem-1-permutations"><span class="nav-number">6.</span> <span class="nav-text">Problem 1: Permutations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-statement"><span class="nav-number">6.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-analysis"><span class="nav-number">6.2.</span> <span class="nav-text">Problem Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solution-approach"><span class="nav-number">6.3.</span> <span class="nav-text">Solution Approach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#complexity-analysis"><span class="nav-number">6.4.</span> <span class="nav-text">Complexity Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solution"><span class="nav-number">6.5.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#problem-2-combination-sum"><span class="nav-number">7.</span> <span class="nav-text">Problem 2: Combination Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-statement-1"><span class="nav-number">7.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-analysis-1"><span class="nav-number">7.2.</span> <span class="nav-text">Problem Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solution-approach-1"><span class="nav-number">7.3.</span> <span class="nav-text">Solution Approach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#complexity-analysis-1"><span class="nav-number">7.4.</span> <span class="nav-text">Complexity Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solution-1"><span class="nav-number">7.5.</span> <span class="nav-text">Solution</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pitfall-1-starting-from-0-causes-duplicates"><span class="nav-number">7.5.1.</span> <span class="nav-text">Pitfall 1: Starting
from 0 causes duplicates</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pitfall-2-using-i1-prevents-reuse"><span class="nav-number">7.5.2.</span> <span class="nav-text">Pitfall 2: Using
i+1 prevents reuse</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#problem-3-subsets"><span class="nav-number">8.</span> <span class="nav-text">Problem 3: Subsets</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-statement-2"><span class="nav-number">8.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#analysis"><span class="nav-number">8.2.</span> <span class="nav-text">Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solution-2"><span class="nav-number">8.3.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#problem-4-n-queens"><span class="nav-number">9.</span> <span class="nav-text">Problem 4: N-Queens</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-statement-3"><span class="nav-number">9.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#analysis-1"><span class="nav-number">9.2.</span> <span class="nav-text">Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solution-3"><span class="nav-number">9.3.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#problem-5-generate-parentheses"><span class="nav-number">10.</span> <span class="nav-text">Problem 5: Generate
Parentheses</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-statement-4"><span class="nav-number">10.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#analysis-2"><span class="nav-number">10.2.</span> <span class="nav-text">Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solution-4"><span class="nav-number">10.3.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pruning-optimization-techniques"><span class="nav-number">11.</span> <span class="nav-text">Pruning Optimization
Techniques</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#early-termination"><span class="nav-number">11.1.</span> <span class="nav-text">1. Early Termination</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constraint-propagation"><span class="nav-number">11.2.</span> <span class="nav-text">2. Constraint Propagation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memoization-for-overlapping-subproblems"><span class="nav-number">11.3.</span> <span class="nav-text">3. Memoization (for
overlapping subproblems)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sort-and-skip-duplicates"><span class="nav-number">11.4.</span> <span class="nav-text">4. Sort and Skip Duplicates</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bounds-checking"><span class="nav-number">11.5.</span> <span class="nav-text">5. Bounds Checking</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#complexity-analysis-2"><span class="nav-number">12.</span> <span class="nav-text">Complexity Analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#time-complexity"><span class="nav-number">12.1.</span> <span class="nav-text">Time Complexity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#space-complexity"><span class="nav-number">12.2.</span> <span class="nav-text">Space Complexity</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#common-pitfalls-and-debugging-tips"><span class="nav-number">13.</span> <span class="nav-text">Common Pitfalls and
Debugging Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pitfall-1-not-copying-paths"><span class="nav-number">13.1.</span> <span class="nav-text">Pitfall 1: Not Copying Paths</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pitfall-2-forgetting-to-backtrack"><span class="nav-number">13.2.</span> <span class="nav-text">Pitfall 2: Forgetting to
Backtrack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pitfall-3-modifying-choices-incorrectly"><span class="nav-number">13.3.</span> <span class="nav-text">Pitfall 3: Modifying
Choices Incorrectly</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pitfall-4-wrong-constraint-checking-order"><span class="nav-number">13.4.</span> <span class="nav-text">Pitfall 4: Wrong
Constraint Checking Order</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#debugging-checklist"><span class="nav-number">13.5.</span> <span class="nav-text">Debugging Checklist</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#qa-10-frequently-asked-questions"><span class="nav-number">14.</span> <span class="nav-text">Q&amp;A: 10 Frequently Asked
Questions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#q1-when-should-i-use-backtracking-vs-dynamic-programming"><span class="nav-number">14.1.</span> <span class="nav-text">Q1:
When should I use backtracking vs dynamic programming?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#q2-how-do-i-avoid-duplicate-solutions"><span class="nav-number">14.2.</span> <span class="nav-text">Q2: How do I avoid
duplicate solutions?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#q3-why-is-my-solution-too-slow"><span class="nav-number">14.3.</span> <span class="nav-text">Q3: Why is my solution too
slow?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#q4-can-i-use-iteration-instead-of-recursion"><span class="nav-number">14.4.</span> <span class="nav-text">Q4: Can I use
iteration instead of recursion?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#q5-how-do-i-handle-problems-with-multiple-constraints"><span class="nav-number">14.5.</span> <span class="nav-text">Q5: How
do I handle problems with multiple constraints?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#q6-whats-the-difference-between-permutations-and-combinations"><span class="nav-number">14.6.</span> <span class="nav-text">Q6:
What&#39;s the difference between permutations and combinations?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#q7-how-do-i-optimize-for-find-one-solution-vs-find-all-solutions"><span class="nav-number">14.7.</span> <span class="nav-text">Q7:
How do I optimize for &quot;find one solution&quot; vs &quot;find all solutions&quot;?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#q8-can-backtracking-solve-optimization-problems"><span class="nav-number">14.8.</span> <span class="nav-text">Q8: Can
backtracking solve optimization problems?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#q9-how-do-i-handle-problems-with-variable-length-solutions"><span class="nav-number">14.9.</span> <span class="nav-text">Q9:
How do I handle problems with variable-length solutions?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#q10-whats-the-best-way-to-practice-backtracking"><span class="nav-number">14.10.</span> <span class="nav-text">Q10: What&#39;s the
best way to practice backtracking?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#summary"><span class="nav-number">15.</span> <span class="nav-text">Summary</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#core-concepts"><span class="nav-number">15.1.</span> <span class="nav-text">Core Concepts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#template-pattern"><span class="nav-number">15.2.</span> <span class="nav-text">Template Pattern</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#key-techniques"><span class="nav-number">15.3.</span> <span class="nav-text">Key Techniques</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-patterns"><span class="nav-number">15.4.</span> <span class="nav-text">Problem Patterns</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#complexity"><span class="nav-number">15.5.</span> <span class="nav-text">Complexity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#best-practices"><span class="nav-number">15.6.</span> <span class="nav-text">Best Practices</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
