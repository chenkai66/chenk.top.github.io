<!DOCTYPE html>



<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode (6): Binary Tree Traversal &amp; Construction |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"en","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/en/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode (6): Binary Tree Traversal &amp; Construction</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-06-20 00:00:00</span>
        <span class="mobile">2023-06-20 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/en/tags/Algorithms/">Algorithms</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/en/tags/Binary-Tree/">Binary Tree</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>4.5k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>28 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>Binary trees are a cornerstone of algorithm interviews, appearing in
problems ranging from basic traversal to complex construction
challenges. Mastering binary tree techniques is essential for
demonstrating algorithmic proficiency. This comprehensive guide
systematically covers four traversal methods (preorder, inorder,
postorder, level-order), explores both recursive and iterative
implementations, and solves classic construction problems (building
trees from preorder+inorder and postorder+inorder). We'll also analyze
complexity, common pitfalls, optimization techniques, and variant
extensions.</p>
<span id="more"></span>
<h1 id="series-navigation">Series Navigation</h1>
<p>üìö <strong>LeetCode Algorithm Masterclass Series</strong> (10
Parts):</p>
<ol type="1">
<li>Hash Tables (Two Sum, Longest Consecutive, Group Anagrams)</li>
<li>Two Pointers Techniques (Collision pointers, fast-slow, sliding
window)</li>
<li>Linked List Operations (Reverse, cycle detection, merge)</li>
<li>Binary Tree Traversal &amp; Recursion (Inorder/Preorder/Postorder,
LCA)</li>
<li><strong>‚Üí Binary Tree Traversal &amp; Construction</strong>
(Pre/In/Post/Level-order, Construction) ‚Üê <em>You are here</em></li>
<li>Backtracking Algorithms (Permutations, combinations, pruning)</li>
<li>Dynamic Programming Intro (1D/2D DP, state transition)</li>
<li>Greedy Algorithms (Interval scheduling, jump game)</li>
<li>Graph Algorithms (BFS/DFS, topological sort, union-find)</li>
<li>Bit Manipulation &amp; Math (Bitwise tricks, math problems)</li>
</ol>
<hr>
<h1 id="binary-tree-fundamentals">Binary Tree Fundamentals</h1>
<h2 id="what-is-a-binary-tree">What is a Binary Tree?</h2>
<p>A <strong>binary tree</strong> is a tree data structure where each
node has at most two children, typically referred to as the "left child"
and "right child".</p>
<p><strong>Key Properties</strong>:</p>
<ul>
<li>Each node has <strong>at most two children</strong></li>
<li><strong>Left and right subtrees are ordered</strong> (cannot be
swapped arbitrarily)</li>
<li>An empty tree is also a binary tree</li>
</ul>
<p><strong>Basic Structure</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>
<h2 id="types-of-binary-trees">Types of Binary Trees</h2>
<p><strong>Complete Binary Tree</strong>: All levels are completely
filled except possibly the last level, which is filled from left to
right.</p>
<p><strong>Full Binary Tree</strong>: Every node has either 0 or 2
children.</p>
<p><strong>Binary Search Tree (BST)</strong>: For each node, all values
in the left subtree &lt; node value &lt; all values in the right
subtree.</p>
<p><strong>Balanced Binary Tree</strong>: The height difference between
left and right subtrees is at most 1.</p>
<hr>
<h1 id="problem-1-binary-tree-preorder-traversal">Problem 1: Binary Tree
Preorder Traversal</h1>
<h2 id="problem-statement">Problem Statement</h2>
<p>Given the <code>root</code> of a binary tree, return the
<strong>preorder traversal</strong> of its nodes' values.</p>
<p><strong>Preorder Order</strong>: Root ‚Üí Left subtree ‚Üí Right
subtree</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>root = [1,null,2,3]</code></li>
<li>Output: <code>[1,2,3]</code></li>
</ul>
<p><strong>Constraints</strong>:</p>
<ul>
<li>The number of nodes in the tree is in the range
<code>[0, 100]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="problem-analysis">Problem Analysis</h2>
<p>Preorder traversal follows the pattern: <strong>visit the root first,
then recursively process the left subtree, and finally the right
subtree</strong>. This is the most intuitive traversal because you
always see the root value first.</p>
<p><strong>Use Cases</strong>:</p>
<ul>
<li>Printing directory structures (print current directory, then
subdirectories)</li>
<li>Copying binary trees (create root first, then copy subtrees)</li>
<li>Expression tree evaluation (process operator before operands)</li>
</ul>
<h2 id="solution-approach">Solution Approach</h2>
<p><strong>Recursive Approach</strong>: Directly implement the
definition‚Äîvisit root, recurse left, recurse right.</p>
<p><strong>Iterative Approach</strong>: Use a stack to simulate
recursion. Push root onto stack, then loop: pop and visit, push right
child first, then left child (order matters because stack is LIFO).</p>
<h2 id="complexity-analysis">Complexity Analysis</h2>
<ul>
<li><strong>Time Complexity</strong>: <span class="math inline">\(O(n)\)</span>, visiting each node once</li>
<li><strong>Space Complexity</strong>:
<ul>
<li>Recursive: <span class="math inline">\(O(h)\)</span>, where <span class="math inline">\(h\)</span> is tree height (recursion stack
depth)</li>
<li>Iterative: <span class="math inline">\(O(h)\)</span>, maximum stack
depth equals tree height</li>
</ul></li>
</ul>
<h2 id="recursive-implementation">Recursive Implementation</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Preorder traversal: Root -&gt; Left -&gt; Right</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Algorithm Steps:</span></span><br><span class="line"><span class="string">        1. If root is None, return empty list</span></span><br><span class="line"><span class="string">        2. Visit root node (add to result)</span></span><br><span class="line"><span class="string">        3. Recursively traverse left subtree</span></span><br><span class="line"><span class="string">        4. Recursively traverse right subtree</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Boundary Conditions:</span></span><br><span class="line"><span class="string">        - Empty tree: return []</span></span><br><span class="line"><span class="string">        - Single node: return [val]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Variable Meanings:</span></span><br><span class="line"><span class="string">        - root: root of current subtree</span></span><br><span class="line"><span class="string">        - result: list storing traversal results</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="comment"># Boundary: empty node returns immediately</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Step 1: Visit root node</span></span><br><span class="line">            result.append(node.val)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Step 2: Recursively traverse left subtree</span></span><br><span class="line">            preorder(node.left)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Step 3: Recursively traverse right subtree</span></span><br><span class="line">            preorder(node.right)</span><br><span class="line">        </span><br><span class="line">        preorder(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Algorithm Principle</strong>:</p>
<p>Preorder traversal follows "root-left-right" order. The recursive
implementation leverages the function call stack‚Äîafter finishing the
left subtree, execution automatically returns to the previous level to
process the right subtree.</p>
<p><strong>Execution Example</strong> (tree
<code>[1, null, 2, 3]</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Visit node 1 -&gt; result = [1]</span><br><span class="line">  Recurse left subtree (null) -&gt; return immediately</span><br><span class="line">  Recurse right subtree (node 2)</span><br><span class="line">    Visit node 2 -&gt; result = [1, 2]</span><br><span class="line">      Recurse left subtree (node 3)</span><br><span class="line">        Visit node 3 -&gt; result = [1, 2, 3]</span><br><span class="line">          Recurse left subtree (null)</span><br><span class="line">          Recurse right subtree (null)</span><br><span class="line">      Recurse right subtree (null)</span><br></pre></td></tr></table></figure>
<h2 id="iterative-implementation">Iterative Implementation</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Iterative implementation: Use stack to simulate recursion</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Algorithm Steps:</span></span><br><span class="line"><span class="string">    1. Initialize stack, push root</span></span><br><span class="line"><span class="string">    2. While stack is not empty:</span></span><br><span class="line"><span class="string">       a. Pop top node and visit</span></span><br><span class="line"><span class="string">       b. If right child exists, push it</span></span><br><span class="line"><span class="string">       c. If left child exists, push it</span></span><br><span class="line"><span class="string">    3. Return result</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Key Technique:</span></span><br><span class="line"><span class="string">    - Push right child first, then left child (stack is LIFO)</span></span><br><span class="line"><span class="string">    - This ensures &quot;root-left-right&quot; order when popping</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Boundary Conditions:</span></span><br><span class="line"><span class="string">    - Empty tree: stack empty, return []</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    stack = [root]  <span class="comment"># Initialize stack</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        <span class="comment"># Pop top node</span></span><br><span class="line">        node = stack.pop()</span><br><span class="line">        result.append(node.val)  <span class="comment"># Visit root node</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Push right first, then left</span></span><br><span class="line">        <span class="comment"># Popping order: left -&gt; right (matches preorder)</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Why Push Right Before Left</strong>:</p>
<p>Stacks are Last-In-First-Out (LIFO). To visit the left subtree first,
we need the left child to be pushed last, so it pops first.</p>
<p><strong>Execution Example</strong> (tree
<code>[1, null, 2, 3]</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Initial: stack = [1], result = []</span><br><span class="line">Iteration 1: Pop 1 -&gt; result = [1]</span><br><span class="line">             Push 2 (right) -&gt; stack = [2]</span><br><span class="line">             Push null (left, skip)</span><br><span class="line">Iteration 2: Pop 2 -&gt; result = [1, 2]</span><br><span class="line">             Push null (right, skip)</span><br><span class="line">             Push 3 (left) -&gt; stack = [3]</span><br><span class="line">Iteration 3: Pop 3 -&gt; result = [1, 2, 3]</span><br><span class="line">             Push null (right, skip)</span><br><span class="line">             Push null (left, skip)</span><br><span class="line">Iteration 4: stack empty, end</span><br></pre></td></tr></table></figure>
<h2 id="common-pitfalls">Common Pitfalls</h2>
<h3 id="pitfall-1-forgetting-to-handle-null-nodes">Pitfall 1: Forgetting
to Handle Null Nodes</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ‚ùå Wrong</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">node</span>):</span><br><span class="line">    result.append(node.val)  <span class="comment"># Error if node is None</span></span><br><span class="line">    preorder(node.left)</span><br><span class="line">    preorder(node.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ‚úÖ Correct</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    result.append(node.val)</span><br><span class="line">    preorder(node.left)</span><br><span class="line">    preorder(node.right)</span><br></pre></td></tr></table></figure>
<h3 id="pitfall-2-wrong-push-order-in-iterative-implementation">Pitfall
2: Wrong Push Order in Iterative Implementation</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ‚ùå Wrong: Push left then right</span></span><br><span class="line"><span class="keyword">if</span> node.left:</span><br><span class="line">    stack.append(node.left)</span><br><span class="line"><span class="keyword">if</span> node.right:</span><br><span class="line">    stack.append(node.right)</span><br><span class="line"><span class="comment"># This visits right subtree first, order becomes &quot;root-right-left&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ‚úÖ Correct: Push right then left</span></span><br><span class="line"><span class="keyword">if</span> node.right:</span><br><span class="line">    stack.append(node.right)</span><br><span class="line"><span class="keyword">if</span> node.left:</span><br><span class="line">    stack.append(node.left)</span><br></pre></td></tr></table></figure>
<h2 id="variant-extension">Variant Extension</h2>
<h3 id="variant-1-morris-preorder-traversal-o1-space">Variant 1: Morris
Preorder Traversal (<span class="math inline">\(O(1)\)</span>
Space)</h3>
<p>Morris traversal uses null pointers in the tree to achieve <span class="math inline">\(O(1)\)</span> space complexity:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorderTraversal_morris</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Morris preorder traversal: O(1) space complexity</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Core Idea: Use null pointers of leaf nodes to create temporary links</span></span><br><span class="line"><span class="string">    After visiting left subtree, return to root via this link</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    current = root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> current:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> current.left:</span><br><span class="line">            <span class="comment"># No left subtree, visit current node directly</span></span><br><span class="line">            result.append(current.val)</span><br><span class="line">            current = current.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Find rightmost node in left subtree (predecessor)</span></span><br><span class="line">            predecessor = current.left</span><br><span class="line">            <span class="keyword">while</span> predecessor.right <span class="keyword">and</span> predecessor.right != current:</span><br><span class="line">                predecessor = predecessor.right</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> predecessor.right:</span><br><span class="line">                <span class="comment"># Create temporary link</span></span><br><span class="line">                result.append(current.val)  <span class="comment"># Visit root</span></span><br><span class="line">                predecessor.right = current</span><br><span class="line">                current = current.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Temporary link exists, left subtree already visited</span></span><br><span class="line">                predecessor.right = <span class="literal">None</span>  <span class="comment"># Restore tree structure</span></span><br><span class="line">                current = current.right</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Complexity Analysis</strong>:</p>
<ul>
<li><strong>Time Complexity</strong>: <span class="math inline">\(O(n)\)</span>, each node visited at most
twice</li>
<li><strong>Space Complexity</strong>: <span class="math inline">\(O(1)\)</span>, only constant extra space</li>
</ul>
<hr>
<h1 id="problem-2-binary-tree-inorder-traversal">Problem 2: Binary Tree
Inorder Traversal</h1>
<h2 id="problem-statement-1">Problem Statement</h2>
<p>Given the <code>root</code> of a binary tree, return the
<strong>inorder traversal</strong> of its nodes' values.</p>
<p><strong>Inorder Order</strong>: Left subtree ‚Üí Root ‚Üí Right
subtree</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>root = [1,null,2,3]</code></li>
<li>Output: <code>[1,3,2]</code></li>
</ul>
<h2 id="problem-analysis-1">Problem Analysis</h2>
<p>Inorder traversal processes <strong>left subtree first, then root,
then right subtree</strong>. For Binary Search Trees (BST), inorder
traversal produces a sorted sequence.</p>
<p><strong>Use Cases</strong>:</p>
<ul>
<li><strong>BST sorted output</strong>: Inorder traversal of BST gives
ascending order</li>
<li><strong>Expression tree evaluation</strong>: Inorder traversal of
expression tree gives infix expression</li>
<li><strong>BST validation</strong>: Check if inorder result is
sorted</li>
</ul>
<h2 id="solution-approach-1">Solution Approach</h2>
<p><strong>Recursive Approach</strong>: Recurse left, visit root,
recurse right.</p>
<p><strong>Iterative Approach</strong>: Use stack to simulate recursion.
Start from root, go left all the way, pushing nodes onto stack. Then pop
and visit, turn to right subtree, repeat.</p>
<h2 id="complexity-analysis-1">Complexity Analysis</h2>
<ul>
<li><strong>Time Complexity</strong>: <span class="math inline">\(O(n)\)</span></li>
<li><strong>Space Complexity</strong>: <span class="math inline">\(O(h)\)</span>, where <span class="math inline">\(h\)</span> is tree height</li>
</ul>
<h2 id="recursive-implementation-1">Recursive Implementation</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Inorder traversal: Left -&gt; Root -&gt; Right</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Algorithm Steps:</span></span><br><span class="line"><span class="string">    1. Recursively traverse left subtree</span></span><br><span class="line"><span class="string">    2. Visit root node</span></span><br><span class="line"><span class="string">    3. Recursively traverse right subtree</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        inorder(node.left)      <span class="comment"># Process left subtree first</span></span><br><span class="line">        result.append(node.val)  <span class="comment"># Then visit root</span></span><br><span class="line">        inorder(node.right)     <span class="comment"># Finally process right subtree</span></span><br><span class="line">    </span><br><span class="line">    inorder(root)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="iterative-implementation-1">Iterative Implementation</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Iterative implementation: Use stack to simulate recursion</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Algorithm Steps:</span></span><br><span class="line"><span class="string">    1. Start from root, go left all the way, push nodes onto stack</span></span><br><span class="line"><span class="string">    2. Pop top node and visit</span></span><br><span class="line"><span class="string">    3. Turn to right subtree, repeat step 1</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Key Technique:</span></span><br><span class="line"><span class="string">    - Use current pointer to track current node</span></span><br><span class="line"><span class="string">    - When current is None and stack is empty, traversal ends</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    stack = []</span><br><span class="line">    current = root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="comment"># Go left all the way</span></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            stack.append(current)</span><br><span class="line">            current = current.left</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Pop top node (leftmost node)</span></span><br><span class="line">        current = stack.pop()</span><br><span class="line">        result.append(current.val)  <span class="comment"># Visit node</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Turn to right subtree</span></span><br><span class="line">        current = current.right</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Execution Example</strong> (tree
<code>[1, null, 2, 3]</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Initial: current = 1, stack = [], result = []</span><br><span class="line">Iteration 1: current = 1, go left all the way</span><br><span class="line">             Push 1 -&gt; stack = [1]</span><br><span class="line">             current = null</span><br><span class="line">             Pop 1 -&gt; result = [1]</span><br><span class="line">             current = 2 (right child of 1)</span><br><span class="line">Iteration 2: current = 2, go left all the way</span><br><span class="line">             Push 2 -&gt; stack = [2]</span><br><span class="line">             current = 3 (left child of 2)</span><br><span class="line">             Push 3 -&gt; stack = [2, 3]</span><br><span class="line">             current = null</span><br><span class="line">             Pop 3 -&gt; result = [1, 3]</span><br><span class="line">             current = null (right child of 3)</span><br><span class="line">             Pop 2 -&gt; result = [1, 3, 2]</span><br><span class="line">             current = null (right child of 2)</span><br><span class="line">Iteration 3: current = null, stack = [], end</span><br></pre></td></tr></table></figure>
<h2 id="common-pitfall">Common Pitfall</h2>
<h3 id="pitfall-forgetting-to-turn-to-right-subtree">Pitfall: Forgetting
to Turn to Right Subtree</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ‚ùå Wrong</span></span><br><span class="line"><span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">    <span class="keyword">while</span> current:</span><br><span class="line">        stack.append(current)</span><br><span class="line">        current = current.left</span><br><span class="line">    current = stack.pop()</span><br><span class="line">    result.append(current.val)</span><br><span class="line">    <span class="comment"># Missing: current = current.right</span></span><br><span class="line">    <span class="comment"># Causes infinite loop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ‚úÖ Correct</span></span><br><span class="line"><span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">    <span class="keyword">while</span> current:</span><br><span class="line">        stack.append(current)</span><br><span class="line">        current = current.left</span><br><span class="line">    current = stack.pop()</span><br><span class="line">    result.append(current.val)</span><br><span class="line">    current = current.right  <span class="comment"># Must turn to right subtree</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="problem-3-binary-tree-postorder-traversal">Problem 3: Binary
Tree Postorder Traversal</h1>
<h2 id="problem-statement-2">Problem Statement</h2>
<p>Given the <code>root</code> of a binary tree, return the
<strong>postorder traversal</strong> of its nodes' values.</p>
<p><strong>Postorder Order</strong>: Left subtree ‚Üí Right subtree ‚Üí
Root</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>root = [1,null,2,3]</code></li>
<li>Output: <code>[3,2,1]</code></li>
</ul>
<h2 id="problem-analysis-2">Problem Analysis</h2>
<p>Postorder traversal processes <strong>left and right subtrees first,
then visits root</strong>. This order is useful when deleting tree
nodes, as you need to delete children before parent.</p>
<p><strong>Use Cases</strong>:</p>
<ul>
<li><strong>Deleting binary tree</strong>: Delete subtrees first, then
root</li>
<li><strong>Calculating directory size</strong>: Calculate subdirectory
sizes first, then total</li>
<li><strong>Expression tree evaluation</strong>: Postorder traversal
gives postfix expression (Reverse Polish Notation)</li>
</ul>
<h2 id="solution-approach-2">Solution Approach</h2>
<p><strong>Recursive Approach</strong>: Recurse left, recurse right,
visit root.</p>
<p><strong>Iterative Approach</strong>: Postorder iteration is more
complex. Method 1: Use two stacks, push in "root-right-left" order to
stack1, then pop all to stack2, finally pop stack2 to get
"left-right-root". Method 2: Use one stack, track visit state for each
node (unvisited, left visited, right visited).</p>
<h2 id="complexity-analysis-2">Complexity Analysis</h2>
<ul>
<li><strong>Time Complexity</strong>: <span class="math inline">\(O(n)\)</span></li>
<li><strong>Space Complexity</strong>: <span class="math inline">\(O(h)\)</span></li>
</ul>
<h2 id="recursive-implementation-2">Recursive Implementation</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Postorder traversal: Left -&gt; Right -&gt; Root</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Algorithm Steps:</span></span><br><span class="line"><span class="string">    1. Recursively traverse left subtree</span></span><br><span class="line"><span class="string">    2. Recursively traverse right subtree</span></span><br><span class="line"><span class="string">    3. Visit root node</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        postorder(node.left)     <span class="comment"># Process left subtree first</span></span><br><span class="line">        postorder(node.right)    <span class="comment"># Then process right subtree</span></span><br><span class="line">        result.append(node.val)  <span class="comment"># Finally visit root</span></span><br><span class="line">    </span><br><span class="line">    postorder(root)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="iterative-implementation-two-stack-method">Iterative
Implementation (Two-Stack Method)</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Iterative implementation: Use two stacks</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Algorithm Steps:</span></span><br><span class="line"><span class="string">    1. Use stack1 to traverse in &quot;root-right-left&quot; order</span></span><br><span class="line"><span class="string">    2. Push popped nodes from stack1 to stack2</span></span><br><span class="line"><span class="string">    3. Pop stack2 sequentially to get &quot;left-right-root&quot; order</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Key Technique:</span></span><br><span class="line"><span class="string">    - Stack1: root -&gt; right -&gt; left (mirror of preorder)</span></span><br><span class="line"><span class="string">    - Stack2: Reverse to get left -&gt; right -&gt; root (postorder)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    stack1 = [root]</span><br><span class="line">    stack2 = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack1:</span><br><span class="line">        node = stack1.pop()</span><br><span class="line">        stack2.append(node)  <span class="comment"># Push to stack2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Push left first, then right (so stack2 pops right-&gt;left, reversed to left-&gt;right)</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack1.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack1.append(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Pop stack2 sequentially</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> stack2:</span><br><span class="line">        result.append(stack2.pop().val)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Why Two-Stack Method Works</strong>:</p>
<p>Stack1 traverses in "root-right-left" order (mirror of preorder),
pushing to stack2 maintains this order. Popping stack2 reverses it to
"left-right-root" (postorder).</p>
<h2 id="iterative-implementation-single-stack-method">Iterative
Implementation (Single-Stack Method)</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Iterative implementation: Use one stack, track visit state</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Algorithm Steps:</span></span><br><span class="line"><span class="string">    1. Use stack to store (node, state) tuples</span></span><br><span class="line"><span class="string">    2. State: 0=unvisited, 1=left visited, 2=right visited</span></span><br><span class="line"><span class="string">    3. Decide next step based on state</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    stack = [(root, <span class="number">0</span>)]  <span class="comment"># (node, state)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, state = stack.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> state == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># Unvisited: visit left subtree first</span></span><br><span class="line">            stack.append((node, <span class="number">1</span>))  <span class="comment"># Mark as left visited</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">elif</span> state == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># Left visited: visit right subtree</span></span><br><span class="line">            stack.append((node, <span class="number">2</span>))  <span class="comment"># Mark as right visited</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Right visited: visit root node</span></span><br><span class="line">            result.append(node.val)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="problem-4-binary-tree-level-order-traversal">Problem 4: Binary
Tree Level Order Traversal</h1>
<h2 id="problem-statement-3">Problem Statement</h2>
<p>Given the <code>root</code> of a binary tree, return the
<strong>level order traversal</strong> of its nodes' values (i.e., from
left to right, level by level).</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>root = [3,9,20,null,null,15,7]</code></li>
<li>Output: <code>[[3],[9,20],[15,7]]</code></li>
</ul>
<h2 id="problem-analysis-3">Problem Analysis</h2>
<p>Level-order traversal (BFS) visits nodes level by level from top to
bottom, left to right. Requires a queue (FIFO) to maintain order.</p>
<p><strong>Use Cases</strong>:</p>
<ul>
<li><strong>Printing binary tree</strong>: Print tree structure by
level</li>
<li><strong>Finding shortest path</strong>: Find shortest path from root
to leaf</li>
<li><strong>Serializing binary tree</strong>: Serialize tree structure
by level</li>
</ul>
<h2 id="solution-approach-3">Solution Approach</h2>
<p>Use queue to implement BFS. Enqueue root, then loop: record current
level size, dequeue these nodes and visit, enqueue their children.</p>
<h2 id="complexity-analysis-3">Complexity Analysis</h2>
<ul>
<li><strong>Time Complexity</strong>: <span class="math inline">\(O(n)\)</span>, each node visited once</li>
<li><strong>Space Complexity</strong>: <span class="math inline">\(O(w)\)</span>, where <span class="math inline">\(w\)</span> is maximum tree width (maximum queue
length)</li>
</ul>
<h2 id="implementation">Implementation</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Level-order traversal: Use queue to implement BFS</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Algorithm Steps:</span></span><br><span class="line"><span class="string">    1. Enqueue root node</span></span><br><span class="line"><span class="string">    2. While queue is not empty:</span></span><br><span class="line"><span class="string">       a. Record current level size (queue length)</span></span><br><span class="line"><span class="string">       b. Dequeue these nodes, visit and collect to current level result</span></span><br><span class="line"><span class="string">       c. Enqueue children of dequeued nodes</span></span><br><span class="line"><span class="string">    3. Return results of all levels</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Key Technique:</span></span><br><span class="line"><span class="string">    - Use level_size to record nodes per level, ensure level-by-level processing</span></span><br><span class="line"><span class="string">    - Children enqueued processed in next iteration</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    queue = deque([root])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = <span class="built_in">len</span>(queue)  <span class="comment"># Number of nodes in current level</span></span><br><span class="line">        level = []  <span class="comment"># Current level result</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Process all nodes in current level</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            level.append(node.val)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Enqueue children (next level)</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        </span><br><span class="line">        result.append(level)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Execution Example</strong> (tree
<code>[3,9,20,null,null,15,7]</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Initial: queue = [3], result = []</span><br><span class="line">Level 1: level_size = 1</span><br><span class="line">         Dequeue 3 -&gt; level = [3]</span><br><span class="line">         Enqueue 9, 20 -&gt; queue = [9, 20]</span><br><span class="line">         result = [[3]]</span><br><span class="line">Level 2: level_size = 2</span><br><span class="line">         Dequeue 9 -&gt; level = [9]</span><br><span class="line">         Dequeue 20 -&gt; level = [9, 20]</span><br><span class="line">         Enqueue 15, 7 -&gt; queue = [15, 7]</span><br><span class="line">         result = [[3], [9, 20]]</span><br><span class="line">Level 3: level_size = 2</span><br><span class="line">         Dequeue 15 -&gt; level = [15]</span><br><span class="line">         Dequeue 7 -&gt; level = [15, 7]</span><br><span class="line">         No children to enqueue</span><br><span class="line">         result = [[3], [9, 20], [15, 7]]</span><br><span class="line">End: queue empty</span><br></pre></td></tr></table></figure>
<h2 id="common-pitfall-1">Common Pitfall</h2>
<h3 id="pitfall-forgetting-to-record-level-size">Pitfall: Forgetting to
Record Level Size</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ‚ùå Wrong</span></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">    node = queue.popleft()</span><br><span class="line">    result.append(node.val)  <span class="comment"># No level separation, all nodes mixed</span></span><br><span class="line">    <span class="keyword">if</span> node.left:</span><br><span class="line">        queue.append(node.left)</span><br><span class="line">    <span class="keyword">if</span> node.right:</span><br><span class="line">        queue.append(node.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ‚úÖ Correct</span></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">    level_size = <span class="built_in">len</span>(queue)  <span class="comment"># Must record level size</span></span><br><span class="line">    level = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        level.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">    result.append(level)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="problem-5-construct-binary-tree-from-preorder-and-inorder-traversal">Problem
5: Construct Binary Tree from Preorder and Inorder Traversal</h1>
<h2 id="problem-statement-4">Problem Statement</h2>
<p>Given two integer arrays <code>preorder</code> and
<code>inorder</code> where <code>preorder</code> is the preorder
traversal of a binary tree and <code>inorder</code> is the inorder
traversal of the same tree, construct and return the binary tree.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>preorder = [3,9,20,15,7]</code>,
<code>inorder = [9,3,15,20,7]</code></li>
<li>Output: <code>[3,9,20,null,null,15,7]</code></li>
</ul>
<p><strong>Constraints</strong>:</p>
<ul>
<li><span class="math inline">\(1 \leq \texttt{preorder.length} \leq
3000\)</span></li>
<li><span class="math inline">\(\texttt{inorder.length} ==
\texttt{preorder.length}\)</span></li>
<li><span class="math inline">\(-3000 \leq \texttt{preorder[i],
inorder[i]} \leq 3000\)</span></li>
<li><code>preorder</code> and <code>inorder</code> consist of unique
values</li>
</ul>
<h2 id="problem-analysis-4">Problem Analysis</h2>
<p><strong>Core Insight</strong>:</p>
<ol type="1">
<li><strong>First element of preorder is the root</strong></li>
<li><strong>Find root in inorder, left side is left subtree, right side
is right subtree</strong></li>
<li><strong>Recursively construct left and right subtrees</strong></li>
</ol>
<p><strong>Key Steps</strong>:</p>
<ol type="1">
<li>Take first element from preorder as root</li>
<li>Find root position in inorder</li>
<li>Based on root position, determine left and right subtree ranges</li>
<li>Recursively construct left and right subtrees</li>
</ol>
<h2 id="solution-approach-4">Solution Approach</h2>
<p>Use recursion + hash map to optimize lookup. Hash map stores index of
each value in inorder, avoiding linear search each time.</p>
<h2 id="complexity-analysis-4">Complexity Analysis</h2>
<ul>
<li><strong>Time Complexity</strong>: <span class="math inline">\(O(n)\)</span>, each node visited once, hash map
lookup <span class="math inline">\(O(1)\)</span></li>
<li><strong>Space Complexity</strong>: <span class="math inline">\(O(n)\)</span>, hash map <span class="math inline">\(O(n)\)</span> + recursion stack <span class="math inline">\(O(h)\)</span></li>
</ul>
<h2 id="implementation-1">Implementation</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Construct binary tree from preorder and inorder traversal</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Algorithm Steps:</span></span><br><span class="line"><span class="string">    1. Create hash map storing index of each value in inorder</span></span><br><span class="line"><span class="string">    2. Recursive function build(pre_start, pre_end, in_start, in_end):</span></span><br><span class="line"><span class="string">       a. If pre_start &gt; pre_end, return None</span></span><br><span class="line"><span class="string">       b. Take preorder[pre_start] as root value</span></span><br><span class="line"><span class="string">       c. Find root position root_idx in inorder</span></span><br><span class="line"><span class="string">       d. Calculate left subtree size: left_size = root_idx - in_start</span></span><br><span class="line"><span class="string">       e. Recursively construct left subtree: build(pre_start+1, pre_start+left_size, in_start, root_idx-1)</span></span><br><span class="line"><span class="string">       f. Recursively construct right subtree: build(pre_start+left_size+1, pre_end, root_idx+1, in_end)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Boundary Conditions:</span></span><br><span class="line"><span class="string">    - Empty array: pre_start &gt; pre_end</span></span><br><span class="line"><span class="string">    - Single node: pre_start == pre_end</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Optimization Technique:</span></span><br><span class="line"><span class="string">    - Use hash map to store inorder indices, avoid linear search each time</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Create hash map: value -&gt; index</span></span><br><span class="line">    inorder_map = &#123;val: idx <span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">pre_start, pre_end, in_start, in_end</span>):</span><br><span class="line">        <span class="comment"># Boundary: empty subtree</span></span><br><span class="line">        <span class="keyword">if</span> pre_start &gt; pre_end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Root value</span></span><br><span class="line">        root_val = preorder[pre_start]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Find root position in inorder</span></span><br><span class="line">        root_idx = inorder_map[root_val]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Calculate left subtree size</span></span><br><span class="line">        left_size = root_idx - in_start</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Recursively construct left subtree</span></span><br><span class="line">        <span class="comment"># Preorder: pre_start+1 to pre_start+left_size</span></span><br><span class="line">        <span class="comment"># Inorder: in_start to root_idx-1</span></span><br><span class="line">        root.left = build(</span><br><span class="line">            pre_start + <span class="number">1</span>,</span><br><span class="line">            pre_start + left_size,</span><br><span class="line">            in_start,</span><br><span class="line">            root_idx - <span class="number">1</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Recursively construct right subtree</span></span><br><span class="line">        <span class="comment"># Preorder: pre_start+left_size+1 to pre_end</span></span><br><span class="line">        <span class="comment"># Inorder: root_idx+1 to in_end</span></span><br><span class="line">        root.right = build(</span><br><span class="line">            pre_start + left_size + <span class="number">1</span>,</span><br><span class="line">            pre_end,</span><br><span class="line">            root_idx + <span class="number">1</span>,</span><br><span class="line">            in_end</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">0</span>, <span class="built_in">len</span>(preorder) - <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Index Calculation Details</strong>:</p>
<p>Assume <code>preorder = [3,9,20,15,7]</code>,
<code>inorder = [9,3,15,20,7]</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Root: 3 (preorder[0])</span><br><span class="line">Position in inorder: index=1</span><br><span class="line"></span><br><span class="line">Left subtree:</span><br><span class="line">  - Preorder range: [9] (preorder[1:1+1])</span><br><span class="line">  - Inorder range: [9] (inorder[0:1])</span><br><span class="line">  </span><br><span class="line">Right subtree:</span><br><span class="line">  - Preorder range: [20,15,7] (preorder[2:5])</span><br><span class="line">  - Inorder range: [15,20,7] (inorder[2:5])</span><br></pre></td></tr></table></figure>
<h2 id="algorithm-principle">Algorithm Principle</h2>
<p><strong>Why Binary Tree is Uniquely Determined</strong>:</p>
<p>Preorder tells us root position, inorder tells us left-right subtree
division. Combining these uniquely determines tree structure.</p>
<p><strong>Mathematical Proof</strong>:</p>
<p>For a tree with <span class="math inline">\(n\)</span> nodes, there
are <span class="math inline">\(n!\)</span> possible preorder traversals
and <span class="math inline">\(n!\)</span> possible inorder traversals.
But given preorder and inorder, tree structure is unique (assuming no
duplicate values).</p>
<h2 id="common-pitfalls-1">Common Pitfalls</h2>
<h3 id="pitfall-1-wrong-index-calculation">Pitfall 1: Wrong Index
Calculation</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ‚ùå Wrong: Incorrect left subtree size</span></span><br><span class="line">left_size = root_idx  <span class="comment"># Should be root_idx - in_start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ‚úÖ Correct</span></span><br><span class="line">left_size = root_idx - in_start</span><br></pre></td></tr></table></figure>
<h3 id="pitfall-2-forgetting-boundary-conditions">Pitfall 2: Forgetting
Boundary Conditions</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ‚ùå Wrong</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">pre_start, pre_end, in_start, in_end</span>):</span><br><span class="line">    root_val = preorder[pre_start]  <span class="comment"># Index out of bounds if pre_start &gt; pre_end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># ‚úÖ Correct</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">pre_start, pre_end, in_start, in_end</span>):</span><br><span class="line">    <span class="keyword">if</span> pre_start &gt; pre_end:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root_val = preorder[pre_start]</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="problem-6-construct-binary-tree-from-inorder-and-postorder-traversal">Problem
6: Construct Binary Tree from Inorder and Postorder Traversal</h1>
<h2 id="problem-statement-5">Problem Statement</h2>
<p>Given two integer arrays <code>inorder</code> and
<code>postorder</code> where <code>inorder</code> is the inorder
traversal of a binary tree and <code>postorder</code> is the postorder
traversal of the same tree, construct and return the binary tree.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Input: <code>inorder = [9,3,15,20,7]</code>,
<code>postorder = [9,15,7,20,3]</code></li>
<li>Output: <code>[3,9,20,null,null,15,7]</code></li>
</ul>
<h2 id="problem-analysis-5">Problem Analysis</h2>
<p><strong>Core Insight</strong>:</p>
<ol type="1">
<li><strong>Last element of postorder is the root</strong></li>
<li><strong>Find root in inorder, left side is left subtree, right side
is right subtree</strong></li>
<li><strong>Recursively construct left and right subtrees</strong></li>
</ol>
<p>Difference from preorder construction: root is at the end of
postorder, not the beginning.</p>
<h2 id="solution-approach-5">Solution Approach</h2>
<p>Similar to preorder+inorder construction, but root taken from end of
postorder, right subtree range calculated from right to left.</p>
<h2 id="complexity-analysis-5">Complexity Analysis</h2>
<ul>
<li><strong>Time Complexity</strong>: <span class="math inline">\(O(n)\)</span></li>
<li><strong>Space Complexity</strong>: <span class="math inline">\(O(n)\)</span></li>
</ul>
<h2 id="implementation-2">Implementation</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Construct binary tree from postorder and inorder traversal</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Algorithm Steps:</span></span><br><span class="line"><span class="string">    1. Create hash map storing inorder indices</span></span><br><span class="line"><span class="string">    2. Recursive function build(in_start, in_end, post_start, post_end):</span></span><br><span class="line"><span class="string">       a. If post_start &gt; post_end, return None</span></span><br><span class="line"><span class="string">       b. Take postorder[post_end] as root value</span></span><br><span class="line"><span class="string">       c. Find root position root_idx in inorder</span></span><br><span class="line"><span class="string">       d. Calculate right subtree size: right_size = in_end - root_idx</span></span><br><span class="line"><span class="string">       e. Recursively construct left and right subtrees</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Key Difference:</span></span><br><span class="line"><span class="string">    - Root at end of postorder (post_end)</span></span><br><span class="line"><span class="string">    - Right subtree range calculated from right to left</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    inorder_map = &#123;val: idx <span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">in_start, in_end, post_start, post_end</span>):</span><br><span class="line">        <span class="keyword">if</span> post_start &gt; post_end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Root value (last in postorder)</span></span><br><span class="line">        root_val = postorder[post_end]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Find root position in inorder</span></span><br><span class="line">        root_idx = inorder_map[root_val]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Calculate right subtree size</span></span><br><span class="line">        right_size = in_end - root_idx</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Recursively construct left subtree</span></span><br><span class="line">        <span class="comment"># Inorder: in_start to root_idx-1</span></span><br><span class="line">        <span class="comment"># Postorder: post_start to post_end-right_size-1</span></span><br><span class="line">        root.left = build(</span><br><span class="line">            in_start,</span><br><span class="line">            root_idx - <span class="number">1</span>,</span><br><span class="line">            post_start,</span><br><span class="line">            post_end - right_size - <span class="number">1</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Recursively construct right subtree</span></span><br><span class="line">        <span class="comment"># Inorder: root_idx+1 to in_end</span></span><br><span class="line">        <span class="comment"># Postorder: post_end-right_size to post_end-1</span></span><br><span class="line">        root.right = build(</span><br><span class="line">            root_idx + <span class="number">1</span>,</span><br><span class="line">            in_end,</span><br><span class="line">            post_end - right_size,</span><br><span class="line">            post_end - <span class="number">1</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(postorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="traversal-methods-comparison">Traversal Methods Comparison</h1>
<table>
<colgroup>
<col style="width: 13%">
<col style="width: 8%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr>
<th>Traversal</th>
<th>Order</th>
<th>Recursive Difficulty</th>
<th>Iterative Difficulty</th>
<th>Typical Applications</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Preorder</strong></td>
<td>Root-Left-Right</td>
<td>‚≠ê</td>
<td>‚≠ê‚≠ê</td>
<td>Copy tree, print directory</td>
</tr>
<tr>
<td><strong>Inorder</strong></td>
<td>Left-Root-Right</td>
<td>‚≠ê</td>
<td>‚≠ê‚≠ê</td>
<td>BST sorted output, validate BST</td>
</tr>
<tr>
<td><strong>Postorder</strong></td>
<td>Left-Right-Root</td>
<td>‚≠ê</td>
<td>‚≠ê‚≠ê‚≠ê</td>
<td>Delete tree, calculate directory size</td>
</tr>
<tr>
<td><strong>Level-order</strong></td>
<td>Top-bottom, left-right</td>
<td>‚≠ê‚≠ê</td>
<td>‚≠ê‚≠ê</td>
<td>Print tree, find shortest path</td>
</tr>
</tbody>
</table>
<p><strong>Memory Mnemonic</strong>:</p>
<ul>
<li><strong>Preorder</strong>: Root first (Root-Left-Right)</li>
<li><strong>Inorder</strong>: Root middle (Left-Root-Right)</li>
<li><strong>Postorder</strong>: Root last (Left-Right-Root)</li>
<li><strong>Level-order</strong>: Level by level (BFS)</li>
</ul>
<hr>
<h1 id="qa-common-questions-about-binary-tree-traversal">Q&amp;A: Common
Questions About Binary Tree Traversal</h1>
<h3 id="q1-why-does-inorder-traversal-of-bst-produce-sorted-sequence">Q1:
Why Does Inorder Traversal of BST Produce Sorted Sequence?</h3>
<p><strong>A</strong>: BST definition: For each node, all values in left
subtree &lt; node value &lt; all values in right subtree.</p>
<p>Inorder traversal order is "left-root-right", meaning: 1. First visit
all values less than current node (left subtree) 2. Then visit current
node 3. Finally visit all values greater than current node (right
subtree)</p>
<p>Therefore, inorder traversal of BST naturally produces ascending
sequence.</p>
<p><strong>Verification</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BST: [4,2,6,1,3,5,7]</span></span><br><span class="line"><span class="comment"># Inorder: [1,2,3,4,5,6,7] ‚úÖ Sorted</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="q2-which-is-better-iterative-or-recursive-implementation">Q2:
Which is Better: Iterative or Recursive Implementation?</h3>
<p><strong>A</strong>: Each has pros and cons:</p>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 36%">
<col style="width: 36%">
</colgroup>
<thead>
<tr>
<th>Aspect</th>
<th>Recursive</th>
<th>Iterative</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Code Simplicity</strong></td>
<td>‚úÖ Simpler</td>
<td>‚ùå More complex</td>
</tr>
<tr>
<td><strong>Space Complexity</strong></td>
<td>‚ùå <span class="math inline">\(O(h)\)</span> (recursion stack)</td>
<td>‚úÖ <span class="math inline">\(O(h)\)</span> (explicit stack)</td>
</tr>
<tr>
<td><strong>Stack Overflow Risk</strong></td>
<td>‚ùå May overflow at great depth</td>
<td>‚úÖ Controllable</td>
</tr>
<tr>
<td><strong>Understanding Difficulty</strong></td>
<td>‚úÖ Intuitive</td>
<td>‚ùå Need to understand stack operations</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Comparable</td>
<td>Comparable</td>
</tr>
</tbody>
</table>
<p><strong>Recommendation</strong>:</p>
<ul>
<li><strong>Interview</strong>: Prefer recursion (simpler), rewrite to
iterative if interviewer requests</li>
<li><strong>Production</strong>: Use recursion when depth is
controllable, use iterative when depth is very large</li>
<li><strong>Learning</strong>: Master both, understand the essence</li>
</ul>
<hr>
<h3 id="q3-how-to-choose-traversal-method">Q3: How to Choose Traversal
Method?</h3>
<p><strong>A</strong>: Choose based on problem requirements:</p>
<p><strong>Preorder</strong> suitable for: - Need to process root before
subtrees - Copy tree structure - Print directory structure</p>
<p><strong>Inorder</strong> suitable for: - BST operations (search,
validate, sorted output) - Expression tree infix expression</p>
<p><strong>Postorder</strong> suitable for: - Need to process subtrees
before root - Delete tree nodes - Calculate directory size - Expression
tree postfix expression</p>
<p><strong>Level-order</strong> suitable for: - Need level-by-level
processing - Find shortest path - Serialize binary tree</p>
<hr>
<h3 id="q4-what-are-the-advantages-of-morris-traversal">Q4: What are the
Advantages of Morris Traversal?</h3>
<p><strong>A</strong>: Main advantage is <strong><span class="math inline">\(O(1)\)</span> space complexity</strong>.</p>
<p><strong>Comparison</strong>:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Space Complexity</th>
<th>Time Complexity</th>
<th>Use Cases</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Recursive</strong></td>
<td><span class="math inline">\(O(h)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>General cases</td>
</tr>
<tr>
<td><strong>Iterative + Stack</strong></td>
<td><span class="math inline">\(O(h)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>General cases</td>
</tr>
<tr>
<td><strong>Morris</strong></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>Space-constrained</td>
</tr>
</tbody>
</table>
<p><strong>Costs</strong>:</p>
<ul>
<li>Higher code complexity</li>
<li>Modifies tree structure (temporary links)</li>
<li>Not suitable for multi-threaded environments</li>
</ul>
<p><strong>Recommendation</strong>: Unless space is strictly limited,
prefer recursive or iterative implementation.</p>
<hr>
<h3 id="q5-why-do-we-need-inorder-traversal-to-construct-binary-tree">Q5:
Why Do We Need Inorder Traversal to Construct Binary Tree?</h3>
<p><strong>A</strong>: Inorder traversal provides <strong>left-right
subtree division information</strong>.</p>
<p><strong>Why Preorder + Postorder Cannot Uniquely
Determine</strong>:</p>
<p>Consider two different trees:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tree 1:     1          Tree 2:     1</span><br><span class="line">          /                        \</span><br><span class="line">         2                          2</span><br></pre></td></tr></table></figure>
<ul>
<li>Preorder both: <code>[1, 2]</code></li>
<li>Postorder both: <code>[2, 1]</code></li>
<li>But tree structures differ!</li>
</ul>
<p><strong>Why Preorder + Inorder Can Uniquely Determine</strong>:</p>
<ul>
<li>Preorder tells us root position</li>
<li>Inorder tells us left-right subtree division</li>
<li>Combining both uniquely determines structure</li>
</ul>
<p><strong>Mathematical Proof</strong>: For <span class="math inline">\(n\)</span> nodes, given preorder and inorder, tree
structure is unique (when node values are unique).</p>
<hr>
<h3 id="q6-how-to-handle-binary-trees-with-duplicate-values">Q6: How to
Handle Binary Trees with Duplicate Values?</h3>
<p><strong>A</strong>: With duplicate values, construction may not be
unique.</p>
<p><strong>Problem</strong>: If <code>preorder = [1,1,1]</code>,
<code>inorder = [1,1,1]</code>, cannot uniquely determine tree
structure.</p>
<p><strong>Solutions</strong>:</p>
<ol type="1">
<li><strong>Assume constraint</strong>: Problems usually guarantee
unique node values</li>
<li><strong>If duplicates allowed</strong>: Need additional information
(e.g., node ID) to distinguish</li>
<li><strong>Practical application</strong>: Usually distinguish by node
references rather than values</li>
</ol>
<hr>
<h3 id="q7-why-is-level-order-traversal-time-complexity-on">Q7: Why is
Level-Order Traversal Time Complexity <span class="math inline">\(O(n)\)</span>?</h3>
<p><strong>A</strong>: Each node is enqueued once and dequeued once.</p>
<p><strong>Analysis</strong>:</p>
<ul>
<li><strong>Enqueue operations</strong>: <span class="math inline">\(n\)</span> times (once per node)</li>
<li><strong>Dequeue operations</strong>: <span class="math inline">\(n\)</span> times (once per node)</li>
<li><strong>Visit operations</strong>: <span class="math inline">\(n\)</span> times (once per node)</li>
</ul>
<p>Total operations: <span class="math inline">\(3n = O(n)\)</span></p>
<p><strong>Space Complexity</strong>: Maximum queue length is maximum
tree width <span class="math inline">\(w\)</span>, usually <span class="math inline">\(w \leq n\)</span>, worst case (complete binary
tree) <span class="math inline">\(w = \lceil n/2 \rceil\)</span>.</p>
<hr>
<h2 id="summary-key-points-of-binary-tree-traversal">Summary: Key Points
of Binary Tree Traversal</h2>
<p><strong>Memory Formulas</strong>:</p>
<ul>
<li><strong>Preorder</strong>: Root ‚Üí Left ‚Üí Right</li>
<li><strong>Inorder</strong>: Left ‚Üí Root ‚Üí Right</li>
<li><strong>Postorder</strong>: Left ‚Üí Right ‚Üí Root</li>
<li><strong>Level-order</strong>: BFS, level by level</li>
</ul>
<p><strong>Memory Mnemonic</strong>:</p>
<blockquote>
<p><strong>Pre/In/Post determined by root position, Level-order is
BFS</strong></p>
<p><strong>Tree construction needs inorder, left-right division depends
on it</strong></p>
</blockquote>
<p><strong>Practical Checklist</strong>:</p>
<ul class="task-list">
<li><label><input type="checkbox">Master recursive implementation of
four traversals</label></li>
<li><label><input type="checkbox">Master iterative implementation of
preorder, inorder, level-order</label></li>
<li><label><input type="checkbox">Understand two methods for postorder
iterative implementation</label></li>
<li><label><input type="checkbox">Master constructing binary tree from
preorder+inorder</label></li>
<li><label><input type="checkbox">Master constructing binary tree from
postorder+inorder</label></li>
<li><label><input type="checkbox">Understand Morris traversal
principle (optional)</label></li>
<li><label><input type="checkbox">Able to choose appropriate traversal
method based on problem</label></li>
</ul>
<p><strong>Common Mistakes to Avoid</strong>:</p>
<ul>
<li>‚úÖ Check null nodes in recursion</li>
<li>‚úÖ Pay attention to push order in iteration</li>
<li>‚úÖ Record level size in level-order traversal</li>
<li>‚úÖ Correctly calculate index ranges when constructing tree</li>
</ul>
<p>By systematically mastering binary tree traversal and construction,
you can solve most binary tree-related LeetCode problems. Remember:
Recursion is the foundation, iteration is advanced, understanding the
essence is key!</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>Post titleÔºöLeetCode (6): Binary Tree Traversal &amp; Construction</li>
        <li>Post authorÔºöChen Kai</li>
        <li>Create timeÔºö2023-06-20 00:00:00</li>
        <li>
            Post linkÔºöhttps://www.chenk.top/en/leetcode-binary-tree-traversal/
        </li>
        <li>
            Copyright NoticeÔºöAll articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/en/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/en/tags/Algorithms/">#Algorithms</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/en/tags/Binary-Tree/">#Binary Tree</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/en/leetcode-backtracking/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode (8): Backtracking Algorithm</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/en/leetcode-linked-list-operations/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode (3): Linked List Operations - Reversal, Cycle Detection &amp; Merging</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: 'üòú Â∞ΩÊÉÖËµûÁæéÂ∏ÖÊ∞î‰ºüÂ§ßÁöÑckÂêß~',
                    lang: 'en'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return 'Âçö‰∏ª';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#series-navigation"><span class="nav-number">1.</span> <span class="nav-text">Series Navigation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#binary-tree-fundamentals"><span class="nav-number">2.</span> <span class="nav-text">Binary Tree Fundamentals</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#what-is-a-binary-tree"><span class="nav-number">2.1.</span> <span class="nav-text">What is a Binary Tree?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#types-of-binary-trees"><span class="nav-number">2.2.</span> <span class="nav-text">Types of Binary Trees</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#problem-1-binary-tree-preorder-traversal"><span class="nav-number">3.</span> <span class="nav-text">Problem 1: Binary Tree
Preorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-statement"><span class="nav-number">3.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-analysis"><span class="nav-number">3.2.</span> <span class="nav-text">Problem Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solution-approach"><span class="nav-number">3.3.</span> <span class="nav-text">Solution Approach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#complexity-analysis"><span class="nav-number">3.4.</span> <span class="nav-text">Complexity Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recursive-implementation"><span class="nav-number">3.5.</span> <span class="nav-text">Recursive Implementation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iterative-implementation"><span class="nav-number">3.6.</span> <span class="nav-text">Iterative Implementation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#common-pitfalls"><span class="nav-number">3.7.</span> <span class="nav-text">Common Pitfalls</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pitfall-1-forgetting-to-handle-null-nodes"><span class="nav-number">3.7.1.</span> <span class="nav-text">Pitfall 1: Forgetting
to Handle Null Nodes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pitfall-2-wrong-push-order-in-iterative-implementation"><span class="nav-number">3.7.2.</span> <span class="nav-text">Pitfall
2: Wrong Push Order in Iterative Implementation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#variant-extension"><span class="nav-number">3.8.</span> <span class="nav-text">Variant Extension</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#variant-1-morris-preorder-traversal-o1-space"><span class="nav-number">3.8.1.</span> <span class="nav-text">Variant 1: Morris
Preorder Traversal (\(O(1)\)
Space)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#problem-2-binary-tree-inorder-traversal"><span class="nav-number">4.</span> <span class="nav-text">Problem 2: Binary Tree
Inorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-statement-1"><span class="nav-number">4.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-analysis-1"><span class="nav-number">4.2.</span> <span class="nav-text">Problem Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solution-approach-1"><span class="nav-number">4.3.</span> <span class="nav-text">Solution Approach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#complexity-analysis-1"><span class="nav-number">4.4.</span> <span class="nav-text">Complexity Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recursive-implementation-1"><span class="nav-number">4.5.</span> <span class="nav-text">Recursive Implementation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iterative-implementation-1"><span class="nav-number">4.6.</span> <span class="nav-text">Iterative Implementation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#common-pitfall"><span class="nav-number">4.7.</span> <span class="nav-text">Common Pitfall</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pitfall-forgetting-to-turn-to-right-subtree"><span class="nav-number">4.7.1.</span> <span class="nav-text">Pitfall: Forgetting
to Turn to Right Subtree</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#problem-3-binary-tree-postorder-traversal"><span class="nav-number">5.</span> <span class="nav-text">Problem 3: Binary
Tree Postorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-statement-2"><span class="nav-number">5.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-analysis-2"><span class="nav-number">5.2.</span> <span class="nav-text">Problem Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solution-approach-2"><span class="nav-number">5.3.</span> <span class="nav-text">Solution Approach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#complexity-analysis-2"><span class="nav-number">5.4.</span> <span class="nav-text">Complexity Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recursive-implementation-2"><span class="nav-number">5.5.</span> <span class="nav-text">Recursive Implementation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iterative-implementation-two-stack-method"><span class="nav-number">5.6.</span> <span class="nav-text">Iterative
Implementation (Two-Stack Method)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iterative-implementation-single-stack-method"><span class="nav-number">5.7.</span> <span class="nav-text">Iterative
Implementation (Single-Stack Method)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#problem-4-binary-tree-level-order-traversal"><span class="nav-number">6.</span> <span class="nav-text">Problem 4: Binary
Tree Level Order Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-statement-3"><span class="nav-number">6.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-analysis-3"><span class="nav-number">6.2.</span> <span class="nav-text">Problem Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solution-approach-3"><span class="nav-number">6.3.</span> <span class="nav-text">Solution Approach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#complexity-analysis-3"><span class="nav-number">6.4.</span> <span class="nav-text">Complexity Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#implementation"><span class="nav-number">6.5.</span> <span class="nav-text">Implementation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#common-pitfall-1"><span class="nav-number">6.6.</span> <span class="nav-text">Common Pitfall</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pitfall-forgetting-to-record-level-size"><span class="nav-number">6.6.1.</span> <span class="nav-text">Pitfall: Forgetting to
Record Level Size</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#problem-5-construct-binary-tree-from-preorder-and-inorder-traversal"><span class="nav-number">7.</span> <span class="nav-text">Problem
5: Construct Binary Tree from Preorder and Inorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-statement-4"><span class="nav-number">7.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-analysis-4"><span class="nav-number">7.2.</span> <span class="nav-text">Problem Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solution-approach-4"><span class="nav-number">7.3.</span> <span class="nav-text">Solution Approach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#complexity-analysis-4"><span class="nav-number">7.4.</span> <span class="nav-text">Complexity Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#implementation-1"><span class="nav-number">7.5.</span> <span class="nav-text">Implementation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#algorithm-principle"><span class="nav-number">7.6.</span> <span class="nav-text">Algorithm Principle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#common-pitfalls-1"><span class="nav-number">7.7.</span> <span class="nav-text">Common Pitfalls</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pitfall-1-wrong-index-calculation"><span class="nav-number">7.7.1.</span> <span class="nav-text">Pitfall 1: Wrong Index
Calculation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pitfall-2-forgetting-boundary-conditions"><span class="nav-number">7.7.2.</span> <span class="nav-text">Pitfall 2: Forgetting
Boundary Conditions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#problem-6-construct-binary-tree-from-inorder-and-postorder-traversal"><span class="nav-number">8.</span> <span class="nav-text">Problem
6: Construct Binary Tree from Inorder and Postorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-statement-5"><span class="nav-number">8.1.</span> <span class="nav-text">Problem Statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-analysis-5"><span class="nav-number">8.2.</span> <span class="nav-text">Problem Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solution-approach-5"><span class="nav-number">8.3.</span> <span class="nav-text">Solution Approach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#complexity-analysis-5"><span class="nav-number">8.4.</span> <span class="nav-text">Complexity Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#implementation-2"><span class="nav-number">8.5.</span> <span class="nav-text">Implementation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#traversal-methods-comparison"><span class="nav-number">9.</span> <span class="nav-text">Traversal Methods Comparison</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#qa-common-questions-about-binary-tree-traversal"><span class="nav-number">10.</span> <span class="nav-text">Q&amp;A: Common
Questions About Binary Tree Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#q1-why-does-inorder-traversal-of-bst-produce-sorted-sequence"><span class="nav-number">10.0.1.</span> <span class="nav-text">Q1:
Why Does Inorder Traversal of BST Produce Sorted Sequence?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q2-which-is-better-iterative-or-recursive-implementation"><span class="nav-number">10.0.2.</span> <span class="nav-text">Q2:
Which is Better: Iterative or Recursive Implementation?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q3-how-to-choose-traversal-method"><span class="nav-number">10.0.3.</span> <span class="nav-text">Q3: How to Choose Traversal
Method?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q4-what-are-the-advantages-of-morris-traversal"><span class="nav-number">10.0.4.</span> <span class="nav-text">Q4: What are the
Advantages of Morris Traversal?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q5-why-do-we-need-inorder-traversal-to-construct-binary-tree"><span class="nav-number">10.0.5.</span> <span class="nav-text">Q5:
Why Do We Need Inorder Traversal to Construct Binary Tree?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q6-how-to-handle-binary-trees-with-duplicate-values"><span class="nav-number">10.0.6.</span> <span class="nav-text">Q6: How to
Handle Binary Trees with Duplicate Values?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q7-why-is-level-order-traversal-time-complexity-on"><span class="nav-number">10.0.7.</span> <span class="nav-text">Q7: Why is
Level-Order Traversal Time Complexity \(O(n)\)?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#summary-key-points-of-binary-tree-traversal"><span class="nav-number">10.1.</span> <span class="nav-text">Summary: Key Points
of Binary Tree Traversal</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
