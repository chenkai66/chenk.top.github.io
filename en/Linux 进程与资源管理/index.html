<!DOCTYPE html>



<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            Linux 进程与资源管理 |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"en","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/en/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Linux 进程与资源管理</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2025-02-08 00:00:00</span>
        <span class="mobile">2025-02-08 00:00</span>
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/tags/Linux/">Linux</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/en/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>7.5k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>28 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>Effective Linux troubleshooting is about turning symptoms into a concrete resource story: which process is consuming CPU, where memory is going (and what “buffer/cache” really means), whether you’re blocked on disk I/O, and which files or ports are involved. This post builds that mental model from the basics (process vs. program vs. thread, parent/child relationships), then walks through a practical toolbox (<code>top/htop/ps/pstree/lsof</code>, network and I/O inspection, load and stress testing). It also covers “control levers” you’ll use in production—signals, background jobs, <code>nice/renice</code>, and diagnosing orphan/zombie processes—so you can both locate and fix issues instead of just observing them.</p>
<span id="more"></span>
<h1>一、进程与程序管理</h1>
<h2 id="1-进程与程序之间的关系-v2"><a class="header-anchor" href="#1-进程与程序之间的关系-v2">¶</a>1. 进程与程序之间的关系</h2>
<p>在 Linux 中，<strong>程序</strong>是存储在硬盘上的静态可执行文件，而<strong>进程</strong>是程序加载到内存中后运行的实例。每次运行程序时，系统都会创建一个或多个进程，每个进程拥有独立的内存空间、进程ID（PID）、父进程ID（PPID）以及各自的运行环境。进程是动态存在的，是源代码和数据的结合体，是一个资源单位，而程序则是静态存储的代码集合。</p>
<p>线程则是 CPU 运行的最小工作单位，例如一个网易云音乐进程可能包含两个线程，一个是下载音乐，一个是播放歌曲。因此进程可以理解为工地上指挥干活的包工头，线程是具体干活的工人。</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/program-process-task-thread_1589445704853.jpeg" alt="程序、进程、线程和任务之间关系| iBit程序猿"></p>
<p><strong>例子</strong>：</p>
<ul>
<li>当你在 Ubuntu 中运行 <code>vim myfile.txt</code> 时，<code>vim</code> 程序从硬盘加载到内存中，产生一个进程，该进程负责编辑 <code>myfile.txt</code>。</li>
<li>同一个程序可以同时启动多个进程，例如在浏览器中打开多个标签页时，每个标签页可能对应一个独立的进程或线程。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：启动 vim 进程并查看 PID</span></span><br><span class="line">vim myfile.txt &amp;</span><br><span class="line">ps -ef | grep vim</span><br></pre></td></tr></table></figure>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206003356484.png" alt="image-20250206003356484"></p>
<h2 id="2-进程的特点-v2"><a class="header-anchor" href="#2-进程的特点-v2">¶</a>2. 进程的特点</h2>
<h3 id="进程的独立性与并发性-v2"><a class="header-anchor" href="#进程的独立性与并发性-v2">¶</a>进程的独立性与并发性</h3>
<ul>
<li><strong>独立性</strong>：每个进程都有自己的内存空间和系统资源，彼此相互隔离。</li>
<li><strong>并发性</strong>：操作系统允许多个进程同时运行，通过多任务调度实现并发处理。</li>
<li><strong>动态性</strong>：进程不断创建、执行、终止，状态实时变化。【操作系统的运行就是不断的创建进程和销毁进程】</li>
<li><strong>父子关系</strong>：进程由父进程通过 <code>fork()</code> 调用创建，形成父子结构；父进程的 PPID 字段指明了其创建者。</li>
<li><strong>调度性</strong>：操作系统使用调度算法（如时间片轮转、优先级调度）来决定进程的执行顺序。</li>
</ul>
<h3 id="示例-v3"><a class="header-anchor" href="#示例-v3">¶</a>示例</h3>
<ul>
<li>使用 <code>ps -ef</code> 查看进程时，可以看到每个进程的 PID 和 PPID，帮助理解父子进程关系。</li>
<li>父进程退出后，子进程成为孤儿进程，由 <code>init</code> 或 <code>systemd</code> 接管。</li>
<li>当子进程结束但父进程未调用 <code>wait()</code> 回收时，会产生僵尸进程，其信息仍保留在进程表中。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程父子关系示例</span></span><br><span class="line">ps -ef | grep bash</span><br><span class="line">pstree -p</span><br></pre></td></tr></table></figure>
<h1>二、Linux 系统资源管理概述</h1>
<p>运维工作围绕硬件和软件资源展开，合理管理这些资源可确保系统高效稳定运行。下面介绍主要硬件与软件资源及常用监控工具。</p>
<h2 id="1-硬件资源管理-v2"><a class="header-anchor" href="#1-硬件资源管理-v2">¶</a>1. 硬件资源管理</h2>
<p><strong>磁盘资源</strong></p>
<ul>
<li>
<p><strong>容量</strong>：硬盘或 SSD 提供的总存储空间。</p>
</li>
<li>
<p><strong>读写性能</strong>：</p>
<ul>
<li><strong>机械硬盘（HDD）</strong>：容量大、价格低、速度较慢。</li>
<li><strong>固态硬盘（SSD）</strong>：速度快、价格高、容量相对较小。</li>
</ul>
</li>
<li>
<p><strong>常用命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h       <span class="comment"># 查看磁盘使用情况</span></span><br><span class="line">lsblk       <span class="comment"># 列出块设备及挂载点</span></span><br><span class="line">iostat      <span class="comment"># 监控磁盘 I/O 性能</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206111508163.png" alt="image-20250206111508163"></p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206111526729.png" alt="image-20250206111526729"></p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206111544412.png" alt="image-20250206111544412"></p>
<ul>
<li>操作系统 0 号进程：0号进程会创建出一堆内核级进程，提供操作系统运行</li>
<li>用户级别 1 号进程：
<ul>
<li>基于 1 号进程创建子进程 <code>sshd</code> 服务</li>
<li>基于 <code>sshd</code> 服务产生 <code>ssh</code> 客户端连接进程</li>
<li>基于 <code>ssh</code> 进程产生用户 <code>bash</code> 进程</li>
<li>基于 <code>bash</code> 进程产生用户执行的其他进程</li>
</ul>
</li>
</ul>
<p><strong>内存资源</strong></p>
<ul>
<li>
<p><strong>总内存与剩余内存</strong>：反映系统当前内存占用情况。</p>
</li>
<li>
<p><strong>常用命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free -hfree -h     <span class="comment"># 查看内存和交换空间使用情况</span></span><br><span class="line">vmstat      <span class="comment"># 查看虚拟内存统计信息</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206153209092.png" alt="image-20250206153209092"></p>
<p><strong>CPU 资源</strong></p>
<ul>
<li>
<p><strong>核心数与负载</strong>：监控各进程对 CPU 的占用情况和系统整体负载。</p>
</li>
<li>
<p><strong>常用命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line">htop</span><br><span class="line">mpstat</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>网络资源</strong></p>
<ul>
<li>
<p><strong>带宽、吞吐量与延迟</strong>：监控网络接口的数据传输速率和状态。</p>
</li>
<li>
<p><strong>常用命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iftop       <span class="comment"># 实时监控网络流量</span></span><br><span class="line">ip -s <span class="built_in">link</span>  <span class="comment"># 查看接口统计信息</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-软件资源与服务管理-v2"><a class="header-anchor" href="#2-软件资源与服务管理-v2">¶</a>2. 软件资源与服务管理</h2>
<ul>
<li><strong>系统服务</strong>：如 <code>sshd</code>, <code>crond</code>, <code>ntpd</code> 等，通过 <code>systemctl</code> 管理。</li>
<li><strong>日志管理</strong>：利用 <code>rsyslog</code> 或 <code>journalctl</code> 分析系统和应用日志。</li>
<li><strong>计划任务</strong>：使用 <code>crontab</code> 配置定时任务，实现自动化运维。</li>
</ul>
<p><strong>例子</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl status sshd</span><br><span class="line">systemctl restart ntpd</span><br><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<h2 id="3-Buffer-和-Cache-讲解-v2"><a class="header-anchor" href="#3-Buffer-和-Cache-讲解-v2">¶</a>3. Buffer 和 Cache 讲解</h2>
<p>Linux 系统将内存划分为多个区域，其中 Buffer 和 Cache 是两个非常重要的区域。理解这两个概念有助于更好地优化系统性能和排查问题。</p>
<h3 id="缓存与性能-v2"><a class="header-anchor" href="#缓存与性能-v2">¶</a>缓存与性能</h3>
<ol>
<li><strong>高效的内存使用</strong>：内存中的 Buffer 和 Cache 提供了数据的快速访问通道。当程序需要读取文件时，Linux 会首先检查 Cache 中是否有该文件的数据，如果有，直接从内存中读取，速度非常快；如果没有，则从磁盘读取并缓存到内存。</li>
<li><strong>提升磁盘 I/O 性能</strong>：Buffer 和 Cache 缓存使得磁盘 I/O 变得更加高效，减少了磁盘的访问次数，提高了系统性能。</li>
</ol>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/maxresdefault.jpg" alt="Buffer Cache"></p>
<h3 id="Buffer（写入数据时加速）-v2"><a class="header-anchor" href="#Buffer（写入数据时加速）-v2">¶</a>Buffer（写入数据时加速）</h3>
<p><strong>定义</strong>：Buffer 是操作系统用于存储即将写入磁盘的数据的内存区域。当程序要写入文件时，数据首先会被存储在内存中的 Buffer 中，等到合适的时机再分批次写入磁盘。没有 buffer 的时候会产生大量的零碎文件，不断的把碎片文件写如此盘，太慢了。</p>
<p><strong>作用</strong>：它减少了程序直接与磁盘交互的次数，从而提高了 I/O 性能。</p>
<h3 id="Cache（读取数据时加速）-v2"><a class="header-anchor" href="#Cache（读取数据时加速）-v2">¶</a>Cache（读取数据时加速）</h3>
<p><strong>定义</strong>：Cache 是用于存储已经读取过的数据，目的是加速后续访问。Cache 保存了频繁访问的磁盘数据，以减少磁盘 I/O 操作，提高数据读取速度。</p>
<p><strong>作用</strong>：缓存是内存中高速存取的数据区域，频繁访问的数据会被缓存在内存中，而不是每次都去磁盘读取。</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/2478745-20220518204225587-325292210.png" alt="buff和cached解析- 屯子里唯一的架构师- 博客园"></p>
<h1>三、进程监控工具详解</h1>
<h2 id="1-使用-top-动态查看进程信息-v2"><a class="header-anchor" href="#1-使用-top-动态查看进程信息-v2">¶</a>1. 使用 <code>top</code> 动态查看进程信息</h2>
<p><code>top</code> 提供实时进程信息，显示 CPU、内存使用率、运行时间、命令等信息。</p>
<p><strong>基本用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206150129592.png" alt="image-20250206150129592"></p>
<p>第一行的 <code>load average</code> 里，CPU是几核的，数字越接近几压力就越大，例如CPU是4核的，数字越接近4压力就越大</p>
<p><strong>常用快捷键</strong>：</p>
<ul>
<li>P：按 CPU 占用排序</li>
<li>M：按内存占用排序</li>
<li>k：输入 PID 发送信号终止进程</li>
<li>q：退出 top 界面</li>
</ul>
<p><strong>补充（glances）</strong>：综合监控工具，实时展示系统各项指标。这个工具是基于Python开发的，可以用Python去改造，同时还提供了Web可视化页面，也就是这个程序部署在云上，可以以Web的形式展示系统资源。</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206150908037.png" alt="image-20250206150908037"></p>
<h2 id="2-使用-htop-增强监控体验-v2"><a class="header-anchor" href="#2-使用-htop-增强监控体验-v2">¶</a>2. 使用 <code>htop</code> 增强监控体验</h2>
<p><code>htop</code> 是 <code>top</code> 的增强版，具有友好的彩色界面和交互式操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt install htop</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">htop</span><br></pre></td></tr></table></figure>
<p><strong>特点</strong>：</p>
<ul>
<li>支持鼠标操作</li>
<li>显示树状进程视图</li>
<li>可直接选择并终止进程</li>
</ul>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206150847590.png" alt="image-20250206150847590"></p>
<h2 id="3-使用-ps-静态查看进程信息-v2"><a class="header-anchor" href="#3-使用-ps-静态查看进程信息-v2">¶</a>3. 使用 <code>ps</code> 静态查看进程信息</h2>
<p>ps 命令提供当前进程快照信息，可通过不同选项显示详细内容。</p>
<p><strong>常用用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206134925579.png" alt="image-20250206134925579"></p>
<p><code>ps</code> 看到的进程名字，如果带有中括号，那就是Linux内核自动生成的进程，如果没有中括号（第一行），就是发行版系统，用户生成的各种进程。也就是说，Linux 是一个开源内核，而 Ubuntu 则是基于 Linux 内核构建的一个 Linux 发行版。</p>
<ul>
<li><strong>Linux 内核</strong>：Linux 内核是由 Linus Torvalds 在 1991 年首次发布的，它是操作系统的核心，负责硬件管理、内存管理、进程调度、文件系统等基本功能。内核本身不包含用户界面或应用程序，它只是提供了系统资源的抽象层和基本服务。</li>
<li><strong>Linux 发行版（Distribution）</strong>：Linux 发行版是在 Linux 内核的基础上，整合了大量软件包、工具和应用程序，形成一个完整的操作系统。发行版会添加图形界面、命令行工具、安装程序和各种预配置的软件，使得普通用户也能方便地使用 Linux 系统。Ubuntu 就是众多 Linux 发行版之一，它以用户友好、易于安装和良好的社区支持而著称。</li>
</ul>
<p>简单来说，Ubuntu 使用 Linux 内核，并在其基础上整合了各种软件包和工具，构成一个完整的操作系统。其他知名的发行版还有 Debian、Fedora、CentOS 等，它们都共享同一个 Linux 内核，但在软件选择、配置和用户体验上有所不同。</p>
<p><code>ps -ef</code> 是 Unix 风格的命令，有短横线，而 <code>ps auf</code> 是 BSD 风格的命令，没有短横线。Unix 风格的具体命令格式和其他参数如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef -p &lt;pid_list&gt; -C &lt;<span class="built_in">command</span>&gt; -U &lt;user&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-e</strong>：显示所有进程（等同于 –A），即不限制进程所属的终端、用户等。</li>
<li><strong>-f</strong>：使用全格式输出（Full-format），会显示额外的信息，例如 UID、PID、PPID、C（CPU 占用）、STIME、TTY、TIME、CMD 等。输出内容更详细。</li>
<li><strong>-p</strong>：根据进程 ID（PID）过滤显示，仅列出指定 PID 的进程。使用时需要在后面跟上一个或多个 PID 列表，例如 <code>-p 1234,5678</code>。</li>
<li><strong>-C</strong>：根据命令名过滤显示，仅列出指定命令名称对应的进程。例如 -C sshd 会显示所有名称为 sshd 的进程。</li>
<li><strong>-U</strong>：根据实际用户（Real user）过滤显示，仅显示指定用户拥有的进程。例如 <code>-U root</code> 会显示 <code>root</code> 用户的所有进程。</li>
</ul>
<p>BSD 风格的命令的各个选项的含义如下：</p>
<ul>
<li><strong>a</strong>：显示所有与终端相关的进程，不仅限于当前用户的进程。</li>
<li><strong>x</strong>：显示所有进程，包括那些没有控制终端（TTY）的进程（例如守护进程或后台进程）。</li>
<li><strong>u</strong>：以用户导向格式显示进程信息，输出中会包含 <code>USER、PID、%CPU、%MEM、VSZ、RSS、TTY、STAT、START、TIME、COMMAND</code> 等列，更加直观易读。</li>
<li><strong>f</strong>：以树状结构（forest）的形式 ps显示进程之间的父子关系，有助于理解进程的继承关系。</li>
<li><strong>o</strong>：允许用户自定义输出格式，可以指定输出哪些列。如果后面没有跟参数，则使用默认格式；通常可以写成 <code>ps axu -o pid,ppid,cmd</code> 这种形式来指定需要显示的列。</li>
<li><strong>k</strong>：用来指定排序关键字，控制输出结果的排序方式。例如可以按 PID、CPU 占用或内存等排序。如果后面没有跟具体参数，则通常使用默认排序方式。</li>
</ul>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206150048998.png" alt="image-20250206150048998"></p>
<p><code>ps</code> 可以去掉 <code>grep</code> 显示的那个进程，方法是使用 <code>-v</code> 参数（结果取反）：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206152136083.png" alt="image-20250206152136083"></p>
<h2 id="4-使用-pstree-显示进程树-v2"><a class="header-anchor" href="#4-使用-pstree-显示进程树-v2">¶</a>4. 使用 <code>pstree</code> 显示进程树</h2>
<p><code>pstree</code> 以树状结构展示进程父子关系，帮助理解进程层级。</p>
<p><strong>基本用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree -p</span><br></pre></td></tr></table></figure>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206151051241.png" alt="image-20250206151051241"></p>
<h2 id="5-使用-pidof-查找进程-PID-v2"><a class="header-anchor" href="#5-使用-pidof-查找进程-PID-v2">¶</a>5. 使用 <code>pidof</code> 查找进程 PID</h2>
<p><code>pidof</code> 能查找指定进程的 PID，适合脚本自动化管理。</p>
<p><strong>基本用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行 pidof sshd 返回所有 SSH 守护进程的 PID。</span></span><br><span class="line">pidof sshd</span><br></pre></td></tr></table></figure>
<h2 id="6-使用-lsof-查看打开的文件-v2"><a class="header-anchor" href="#6-使用-lsof-查看打开的文件-v2">¶</a>6. 使用 <code>lsof</code> 查看打开的文件</h2>
<p><code>lsof</code>（List Open Files）用于列出系统中所有打开的文件，包括常见的网络连接、设备和进程占用的文件。以下是一些常用参数及其说明：</p>
<ul>
<li>
<p><strong>-a</strong><br>
与其他选项一起使用，表示“与”关系（AND），只显示同时满足所有条件的结果。</p>
</li>
<li>
<p><strong>-c <command></strong><br>
按进程名称过滤，显示指定命令名的进程所打开的文件。<br>
<em>示例：</em> <code>lsof -c ssh</code></p>
</li>
<li>
<p><strong>-d <fd></fd></strong><br>
按文件描述符过滤，显示特定文件描述符（如 <code>cwd</code>、<code>txt</code>、<code>mem</code>、<code>1</code>、<code>2</code> 等）的打开文件。<br>
<em>示例：</em> <code>lsof -d cwd</code></p>
</li>
<li>
<p><strong>-i [protocol][@hostname|hostaddr][:service|port]</strong><br>
显示网络相关的打开文件。</p>
<ul>
<li><code>lsof -i</code> 显示所有网络连接</li>
<li><code>lsof -i tcp</code> 显示所有 TCP 连接</li>
<li><code>lsof -i :80</code> 显示所有使用 80 端口的进程</li>
<li><code>lsof -i @192.168.1.100</code> 显示与特定 IP 相关的连接</li>
</ul>
</li>
<li>
<p><strong>-n</strong><br>
禁用主机名解析，直接显示 IP 地址，有助于提高执行速度并避免 DNS 查询延迟。</p>
</li>
<li>
<p><strong>-P</strong><br>
禁用端口号转换，不把端口号转换为服务名称，直接显示数字端口。</p>
</li>
<li>
<p><strong>-u <user></user></strong><br>
按用户过滤，显示指定用户的所有打开文件。<br>
<em>示例：</em> <code>lsof -u root</code></p>
</li>
<li>
<p><strong>-p <pid></pid></strong><br>
按进程 ID 过滤，显示指定进程的所有打开文件。<br>
<em>示例：</em> <code>lsof -p 1234</code></p>
</li>
<li>
<p><strong>+D <directory></directory></strong><br>
列出指定目录（包括子目录）中所有打开的文件。<br>
<em>示例：</em> <code>lsof +D /var/log</code></p>
</li>
<li>
<p><strong>+L1</strong><br>
列出链接计数小于 1 的文件，通常表示文件已删除但仍被进程占用。</p>
</li>
<li>
<p><strong>-r [interval]</strong><br>
循环执行 <code>lsof</code>，每隔指定秒数刷新一次结果，常用于实时监控。<br>
<em>示例：</em> <code>lsof -r 2</code> （每 2 秒刷新一次）</p>
</li>
<li>
<p><strong>-V</strong><br>
显示 <code>lsof</code> 版本信息。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<p>列出所有使用 80 端口的网络连接，不解析主机名和端口名称：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -nlsof -nP -i :80P -i :80</span><br></pre></td></tr></table></figure>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206173629686.png" alt="image-20250206173629686"></p>
<p>其他一些用法：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206152853213.png" alt="image-20250206152853213"></p>
<p>查看 Nginx 进程打开了哪些文件，进一步可以从中过滤出日志文件：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206153440327.png" alt="image-20250206153440327"></p>
<p>还可以查看占用文件的进程：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206173342247.png" alt="image-20250206173342247"></p>
<h2 id="7-网络流量与端口监控-v2"><a class="header-anchor" href="#7-网络流量与端口监控-v2">¶</a>7. 网络流量与端口监控</h2>
<ul>
<li><strong>iftop</strong>：实时显示网络接口数据流量。</li>
<li><strong>lsof</strong>：查看进程打开的文件或网络端口。</li>
<li><strong>netstat, ss</strong></li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo iftop -i ens160</span><br><span class="line">lsof -i :80</span><br></pre></td></tr></table></figure>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250208013603183.png" alt="image-20250208013603183"></p>
<p>也可以使用 <code>netstat</code> 或者具有更快的查询速度的 <code>ss</code> 命令查看端口信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulnp</span><br><span class="line">ss -tulnp <span class="comment"># 高并发下性能更高</span></span><br></pre></td></tr></table></figure>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250208013219488.png" alt="image-20250208013219488"></p>
<p><code>-t</code> 显示 TCP 连接，<code>-u</code> 显示 UDP 连接，<code>-l</code> 显示监听端口（过滤出 State 列中值为 LISTEN 的连接），<code>-n</code> 显示数字形式的地址和端口，<code>-p</code> 表示显示发起连接的进程 <code>pid</code> 和进程名称。</p>
<h2 id="8-磁盘-I-O-查看-v2"><a class="header-anchor" href="#8-磁盘-I-O-查看-v2">¶</a>8. 磁盘 I/O 查看</h2>
<p>磁盘 I/O 的性能直接影响到系统的运行效率，特别是在进行大规模数据处理时。</p>
<p><code>iostat</code> 命令提供了关于 CPU 和 I/O 设备的详细统计信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x</span><br></pre></td></tr></table></figure>
<p><code>-x</code> 参数显示扩展信息，包括每个设备的 I/O 性能。</p>
<p>另外也可以使用 <code>iotop</code> 实时查看磁盘 I/O 使用情况，但需要管理员权限来运行，实时显示进程的磁盘 I/O 使用情况。</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250208011840833.png" alt="image-20250208011840833"></p>
<p><code>iotop -k</code> 可以动态显示 IO 情况：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250208012108808.png" alt="image-20250208012108808"></p>
<h2 id="9-内存资源查看-free-v2"><a class="header-anchor" href="#9-内存资源查看-free-v2">¶</a>9. 内存资源查看 <code>free</code></h2>
<p>在 Linux 系统中，查看内存资源的使用情况，可以使用 <code>free</code> 命令。该命令提供了有关系统内存使用的汇总信息。</p>
<ol>
<li>
<p><strong>查看内存使用情况</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​		<code>-h</code> 参数会以人类易读的格式（如 MB、GB）显示内存使用情况。</p>
<ol start="2">
<li>
<p><strong>输出详细信息</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>
<p><code>-m</code> 参数以 MB 为单位显示内存使用情况，适用于查看内存总量和剩余空间。</p>
</li>
<li>
<p><strong>查看内存使用变化</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch free -h</span><br></pre></td></tr></table></figure>
<p>使用 <code>watch</code> 命令可以实时监控内存使用情况，自动刷新显示结果。</p>
</li>
</ol>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250208010259465.png" alt="image-20250208010259465"></p>
<blockquote>
<p>swap 是硬件交换分区（虚拟内存），防止内存用完导致系统崩溃，临时拿磁盘的一些空间当做内存使用。</p>
</blockquote>
<h2 id="10-CPU-与负载管理-v2"><a class="header-anchor" href="#10-CPU-与负载管理-v2">¶</a>10. CPU 与负载管理</h2>
<p>在 Linux 系统中，查看 CPU 核心数非常简单，可以使用以下命令来查看当前系统中的 CPU 配置：</p>
<ul>
<li>
<p><strong><code>lscpu</code> 命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  lscpu | grep -i <span class="string">&#x27;^cpu(s)&#x27;</span></span><br><span class="line"></span><br><span class="line">​		这个命令会输出系统中 CPU 的核心数信息，例如：</span><br><span class="line"></span><br><span class="line">​		![image-20250208004559916](./Linux%20进程与资源管理/image-20250208004559916.png)</span><br><span class="line"></span><br><span class="line">* **`top` 命令**：在 `top` 命令的实时监控界面中，按下 1 键可以查看每个 CPU 核心的使用情况。理想情况下，所有 CPU 核心都会有进程在执行，这表示 CPU 被充分利用，系统的运行效率最大化。</span><br><span class="line"></span><br><span class="line">理想的 CPU 利用状态是系统中的每个核心都在处理进程。在高并发编程中，目标是让系统的每个 CPU 核心都得到充分的利用，这样才能在多核 CPU 系统中达到最大的工作效率。例如，如果你有 4 个核心的 CPU，理想情况下，应该有 4 个进程同时运行，每个进程占用一个 CPU 核心。这样系统可以最大化地发挥 CPU 的处理能力。如果你的代码或程序设计不当，导致只有一个核心在执行任务，而其他核心空闲，这样就不能充分利用所有的 CPU 核心，导致系统资源浪费。</span><br><span class="line"></span><br><span class="line">* **<span class="built_in">uptime</span> 命令**：</span><br><span class="line"></span><br><span class="line">  ```bash</span><br><span class="line">   <span class="comment"># 输出示例</span></span><br><span class="line">   06:56:12 up 12 days,  3:45,  3 <span class="built_in">users</span>,  load average: 0.22, 0.45, 0.56</span><br></pre></td></tr></table></figure>
<p>在输出中，load average 后面跟着的是三个数字，分别表示 1 分钟、5 分钟和 15 分钟内的平均负载。要如何解读这些负载值呢？</p>
<ul>
<li><strong>理想的负载情况</strong>：如果这三个值差不多，说明系统运行平稳，负载是均衡的。</li>
<li><strong>负载迅速增加</strong>：如果 1 分钟内的负载值远大于 15 分钟的负载值，说明系统在短时间内负载突然上升，可能表示系统正在经历某种突发的工作负载。</li>
<li><strong>负载下降</strong>：如果 1 分钟内的负载值小于 15 分钟的负载值，说明系统负载正在下降，负载压力减轻。</li>
</ul>
<p>就上面的例子而言：</p>
<ul>
<li>
<p>在过去 1 分钟内，系统的负载平均值为 0.22。</p>
</li>
<li>
<p>在过去 5 分钟内，系统的负载平均值为 0.45。</p>
</li>
<li>
<p>在过去 15 分钟内，系统的负载平均值为 0.56。</p>
</li>
</ul>
<p>这些值相差不大，表明系统负载较为平稳，没有出现过高的负载压力。</p>
</li>
</ul>
<h2 id="11-Stress-负载压力测试-v2"><a class="header-anchor" href="#11-Stress-负载压力测试-v2">¶</a>11. Stress 负载压力测试</h2>
<p><code>stress</code> 是一个常用的负载测试工具，用于模拟 CPU、内存、磁盘和 I/O 负载等各种场景。它可以帮助你进行性能测试或模拟系统的高负载状态，评估系统的稳定性。</p>
<ol>
<li>
<p><strong>安装 <code>stress</code></strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install stress</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>进行 CPU 压力测试</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --cpu 4 --<span class="built_in">timeout</span> 60s</span><br></pre></td></tr></table></figure>
<p>这条命令会启动 4 个进程，进行 60 秒的 CPU 压力测试。</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250208005755365.png" alt="image-20250208005755365"></p>
<p>其他的还有 <code>pidstat</code> 和 <code>mpstat</code>：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250208005952558.png" alt="image-20250208005952558"></p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250208010015379.png" alt="image-20250208010015379"></p>
</li>
<li>
<p><strong>内存压力测试</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --vm 2 --vm-bytes 1G --<span class="built_in">timeout</span> 60s</span><br></pre></td></tr></table></figure>
<p>启动 2 个虚拟内存进程，每个进程分配 1GB 内存，持续 60 秒。</p>
</li>
<li>
<p><strong>I/O 压力测试</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --io 4 --<span class="built_in">timeout</span> 60s</span><br></pre></td></tr></table></figure>
<p>进行 I/O 操作压力测试，启动 4 个 I/O 密集型进程，测试持续 60 秒。</p>
</li>
</ol>
<h1>四、进程信号与后台管理</h1>
<h2 id="1-使用-kill-发送信号-v2"><a class="header-anchor" href="#1-使用-kill-发送信号-v2">¶</a>1. 使用 <code>kill</code> 发送信号</h2>
<p><code>kill</code> 命令用于向进程发送信号，以请求进程终止或进行其他处理。</p>
<p><strong>基本用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> &lt;PID&gt;</span><br></pre></td></tr></table></figure>
<p>默认发送 <code>SIGTERM</code> 信号（等于加 15 信号），通常请求进程正常退出。</p>
<p><strong>强制终止</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 &lt;PID&gt;</span><br></pre></td></tr></table></figure>
<p>发送 <code>SIGKILL</code> 信号，强制立即终止进程。</p>
<p>**不关闭进程，重新加载其配置文件，如 <code>reload</code> 操作 **：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -1 &lt;PID&gt;</span><br></pre></td></tr></table></figure>
<p><code>kill</code> 命令的其他信号参数如下：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206233455373.png" alt="image-20250206233455373"></p>
<p>其中 2 信号等于中断（ <code>Ctrl + C</code>）；3 信号等于退出（<code>Ctrl + \</code>）；15 信号是终止，通常是系统关机时发送；20 信号是暂停进程（<code>Ctrl + Z</code>）。下面可以看到我们使用 <code>Ctrl + Z</code> 暂停进程后，<code>ping</code> 的进程被挂起了，使用 <code>kill</code> 并没有杀掉他，但 <code>ping</code> 并没有响应 <code>SIGTERM</code>，我们需要 <code>SIGKILL</code>（信号 9）强制终止：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206234327729.png" alt="image-20250206234327729"></p>
<p>我们可以再做个实验，在一个终端 <code>ping</code>，在另一个终端使用正常的 <code>kill</code> 命令，看是否会被杀死：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206234726903.png" alt="image-20250206234726903"></p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206234815881.png" alt="image-20250206234815881"></p>
<p>可以看到，当 <code>ping</code> 不是在暂停状态时，是可以直接被杀死的，不需要强制。</p>
<p><code>killall</code> 可以将所有同名的进程杀死，但不建议用，容易挨揍。</p>
<h2 id="2-后台运行命令-v2"><a class="header-anchor" href="#2-后台运行命令-v2">¶</a>2. 后台运行命令</h2>
<h3 id="使用-将命令放入后台-v2"><a class="header-anchor" href="#使用-将命令放入后台-v2">¶</a>使用 <code>&amp;</code> 将命令放入后台</h3>
<p><strong>基本用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./long_task.sh &amp;</span><br></pre></td></tr></table></figure>
<h3 id="使用-nohup-保证任务在注销后继续运行-v2"><a class="header-anchor" href="#使用-nohup-保证任务在注销后继续运行-v2">¶</a>使用 <code>nohup</code> 保证任务在注销后继续运行</h3>
<p>即使非正常退出，<code>nohup + &amp;</code> 的任务也还在，但如果不加 <code>nohup</code> 就不在了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ./backup.sh &amp;</span><br></pre></td></tr></table></figure>
<h3 id="bg-和-fg-v2"><a class="header-anchor" href="#bg-和-fg-v2">¶</a><code>bg</code> 和 <code>fg</code></h3>
<p><code>bg</code> 是在 <code>Ctrl + Z</code> 后将后台的程序继续运行起来，<code>fg</code> 是将前台运行的程序放到后台运行，后面接查看 <code>jobs</code> 后显示的对应进程的 <code>ID</code> 号，注意无论是不是后台运行该在终端输出的还是会输出。</p>
<h1>五、调整进程优先级</h1>
<h2 id="1-使用-nice-启动进程-v2"><a class="header-anchor" href="#1-使用-nice-启动进程-v2">¶</a>1. 使用 <code>nice</code> 启动进程</h2>
<p><code>nice</code> 命令在启动进程时指定其优先级。<code>nice</code> 值越高，进程优先级越低；<code>nice</code> 值范围通常为 -20（最高优先级）到 19（最低优先级）。</p>
<p><strong>基本用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nice</span> -n 10 ./myscript.sh</span><br></pre></td></tr></table></figure>
<p><strong>例子</strong>：</p>
<p>启动脚本 <code>myscript.sh</code> 时以 <code>nice</code> 值 10 运行，降低其对 CPU 的抢占。</p>
<h2 id="2-使用-renice-调整正在运行进程的优先级-v2"><a class="header-anchor" href="#2-使用-renice-调整正在运行进程的优先级-v2">¶</a>2. 使用 <code>renice</code> 调整正在运行进程的优先级</h2>
<p><code>renice</code> 命令用于修改已运行进程的 <code>nice</code> 值。</p>
<p><strong>基本用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice -n -5 -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>
<p><strong>例子</strong>：</p>
<p>调整进程 2345 的优先级，将 <code>nice</code> 值设置为 -5（提高优先级）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice -n -5 -p 2345</span><br></pre></td></tr></table></figure>
<h1>六、进程父子关系与特殊进程状态</h1>
<h2 id="1-进程父子关系-v2"><a class="header-anchor" href="#1-进程父子关系-v2">¶</a>1. 进程父子关系</h2>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/copy-on-write.png" alt="Redis数据持久化- Aphasia's personal blog"></p>
<ul>
<li>
<p>每个进程通过 <code>fork()</code> 调用由父进程创建。</p>
</li>
<li>
<p><strong>父进程</strong>与<strong>子进程</strong>通过 PPID（父进程 ID）关联。</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206113610023.png" alt="image-20250206113610023"></p>
<p>我们登录的 XShell 终端的流程是：</p>
<ol>
<li>系统上运行了 <code>sshd</code> 服务</li>
<li>通过 <code>ssh</code> 客户端命令都是去连接这个服务而产生的一堆子进程</li>
</ol>
<p>可以通过 <code>ps -auxf</code> 查看：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206113904636.png" alt="image-20250206113904636"></p>
<p>我们可以查看对应进程的父子关系来验证：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206114542373.png" alt="image-20250206114542373"></p>
<p><code>sshd</code> 第一行的进程是 <code>sshd</code> 服务本身，<code>sshd</code> 第二行的进程是 <code>ssh</code> 客户端，远程连接的会话进程。后续的命令都是基于 957499 这个进程生成的子进程，在 <code>bash</code> 的第三行是用户登录解释器产生的 <code>bash</code> 进程， <code>id</code> 是 957500，后续的命令又都是这个 <code>bash</code> 进程生成的子进程。</p>
</li>
</ul>
<h2 id="2-孤儿进程-v2"><a class="header-anchor" href="#2-孤儿进程-v2">¶</a>2. 孤儿进程</h2>
<p>父进程退出后（因为某些原因挂了），子进程由 <code>init</code> 或 <code>systemd</code> 接管（被 1 号进程接替，去管理这些孤儿进程的数据）。</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/63b77cb276213111b4734938.png" alt="孤儿进程流程图模板_ProcessOn思维导图、流程图"></p>
<p>具体可以运行这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">child_process</span>():</span><br><span class="line">    <span class="comment"># 第一次输出，可能仍是父进程存在时</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Child process: PID = &#123;&#125;, Parent PID = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(os.getpid(), os.getppid()))</span><br><span class="line">    <span class="comment"># 等待父进程退出（父进程突然退出后，孤儿进程会被 init 领养）</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 父进程退出后再次输出，此时父进程 PID 应该变为 1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Child process after parent&#x27;s exit: PID = &#123;&#125;, Parent PID = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(os.getpid(), os.getppid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pid = os.fork()</span><br><span class="line">    <span class="keyword">if</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 父进程分支</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Parent process: PID = &#123;&#125;, Child PID = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(os.getpid(), pid))</span><br><span class="line">        <span class="comment"># 突然退出，父进程立即结束</span></span><br><span class="line">        os._exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 子进程分支</span></span><br><span class="line">        child_process()</span><br></pre></td></tr></table></figure>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206141429890.png" alt="image-20250206141429890"></p>
<p>流程讲解：</p>
<ol>
<li>程序调用 <code>os.fork()</code> 创建子进程。
<ol>
<li>父进程中，<code>os.fork()</code> 返回子进程的 PID；</li>
<li>子进程中，返回值为 0。</li>
</ol>
</li>
<li>父进程打印自己的 PID 和子进程 PID 后，使用 <code>os._exit(0)</code> 立即退出，使子进程成为孤儿进程。</li>
<li>子进程先打印初始时的父进程 PID，再等待 3 秒（确保父进程已经退出），最后再次打印自己的 PID 和父进程 PID。此时，由于父进程已退出，操作系统会将子进程的父进程设置为 <code>init</code>（在大多数系统中，其 PID 为 1）。</li>
</ol>
<h2 id="3-僵尸进程-v2"><a class="header-anchor" href="#3-僵尸进程-v2">¶</a>3. 僵尸进程</h2>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/GIqlONjnXBrkuRz4DXxSdr0WBeSmud5olIwsN9w7B3TRy6IBNgaqaRphuj4PB2194l89F9vjp6GHteXc3txRX5SDJMQVgN6m76YejCRl32TfGJQ.png" alt="僵尸进程（Zombie Process） – 常量笔记"></p>
<ul>
<li>进程退出后，内核保留其退出状态，等待父进程回收；</li>
<li>父进程若不调用 wait()，子进程则成为僵尸；</li>
<li>僵尸进程不会占用大量资源，但过多会耗尽系统进程表。</li>
</ul>
<p><strong>查看方式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&#x27; Z &#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>具体例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    pid = os.fork()</span><br><span class="line">    <span class="keyword">if</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 父进程</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Parent process: PID = &#123;&#125;, Child PID = &#123;&#125; (child will become zombie)&quot;</span>.<span class="built_in">format</span>(os.getpid(), pid))</span><br><span class="line">        <span class="comment"># 父进程暂停 15 秒，在此期间子进程已退出但未被回收，处于僵尸状态</span></span><br><span class="line">        time.sleep(<span class="number">15</span>)</span><br><span class="line">        <span class="comment"># 最后回收僵尸进程</span></span><br><span class="line">        os.wait()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Zombie child has been reaped.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 子进程</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Child process: PID = &#123;&#125;, Parent PID = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(os.getpid(), os.getppid()))</span><br><span class="line">        <span class="comment"># 子进程立即退出，进入僵尸状态（直到父进程调用 wait()）</span></span><br><span class="line">        os._exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>在调用 <code>os.fork()</code> 后，实际上会产生两个独立的进程：一个是父进程，一个是子进程。这两个进程都会从 <code>os.fork()</code> 这一行开始继续执行接下来的代码，但它们各自拥有不同的返回值：</p>
<ul>
<li><strong>在父进程中</strong>：<code>os.fork()</code> 返回的是子进程的 PID（一个正整数），因此条件 <code>if pid &gt; 0</code> 为真，父进程会执行 if 分支的代码。</li>
<li><strong>在子进程中</strong>：<code>os.fork()</code> 返回 0，所以条件 <code>if pid &gt; 0</code> 为假，子进程会执行 <code>else</code> 分支的代码。<code>os.wait()</code> 会使父进程等待任一子进程结束，并收集其退出状态（也称为回收僵尸进程）。当父进程执行到这行代码时，之前已经退出的子进程将被系统正式回收，其“僵尸状态”消失。</li>
</ul>
<p>这两个进程是并行运行的，它们共享同一段代码，但各自根据 <code>os.fork()</code> 返回的不同值来选择不同的执行路径。这样就可以同时看到父进程和子进程的输出，而它们的 PID 值分别反映了各自的情况（父进程得到子进程的 PID，子进程得到 0）。</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206142957326.png" alt="image-20250206142957326"></p>
<p>上面的代码运行期间，我们可以在另一个窗口通过 <code>ps aux | grep Z</code> 观察到子进程变成僵尸进程（状态为 “Z”）：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206142932763.png" alt="image-20250206142932763"></p>
<h1>七、挂载点的理解与实例详解</h1>
<p>在 Linux 中，整个文件系统是一个统一的目录树，所有的文件和目录都位于根目录 <code>/</code> 下。挂载点（Mount Point）就是在这个目录树中预先创建的一个空目录，用于将其他存储设备（例如硬盘分区、USB 驱动器、网络文件系统等）的文件系统“挂载”到这个目录上，从而将这些外部文件系统整合到主文件系统中，实现统一管理和访问。</p>
<h2 id="1-挂载点的基本概念-v2"><a class="header-anchor" href="#1-挂载点的基本概念-v2">¶</a>1. 挂载点的基本概念</h2>
<ul>
<li>
<p><strong>统一文件树</strong><br>
Linux 的设计理念是“一切皆文件”，整个系统都被构造为一个单一的目录树。无论是系统硬盘、外接存储设备，还是网络文件系统，最终都可以通过挂载点呈现在同一个目录结构中。</p>
</li>
<li>
<p><strong>挂载操作</strong><br>
挂载就是把一个独立的文件系统连接到现有目录树的某个目录上，使得这个目录成为访问该文件系统的入口。挂载完成后，用户访问该目录时，实际上访问的是挂载的设备中的文件。</p>
</li>
<li>
<p><strong>卸载操作</strong><br>
卸载（umount）则是将挂载的设备从目录树中移除。在卸载之前，必须确保没有进程在使用挂载点，否则卸载操作会失败。</p>
</li>
</ul>
<h2 id="2-常见的挂载点示例-v2"><a class="header-anchor" href="#2-常见的挂载点示例-v2">¶</a>2. 常见的挂载点示例</h2>
<ul>
<li>
<p><strong>根目录 (<code>/</code>)</strong><br>
整个系统的根，所有挂载的文件系统最终都挂载在根目录下。例如，系统安装盘通常直接挂载在 <code>/</code> 上。</p>
</li>
<li>
<p><strong>临时挂载目录 (<code>/mnt</code> 或 <code>/media</code>)</strong><br>
用于临时挂载外部设备。例如，当你插入一个 USB 驱动器时，系统可能自动将其挂载到 <code>/media/username/USB_DRIVE</code> 或你手动将其挂载到 <code>/mnt/usb</code>。</p>
</li>
<li>
<p><strong>自定义挂载点</strong><br>
在服务器环境中，经常为不同用途创建专用挂载点，如 <code>/data</code> 用于存储用户数据，<code>/backup</code> 用于备份文件。这样不仅方便管理，还能根据设备性能合理分配任务（例如将高性能 SSD 挂载在数据库目录下，而将大容量 HDD 用于存储日志文件）。</p>
</li>
</ul>
<h2 id="3-挂载命令与操作示例-v2"><a class="header-anchor" href="#3-挂载命令与操作示例-v2">¶</a>3. 挂载命令与操作示例</h2>
<ul>
<li><strong>挂载设备</strong><br>
使用 <code>mount</code> 命令将设备挂载到指定目录。例如，将设备 <code>/dev/sdb1</code> 挂载到 <code>/mnt/data</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  mount /dev/sdb1 /mnt/data</span><br><span class="line"></span><br><span class="line">​		挂载后，访问 /mnt/data 就相当于访问 /dev/sdb1 中的所有文件。</span><br><span class="line"></span><br><span class="line">* **查看当前挂载情况**</span><br><span class="line"></span><br><span class="line">  使用 `mount` 或 `findmnt` 查看当前所有挂载的设备及其挂载点：</span><br><span class="line"></span><br><span class="line">  ```bash</span><br><span class="line">  mount</span><br><span class="line">  findmnt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>
<p><strong>卸载设备</strong></p>
<p>使用 <code>umount</code> 命令卸载挂载的文件系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /mnt/data</span><br></pre></td></tr></table></figure>
<p>注意：在卸载前必须确保没有进程正在使用 /mnt/data。</p>
</li>
</ul>
<h2 id="4-挂载点在系统管理中的作用-v2"><a class="header-anchor" href="#4-挂载点在系统管理中的作用-v2">¶</a>4. 挂载点在系统管理中的作用</h2>
<ul>
<li>
<p><strong>数据整合</strong></p>
<p>挂载点允许管理员将不同物理设备的文件系统整合到一个统一的目录结构中，便于统一管理。例如，数据库文件可以挂载在一个专用分区（例如 /var/lib/mysql），而用户数据则挂载在另一个分区（例如 /data）。</p>
</li>
<li>
<p><strong>性能优化</strong></p>
<p>将性能要求高的应用挂载到高性能设备上（如固态硬盘），而大容量但速度较慢的设备则用于存储归档数据，合理规划存储策略。</p>
</li>
<li>
<p><strong>备份与恢复</strong></p>
<p>利用挂载点，可以将外部备份设备挂载到系统中，实现数据的备份与恢复，而无需改变系统的目录结构。</p>
</li>
</ul>
<h1>八、综合应用</h1>
<p>Nginx 日志非常重要，可以帮助我们查看是否有一些异常的 IP 在进行非授权的访问，例如访问 admin 或者试图访问一些敏感的后台管理文件夹：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206233125034.png" alt="image-20250206233125034"></p>
<p>误删除 nginx 日志文件夹后恢复操作：</p>
<p><img src="/en/Linux%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20250206233055035.png" alt="image-20250206233055035"></p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：Linux 进程与资源管理</li>
        <li>Post author：Chen Kai</li>
        <li>Create time：2025-02-08 00:00:00</li>
        <li>
            Post link：https://www.chenk.top//en/Linux 进程与资源管理/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/en/tags/Linux/">#Linux</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/en/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/">#云计算</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/en/Linux%20%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Linux 软件包管理</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/Linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Linux 文件操作深入解析</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情赞美帅气伟大的ck吧~',
                    lang: 'en'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">一、进程与程序管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB-v2"><span class="nav-number">1.1.</span> <span class="nav-text">1. 进程与程序之间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9-v2"><span class="nav-number">1.2.</span> <span class="nav-text">2. 进程的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%80%A7%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%80%A7-v2"><span class="nav-number">1.2.1.</span> <span class="nav-text">进程的独立性与并发性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-v3"><span class="nav-number">1.2.2.</span> <span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">二、Linux 系统资源管理概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-v2"><span class="nav-number">2.1.</span> <span class="nav-text">1. 硬件资源管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BD%AF%E4%BB%B6%E8%B5%84%E6%BA%90%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86-v2"><span class="nav-number">2.2.</span> <span class="nav-text">2. 软件资源与服务管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Buffer-%E5%92%8C-Cache-%E8%AE%B2%E8%A7%A3-v2"><span class="nav-number">2.3.</span> <span class="nav-text">3. Buffer 和 Cache 讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%80%A7%E8%83%BD-v2"><span class="nav-number">2.3.1.</span> <span class="nav-text">缓存与性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer%EF%BC%88%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E6%97%B6%E5%8A%A0%E9%80%9F%EF%BC%89-v2"><span class="nav-number">2.3.2.</span> <span class="nav-text">Buffer（写入数据时加速）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache%EF%BC%88%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%97%B6%E5%8A%A0%E9%80%9F%EF%BC%89-v2"><span class="nav-number">2.3.3.</span> <span class="nav-text">Cache（读取数据时加速）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">三、进程监控工具详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8-top-%E5%8A%A8%E6%80%81%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF-v2"><span class="nav-number">3.1.</span> <span class="nav-text">1. 使用 top 动态查看进程信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-htop-%E5%A2%9E%E5%BC%BA%E7%9B%91%E6%8E%A7%E4%BD%93%E9%AA%8C-v2"><span class="nav-number">3.2.</span> <span class="nav-text">2. 使用 htop 增强监控体验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8-ps-%E9%9D%99%E6%80%81%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF-v2"><span class="nav-number">3.3.</span> <span class="nav-text">3. 使用 ps 静态查看进程信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8-pstree-%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B%E6%A0%91-v2"><span class="nav-number">3.4.</span> <span class="nav-text">4. 使用 pstree 显示进程树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%BD%BF%E7%94%A8-pidof-%E6%9F%A5%E6%89%BE%E8%BF%9B%E7%A8%8B-PID-v2"><span class="nav-number">3.5.</span> <span class="nav-text">5. 使用 pidof 查找进程 PID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E4%BD%BF%E7%94%A8-lsof-%E6%9F%A5%E7%9C%8B%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6-v2"><span class="nav-number">3.6.</span> <span class="nav-text">6. 使用 lsof 查看打开的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E4%B8%8E%E7%AB%AF%E5%8F%A3%E7%9B%91%E6%8E%A7-v2"><span class="nav-number">3.7.</span> <span class="nav-text">7. 网络流量与端口监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%A3%81%E7%9B%98-I-O-%E6%9F%A5%E7%9C%8B-v2"><span class="nav-number">3.8.</span> <span class="nav-text">8. 磁盘 I&#x2F;O 查看</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%86%85%E5%AD%98%E8%B5%84%E6%BA%90%E6%9F%A5%E7%9C%8B-free-v2"><span class="nav-number">3.9.</span> <span class="nav-text">9. 内存资源查看 free</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-CPU-%E4%B8%8E%E8%B4%9F%E8%BD%BD%E7%AE%A1%E7%90%86-v2"><span class="nav-number">3.10.</span> <span class="nav-text">10. CPU 与负载管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-Stress-%E8%B4%9F%E8%BD%BD%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-v2"><span class="nav-number">3.11.</span> <span class="nav-text">11. Stress 负载压力测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">四、进程信号与后台管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8-kill-%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7-v2"><span class="nav-number">4.1.</span> <span class="nav-text">1. 使用 kill 发送信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4-v2"><span class="nav-number">4.2.</span> <span class="nav-text">2. 后台运行命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-%E5%B0%86%E5%91%BD%E4%BB%A4%E6%94%BE%E5%85%A5%E5%90%8E%E5%8F%B0-v2"><span class="nav-number">4.2.1.</span> <span class="nav-text">使用 &amp; 将命令放入后台</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-nohup-%E4%BF%9D%E8%AF%81%E4%BB%BB%E5%8A%A1%E5%9C%A8%E6%B3%A8%E9%94%80%E5%90%8E%E7%BB%A7%E7%BB%AD%E8%BF%90%E8%A1%8C-v2"><span class="nav-number">4.2.2.</span> <span class="nav-text">使用 nohup 保证任务在注销后继续运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bg-%E5%92%8C-fg-v2"><span class="nav-number">4.2.3.</span> <span class="nav-text">bg 和 fg</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">5.</span> <span class="nav-text">五、调整进程优先级</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8-nice-%E5%90%AF%E5%8A%A8%E8%BF%9B%E7%A8%8B-v2"><span class="nav-number">5.1.</span> <span class="nav-text">1. 使用 nice 启动进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-renice-%E8%B0%83%E6%95%B4%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7-v2"><span class="nav-number">5.2.</span> <span class="nav-text">2. 使用 renice 调整正在运行进程的优先级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">6.</span> <span class="nav-text">六、进程父子关系与特殊进程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%BF%9B%E7%A8%8B%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB-v2"><span class="nav-number">6.1.</span> <span class="nav-text">1. 进程父子关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B-v2"><span class="nav-number">6.2.</span> <span class="nav-text">2. 孤儿进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B-v2"><span class="nav-number">6.3.</span> <span class="nav-text">3. 僵尸进程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">7.</span> <span class="nav-text">七、挂载点的理解与实例详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%8C%82%E8%BD%BD%E7%82%B9%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-v2"><span class="nav-number">7.1.</span> <span class="nav-text">1. 挂载点的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8C%82%E8%BD%BD%E7%82%B9%E7%A4%BA%E4%BE%8B-v2"><span class="nav-number">7.2.</span> <span class="nav-text">2. 常见的挂载点示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%8C%82%E8%BD%BD%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B-v2"><span class="nav-number">7.3.</span> <span class="nav-text">3. 挂载命令与操作示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%8C%82%E8%BD%BD%E7%82%B9%E5%9C%A8%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8-v2"><span class="nav-number">7.4.</span> <span class="nav-text">4. 挂载点在系统管理中的作用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">8.</span> <span class="nav-text">八、综合应用</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
