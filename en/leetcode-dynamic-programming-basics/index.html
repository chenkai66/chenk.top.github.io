<!DOCTYPE html>



<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode (6): Dynamic Programming Basics |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"en","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/en/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode (6): Dynamic Programming Basics</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-05-29 00:00:00</span>
        <span class="mobile">2022-05-29 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/en/tags/Algorithms/">Algorithms</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/en/tags/Dynamic-Programming/">Dynamic Programming</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>3.6k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>22 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>Dynamic Programming (DP) is one of the most powerful problem-solving
paradigms in computer science. While it might seem intimidating at
first, understanding its core principles and patterns can transform how
you approach optimization problems. This article will guide you through
the fundamentals of dynamic programming, from the theoretical
foundations to practical LeetCode problem-solving strategies.</p>
<span id="more"></span>
<h2 id="what-is-dynamic-programming">What is Dynamic Programming?</h2>
<p>Dynamic Programming is a method for solving complex problems by
breaking them down into simpler subproblems. The key insight is that
instead of solving the same subproblem multiple times, we solve it once
and store the result for future use. This approach dramatically improves
efficiency for problems that exhibit two critical properties:
<strong>optimal substructure</strong> and <strong>overlapping
subproblems</strong>.</p>
<p>The term "dynamic programming" was coined by Richard Bellman in the
1950s. Interestingly, Bellman chose this name not because the method
involves dynamic or changing behavior, but rather to make it sound
impressive enough to secure funding. Despite its somewhat misleading
name, DP has become one of the most fundamental techniques in algorithm
design.</p>
<h2 id="core-principles">Core Principles</h2>
<h3 id="optimal-substructure">Optimal Substructure</h3>
<p>A problem exhibits <strong>optimal substructure</strong> if an
optimal solution to the problem contains optimal solutions to its
subproblems. In other words, if we can solve the problem optimally by
combining optimal solutions to smaller problems, then the problem has
optimal substructure.</p>
<p>Consider the classic example of finding the shortest path in a graph.
If the shortest path from node A to node C goes through node B, then the
path from A to B must be the shortest path from A to B, and the path
from B to C must be the shortest path from B to C. This property allows
us to build solutions incrementally.</p>
<p><strong>Example</strong>: In the Fibonacci sequence, <span class="math inline">\(F(n) = F(n-1) + F(n-2)\)</span>. The optimal
solution for <span class="math inline">\(F(n)\)</span> depends on the
optimal solutions for <span class="math inline">\(F(n-1)\)</span> and
<span class="math inline">\(F(n-2)\)</span>.</p>
<h3 id="overlapping-subproblems">Overlapping Subproblems</h3>
<p>A problem has <strong>overlapping subproblems</strong> if the same
subproblem is solved multiple times during the computation. This is
where DP shines—instead of recalculating the same values repeatedly, we
store results in a table (memoization) and reuse them.</p>
<p><strong>Example</strong>: When computing <span class="math inline">\(F(5)\)</span> recursively: - <span class="math inline">\(F(5) = F(4) + F(3)\)</span> - <span class="math inline">\(F(4) = F(3) + F(2)\)</span> - <span class="math inline">\(F(3) = F(2) + F(1)\)</span></p>
<p>Notice that <span class="math inline">\(F(3)\)</span> and <span class="math inline">\(F(2)\)</span> are computed multiple times. This
redundancy is exactly what DP eliminates.</p>
<h3 id="when-to-use-dynamic-programming">When to Use Dynamic
Programming</h3>
<p>DP is most effective when: 1. The problem can be broken down into
smaller subproblems 2. These subproblems overlap (same subproblem
appears multiple times) 3. The problem has optimal substructure (optimal
solution uses optimal subproblem solutions) 4. You need to find an
optimal value (maximum, minimum, count, etc.) rather than all possible
solutions</p>
<h2 id="the-three-step-dp-process">The Three-Step DP Process</h2>
<p>Every DP problem can be approached systematically using these three
steps:</p>
<h3 id="step-1-define-the-state">Step 1: Define the State</h3>
<p>The <strong>state</strong> represents a subproblem. You need to
identify: - What information you need to track - What parameters
uniquely identify a subproblem - What the state represents (usually the
answer to a subproblem)</p>
<p><strong>Example</strong>: For climbing stairs, the state
<code>dp[i]</code> represents "the number of ways to reach step <span class="math inline">\(i\)</span>".</p>
<h3 id="step-2-find-the-state-transition">Step 2: Find the State
Transition</h3>
<p>The <strong>state transition</strong> (recurrence relation) describes
how to compute a state from previous states. This is the heart of DP—it
captures the relationship between subproblems.</p>
<p><strong>Example</strong>: For climbing stairs,
<code>dp[i] = dp[i-1] + dp[i-2]</code> because you can reach step <span class="math inline">\(i\)</span> from step <span class="math inline">\(i-1\)</span> or step <span class="math inline">\(i-2\)</span>.</p>
<h3 id="step-3-determine-base-cases-and-initialization">Step 3:
Determine Base Cases and Initialization</h3>
<p><strong>Base cases</strong> are the smallest subproblems that can be
solved directly without recursion. They prevent infinite recursion and
provide starting points for building up solutions.</p>
<p><strong>Example</strong>: For climbing stairs, <code>dp[0] = 1</code>
(one way to stay at ground level) and <code>dp[1] = 1</code> (one way to
reach the first step).</p>
<h2 id="one-dimensional-dynamic-programming">One-Dimensional Dynamic
Programming</h2>
<p>One-dimensional DP problems use a single array to store subproblem
solutions. The state typically depends on a single parameter (usually
position or index).</p>
<h3 id="problem-1-climbing-stairs">Problem 1: Climbing Stairs</h3>
<p><strong>LeetCode 70</strong>: You are climbing a staircase. It takes
<span class="math inline">\(n\)</span> steps to reach the top. Each time
you can either climb 1 or 2 steps. In how many distinct ways can you
climb to the top?</p>
<p><strong>Analysis</strong>: - <strong>State</strong>:
<code>dp[i]</code> = number of ways to reach step <span class="math inline">\(i\)</span> - <strong>Transition</strong>:
<code>dp[i] = dp[i-1] + dp[i-2]</code> (can come from step <span class="math inline">\(i-1\)</span> or <span class="math inline">\(i-2\)</span>) - <strong>Base cases</strong>:
<code>dp[0] = 1</code>, <code>dp[1] = 1</code></p>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: <span class="math inline">\(O(n)\)</span> - single pass through the
array<br>
<strong>Space Complexity</strong>: <span class="math inline">\(O(n)\)</span> - DP array of size <span class="math inline">\(n+1\)</span></p>
<p><strong>Space Optimization</strong>: Since we only need the last two
values, we can reduce space to <span class="math inline">\(O(1)\)</span>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    prev2 = <span class="number">1</span>  <span class="comment"># dp[0]</span></span><br><span class="line">    prev1 = <span class="number">1</span>  <span class="comment"># dp[1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        current = prev1 + prev2</span><br><span class="line">        prev2 = prev1</span><br><span class="line">        prev1 = current</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure>
<h3 id="problem-2-house-robber">Problem 2: House Robber</h3>
<p><strong>LeetCode 198</strong>: You are a professional robber planning
to rob houses along a street. Each house has a certain amount of money
stashed. You cannot rob two adjacent houses. Determine the maximum
amount of money you can rob tonight.</p>
<p><strong>Analysis</strong>: - <strong>State</strong>:
<code>dp[i]</code> = maximum money that can be robbed from houses <span class="math inline">\(0\)</span> to <span class="math inline">\(i\)</span> - <strong>Transition</strong>: At house
<span class="math inline">\(i\)</span>, we have two choices: - Rob house
<span class="math inline">\(i\)</span>:
<code>dp[i] = nums[i] + dp[i-2]</code> - Skip house <span class="math inline">\(i\)</span>: <code>dp[i] = dp[i-1]</code> - Take
the maximum: <code>dp[i] = max(nums[i] + dp[i-2], dp[i-1])</code> -
<strong>Base cases</strong>: <code>dp[0] = nums[0]</code>,
<code>dp[1] = max(nums[0], nums[1])</code></p>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(nums[i] + dp[i-<span class="number">2</span>], dp[i-<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: <span class="math inline">\(O(n)\)</span><br>
<strong>Space Complexity</strong>: <span class="math inline">\(O(n)\)</span>, optimizable to <span class="math inline">\(O(1)\)</span></p>
<p><strong>Space-Optimized Version</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    prev2 = nums[<span class="number">0</span>]</span><br><span class="line">    prev1 = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        current = <span class="built_in">max</span>(nums[i] + prev2, prev1)</span><br><span class="line">        prev2 = prev1</span><br><span class="line">        prev1 = current</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure>
<h3 id="problem-3-best-time-to-buy-and-sell-stock">Problem 3: Best Time
to Buy and Sell Stock</h3>
<p><strong>LeetCode 121</strong>: You are given an array
<code>prices</code> where <code>prices[i]</code> is the price of a given
stock on day <span class="math inline">\(i\)</span>. You want to
maximize your profit by choosing a single day to buy one stock and
choosing a different day in the future to sell that stock. Return the
maximum profit you can achieve.</p>
<p><strong>Analysis</strong>: - <strong>State</strong>:
<code>dp[i]</code> = maximum profit achievable up to day <span class="math inline">\(i\)</span> - <strong>Transition</strong>: - Track
the minimum price seen so far:
<code>min_price = min(min_price, prices[i])</code> - Calculate profit if
selling today: <code>profit = prices[i] - min_price</code> - Update
maximum: <code>dp[i] = max(dp[i-1], profit)</code> - <strong>Base
case</strong>: <code>dp[0] = 0</code> (no profit on first day)</p>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">prices</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    min_price = prices[<span class="number">0</span>]</span><br><span class="line">    max_profit = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">        min_price = <span class="built_in">min</span>(min_price, prices[i])</span><br><span class="line">        max_profit = <span class="built_in">max</span>(max_profit, prices[i] - min_price)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: <span class="math inline">\(O(n)\)</span><br>
<strong>Space Complexity</strong>: <span class="math inline">\(O(1)\)</span></p>
<p><strong>Alternative DP Approach</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">prices</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(prices)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># dp[i] = max profit up to day i</span></span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    min_price = prices[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        min_price = <span class="built_in">min</span>(min_price, prices[i])</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], prices[i] - min_price)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="problem-4-coin-change">Problem 4: Coin Change</h3>
<p><strong>LeetCode 322</strong>: You are given an integer array
<code>coins</code> representing coins of different denominations and an
integer <code>amount</code> representing a total amount of money. Return
the fewest number of coins that you need to make up that amount. If that
amount of money cannot be made up by any combination of the coins,
return <span class="math inline">\(-1\)</span>.</p>
<p><strong>Analysis</strong>: - <strong>State</strong>:
<code>dp[i]</code> = minimum number of coins needed to make amount <span class="math inline">\(i\)</span> - <strong>Transition</strong>: For each
coin denomination, try using it: -
<code>dp[i] = min(dp[i], dp[i - coin] + 1)</code> for all valid coins -
<strong>Base case</strong>: <code>dp[0] = 0</code> (0 coins needed for
amount 0)</p>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">coins, amount</span>):</span><br><span class="line">    <span class="comment"># Initialize with amount + 1 (impossible value)</span></span><br><span class="line">    dp = [amount + <span class="number">1</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> coin &lt;= i:</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coin] + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != amount + <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: <span class="math inline">\(O(amount \times len(coins))\)</span><br>
<strong>Space Complexity</strong>: <span class="math inline">\(O(amount)\)</span></p>
<h2 id="two-dimensional-dynamic-programming">Two-Dimensional Dynamic
Programming</h2>
<p>Two-dimensional DP problems use a 2D table where the state depends on
two parameters. These are often more complex but follow the same
principles.</p>
<h3 id="problem-5-longest-common-subsequence-lcs">Problem 5: Longest
Common Subsequence (LCS)</h3>
<p><strong>LeetCode 1143</strong>: Given two strings <code>text1</code>
and <code>text2</code>, return the length of their longest common
subsequence. A subsequence is a sequence that appears in the same
relative order, but not necessarily contiguous.</p>
<p><strong>Analysis</strong>: - <strong>State</strong>:
<code>dp[i][j]</code> = length of LCS of <code>text1[0:i]</code> and
<code>text2[0:j]</code> - <strong>Transition</strong>: - If
<code>text1[i-1] == text2[j-1]</code>:
<code>dp[i][j] = dp[i-1][j-1] + 1</code> - Otherwise:
<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code> - <strong>Base
cases</strong>: <code>dp[0][j] = 0</code>, <code>dp[i][0] = 0</code>
(empty string has LCS length 0)</p>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">text1, text2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: <span class="math inline">\(O(m
\times n)\)</span><br>
<strong>Space Complexity</strong>: <span class="math inline">\(O(m
\times n)\)</span>, optimizable to <span class="math inline">\(O(min(m,
n))\)</span></p>
<p><strong>Space-Optimized Version</strong> (using only previous
row):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">text1, text2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">    <span class="keyword">if</span> m &lt; n:</span><br><span class="line">        text1, text2 = text2, text1</span><br><span class="line">        m, n = n, m</span><br><span class="line">    </span><br><span class="line">    prev = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        curr = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>]:</span><br><span class="line">                curr[j] = prev[j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr[j] = <span class="built_in">max</span>(prev[j], curr[j-<span class="number">1</span>])</span><br><span class="line">        prev = curr</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prev[n]</span><br></pre></td></tr></table></figure>
<h3 id="problem-6-edit-distance">Problem 6: Edit Distance</h3>
<p><strong>LeetCode 72</strong>: Given two strings <code>word1</code>
and <code>word2</code>, return the minimum number of operations required
to convert <code>word1</code> to <code>word2</code>. You have three
operations permitted: insert a character, delete a character, or replace
a character.</p>
<p><strong>Analysis</strong>: - <strong>State</strong>:
<code>dp[i][j]</code> = minimum operations to convert
<code>word1[0:i]</code> to <code>word2[0:j]</code> -
<strong>Transition</strong>: - If <code>word1[i-1] == word2[j-1]</code>:
<code>dp[i][j] = dp[i-1][j-1]</code> (no operation needed) - Otherwise,
take minimum of: - Insert: <code>dp[i][j-1] + 1</code> - Delete:
<code>dp[i-1][j] + 1</code> - Replace: <code>dp[i-1][j-1] + 1</code> -
<strong>Base cases</strong>: - <code>dp[0][j] = j</code> (insert all
characters) - <code>dp[i][0] = i</code> (delete all characters)</p>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">word1, word2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Base cases</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        dp[i][<span class="number">0</span>] = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = j</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(</span><br><span class="line">                    dp[i-<span class="number">1</span>][j] + <span class="number">1</span>,      <span class="comment"># delete</span></span><br><span class="line">                    dp[i][j-<span class="number">1</span>] + <span class="number">1</span>,      <span class="comment"># insert</span></span><br><span class="line">                    dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>     <span class="comment"># replace</span></span><br><span class="line">                )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: <span class="math inline">\(O(m
\times n)\)</span><br>
<strong>Space Complexity</strong>: <span class="math inline">\(O(m
\times n)\)</span>, optimizable to <span class="math inline">\(O(min(m,
n))\)</span></p>
<h3 id="problem-7-01-knapsack-problem">Problem 7: 0/1 Knapsack
Problem</h3>
<p><strong>Problem</strong>: Given weights and values of <span class="math inline">\(n\)</span> items, put these items in a knapsack of
capacity <span class="math inline">\(W\)</span> to get the maximum total
value. Each item can be used at most once.</p>
<p><strong>Analysis</strong>: - <strong>State</strong>:
<code>dp[i][w]</code> = maximum value achievable with first <span class="math inline">\(i\)</span> items and weight capacity <span class="math inline">\(w\)</span> - <strong>Transition</strong>: - If
item <span class="math inline">\(i\)</span> doesn't fit:
<code>dp[i][w] = dp[i-1][w]</code> - Otherwise:
<code>dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])</code>
- <strong>Base cases</strong>: <code>dp[0][w] = 0</code> (no items, no
value)</p>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(weights)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (capacity + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, capacity + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> weights[i-<span class="number">1</span>] &gt; w:</span><br><span class="line">                dp[i][w] = dp[i-<span class="number">1</span>][w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(</span><br><span class="line">                    dp[i-<span class="number">1</span>][w],</span><br><span class="line">                    dp[i-<span class="number">1</span>][w - weights[i-<span class="number">1</span>]] + values[i-<span class="number">1</span>]</span><br><span class="line">                )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n][capacity]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: <span class="math inline">\(O(n
\times capacity)\)</span><br>
<strong>Space Complexity</strong>: <span class="math inline">\(O(n
\times capacity)\)</span>, optimizable to <span class="math inline">\(O(capacity)\)</span></p>
<p><strong>Space-Optimized Version</strong> (using 1D array, iterating
backwards):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(weights)</span><br><span class="line">    dp = [<span class="number">0</span>] * (capacity + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># Iterate backwards to avoid using updated values</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(capacity, weights[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weights[i]] + values[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[capacity]</span><br></pre></td></tr></table></figure>
<h2 id="space-optimization-techniques">Space Optimization
Techniques</h2>
<p>Space optimization is crucial for DP problems, especially in
competitive programming where memory constraints matter. Here are common
techniques:</p>
<h3 id="rolling-array-1d-to-variables">1. Rolling Array (1D to
Variables)</h3>
<p>When only the last few values are needed, replace arrays with
variables:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Before: O(n) space</span></span><br><span class="line">dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># After: O(1) space</span></span><br><span class="line">prev2, prev1 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">current = prev1 + prev2</span><br></pre></td></tr></table></figure>
<h3 id="d-to-1d-row-by-row-processing">2. 2D to 1D (Row-by-Row
Processing)</h3>
<p>When only the previous row is needed, use a 1D array:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Before: O(m*n) space</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># After: O(n) space</span></span><br><span class="line">prev = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">curr = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># Process row by row</span></span><br></pre></td></tr></table></figure>
<h3 id="backward-iteration-for-1d-optimization">3. Backward Iteration
for 1D Optimization</h3>
<p>For knapsack-like problems, iterate backwards to avoid overwriting
values:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Forward iteration (wrong for knapsack)</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(weights[i], capacity + <span class="number">1</span>):</span><br><span class="line">    dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weights[i]] + values[i])</span><br><span class="line">    <span class="comment"># dp[w - weights[i]] might have been updated in this iteration!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Backward iteration (correct)</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(capacity, weights[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weights[i]] + values[i])</span><br><span class="line">    <span class="comment"># dp[w - weights[i]] hasn&#x27;t been updated yet</span></span><br></pre></td></tr></table></figure>
<h2 id="dp-vs-recursion-vs-memoization">DP vs Recursion vs
Memoization</h2>
<p>Understanding the relationship between these concepts is crucial:</p>
<h3 id="pure-recursion">Pure Recursion</h3>
<p>Recursive solution without optimization:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: <span class="math inline">\(O(2^n)\)</span> (exponential)<br>
<strong>Space Complexity</strong>: <span class="math inline">\(O(n)\)</span> (call stack)</p>
<h3 id="memoization-top-down-dp">Memoization (Top-Down DP)</h3>
<p>Store results of recursive calls:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n, memo=&#123;&#125;</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    memo[n] = fib(n-<span class="number">1</span>, memo) + fib(n-<span class="number">2</span>, memo)</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: <span class="math inline">\(O(n)\)</span><br>
<strong>Space Complexity</strong>: <span class="math inline">\(O(n)\)</span> (memo + call stack)</p>
<h3 id="tabulation-bottom-up-dp">Tabulation (Bottom-Up DP)</h3>
<p>Build solution iteratively from base cases:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: <span class="math inline">\(O(n)\)</span><br>
<strong>Space Complexity</strong>: <span class="math inline">\(O(n)\)</span>, optimizable to <span class="math inline">\(O(1)\)</span></p>
<h3 id="comparison">Comparison</h3>
<table>
<colgroup>
<col style="width: 28%">
<col style="width: 17%">
<col style="width: 20%">
<col style="width: 17%">
<col style="width: 17%">
</colgroup>
<thead>
<tr>
<th>Approach</th>
<th>Time</th>
<th>Space</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr>
<td>Recursion</td>
<td><span class="math inline">\(O(2^n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>Intuitive, natural</td>
<td>Exponential time</td>
</tr>
<tr>
<td>Memoization</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>Natural recursion, avoids recomputation</td>
<td>Stack overflow risk</td>
</tr>
<tr>
<td>Tabulation</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(1)\)</span></td>
<td>No stack overflow, space optimizable</td>
<td>Less intuitive</td>
</tr>
</tbody>
</table>
<p><strong>When to use each</strong>: - <strong>Recursion</strong>: Only
for small inputs or when clarity matters more than performance -
<strong>Memoization</strong>: When the recursive structure is natural
and you want to preserve it - <strong>Tabulation</strong>: Preferred for
competitive programming, better space optimization, no stack
overflow</p>
<h2 id="complexity-analysis">Complexity Analysis</h2>
<h3 id="time-complexity">Time Complexity</h3>
<p>For DP problems, time complexity is typically: - <strong>1D
DP</strong>: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(n \times k)\)</span> where <span class="math inline">\(k\)</span> is the number of choices per state -
<strong>2D DP</strong>: <span class="math inline">\(O(m \times
n)\)</span> or <span class="math inline">\(O(m \times n \times
k)\)</span> - <strong>General</strong>: <span class="math inline">\(O(\text{number of states} \times \text{work per
state})\)</span></p>
<h3 id="space-complexity">Space Complexity</h3>
<ul>
<li><strong>Original</strong>: <span class="math inline">\(O(\text{number of states})\)</span></li>
<li><strong>Optimized</strong>: Often reducible to <span class="math inline">\(O(1)\)</span> for 1D or <span class="math inline">\(O(min(m,n))\)</span> for 2D</li>
</ul>
<h3 id="example-analysis-coin-change">Example Analysis: Coin Change</h3>
<ul>
<li><strong>States</strong>: <span class="math inline">\(O(amount)\)</span> states (one for each amount
from 0 to amount)</li>
<li><strong>Work per state</strong>: <span class="math inline">\(O(len(coins))\)</span> (try each coin)</li>
<li><strong>Time</strong>: <span class="math inline">\(O(amount \times
len(coins))\)</span></li>
<li><strong>Space</strong>: <span class="math inline">\(O(amount)\)</span></li>
</ul>
<h2 id="common-dp-patterns">Common DP Patterns</h2>
<h3 id="pattern-1-linear-dp">Pattern 1: Linear DP</h3>
<p>State depends on a single dimension (position, time, etc.):</p>
<ul>
<li>Climbing Stairs</li>
<li>House Robber</li>
<li>Maximum Subarray</li>
</ul>
<h3 id="pattern-2-interval-dp">Pattern 2: Interval DP</h3>
<p>Process intervals of increasing length:</p>
<ul>
<li>Palindrome Partitioning</li>
<li>Burst Balloons</li>
<li>Matrix Chain Multiplication</li>
</ul>
<h3 id="pattern-3-tree-dp">Pattern 3: Tree DP</h3>
<p>DP on trees, often with DFS:</p>
<ul>
<li>House Robber III</li>
<li>Binary Tree Maximum Path Sum</li>
</ul>
<h3 id="pattern-4-state-machine-dp">Pattern 4: State Machine DP</h3>
<p>Track multiple states simultaneously:</p>
<ul>
<li>Best Time to Buy and Sell Stock (with transactions)</li>
<li>House Robber II (circular array)</li>
</ul>
<h3 id="pattern-5-digit-dp">Pattern 5: Digit DP</h3>
<p>Count numbers with certain properties:</p>
<ul>
<li>Count Numbers with Unique Digits</li>
<li>Numbers At Most N Given Digit Set</li>
</ul>
<h2 id="qa-common-questions">Q&amp;A: Common Questions</h2>
<h3 id="q1-how-do-i-know-if-a-problem-is-a-dp-problem">Q1: How do I know
if a problem is a DP problem?</h3>
<p><strong>A</strong>: Look for these signs: - Optimization problem
(max, min, count) - Can be broken into subproblems - Subproblems overlap
- Has optimal substructure - Often involves sequences, arrays, or
strings</p>
<h3 id="q2-should-i-use-top-down-memoization-or-bottom-up-tabulation">Q2:
Should I use top-down (memoization) or bottom-up (tabulation)?</h3>
<p><strong>A</strong>: - <strong>Top-down</strong>: More intuitive if
you think recursively, easier to implement from recursive solution -
<strong>Bottom-up</strong>: Better for space optimization, no stack
overflow risk, preferred in interviews -
<strong>Recommendation</strong>: Learn both, but master bottom-up for
competitive programming</p>
<h3 id="q3-how-do-i-find-the-state-transition-equation">Q3: How do I
find the state transition equation?</h3>
<p><strong>A</strong>: 1. Identify what choices you have at each step 2.
Consider all possible transitions from previous states 3. Write the
recurrence relation 4. Verify with small examples</p>
<h3 id="q4-what-if-i-cant-figure-out-the-dp-state">Q4: What if I can't
figure out the DP state?</h3>
<p><strong>A</strong>: - Start with the most obvious state (position,
index) - Consider what information you need to make decisions - Look at
constraints—they often hint at state dimensions - Practice with simpler
problems first</p>
<h3 id="q5-how-do-i-optimize-space-in-2d-dp">Q5: How do I optimize space
in 2D DP?</h3>
<p><strong>A</strong>: - If only previous row is needed: use 1D array,
update row by row - If only diagonal is needed: use variables - If
backward dependencies: iterate backwards - Always check if you can
reduce dimensions</p>
<h3 id="q6-can-dp-solve-all-optimization-problems">Q6: Can DP solve all
optimization problems?</h3>
<p><strong>A</strong>: No. DP requires: - Optimal substructure -
Overlapping subproblems - Finite state space</p>
<p>Problems without these properties need other techniques (greedy,
divide-and-conquer, etc.).</p>
<h3 id="q7-how-do-i-debug-dp-solutions">Q7: How do I debug DP
solutions?</h3>
<p><strong>A</strong>: - Print the DP table after filling - Verify base
cases - Check state transitions with small examples - Use test cases
with known answers - Trace through the algorithm manually</p>
<h3 id="q8-whats-the-difference-between-dp-and-greedy-algorithms">Q8:
What's the difference between DP and greedy algorithms?</h3>
<p><strong>A</strong>: - <strong>DP</strong>: Considers all
possibilities, makes optimal choice at each step based on previous
optimal solutions - <strong>Greedy</strong>: Makes locally optimal
choice without considering future consequences - <strong>Key
difference</strong>: Greedy doesn't reconsider past decisions; DP
does</p>
<h3 id="q9-how-do-i-handle-dp-with-constraints-like-at-most-k-transactions">Q9:
How do I handle DP with constraints (like "at most k
transactions")?</h3>
<p><strong>A</strong>: Add a dimension to your state: -
<code>dp[i][k]</code> = state at position <span class="math inline">\(i\)</span> with constraint <span class="math inline">\(k\)</span> - Update transitions to account for the
constraint - Example: Stock problems with transaction limits</p>
<h3 id="q10-is-dp-always-better-than-recursion">Q10: Is DP always better
than recursion?</h3>
<p><strong>A</strong>: Not always: - <strong>DP is better</strong>: When
subproblems overlap significantly - <strong>Recursion is fine</strong>:
When subproblems don't overlap (divide-and-conquer) - <strong>Rule of
thumb</strong>: If you see repeated calculations, use DP</p>
<h2 id="practice-strategy">Practice Strategy</h2>
<h3 id="step-1-master-the-fundamentals">Step 1: Master the
Fundamentals</h3>
<p>Start with classic problems: 1. Fibonacci 2. Climbing Stairs 3. House
Robber 4. Coin Change</p>
<h3 id="step-2-learn-1d-patterns">Step 2: Learn 1D Patterns</h3>
<p>Practice these patterns: - Linear sequences - State transitions -
Space optimization</p>
<h3 id="step-3-master-2d-dp">Step 3: Master 2D DP</h3>
<p>Focus on: - String DP (LCS, Edit Distance) - Grid DP (Unique Paths) -
Knapsack variants</p>
<h3 id="step-4-advanced-topics">Step 4: Advanced Topics</h3>
<p>Once comfortable: - Interval DP - Tree DP - State machine DP - Digit
DP</p>
<h3 id="step-5-problem-solving-framework">Step 5: Problem-Solving
Framework</h3>
<p>For any DP problem: 1. <strong>Identify</strong>: Is this a DP
problem? 2. <strong>State</strong>: What does <code>dp[i]</code> or
<code>dp[i][j]</code> represent? 3. <strong>Transition</strong>: How do
states relate? 4. <strong>Base cases</strong>: What are the smallest
subproblems? 5. <strong>Implementation</strong>: Code it up 6.
<strong>Optimize</strong>: Can you reduce space?</p>
<h2 id="summary">Summary</h2>
<p>Dynamic Programming is a powerful technique that transforms
exponential-time recursive solutions into polynomial-time iterative
ones. The key to mastering DP is:</p>
<ol type="1">
<li><strong>Understand the principles</strong>: Optimal substructure and
overlapping subproblems</li>
<li><strong>Follow the process</strong>: State definition → Transition →
Base cases</li>
<li><strong>Practice patterns</strong>: 1D linear, 2D string/grid,
knapsack, etc.</li>
<li><strong>Optimize space</strong>: Use rolling arrays, reduce
dimensions when possible</li>
<li><strong>Build intuition</strong>: Start with simple problems and
gradually increase difficulty</li>
</ol>
<p>Remember, DP is not about memorizing solutions—it's about recognizing
patterns and applying systematic problem-solving techniques. With
practice, you'll develop the intuition to identify DP problems and
construct efficient solutions.</p>
<p>The problems covered in this article form the foundation of dynamic
programming. Master these, and you'll be well-equipped to tackle more
advanced DP problems on LeetCode and in technical interviews. Keep
practicing, and don't be discouraged by initial difficulties—DP becomes
more intuitive with experience.</p>
<h2 id="additional-resources">Additional Resources</h2>
<ul>
<li><strong>LeetCode DP Collection</strong>: Practice problems sorted by
difficulty</li>
<li><strong>Classic DP Problems</strong>: Fibonacci, Knapsack, LCS, Edit
Distance</li>
<li><strong>Pattern Recognition</strong>: Learn to identify DP patterns
quickly</li>
<li><strong>Space Optimization</strong>: Master reducing space
complexity</li>
</ul>
<p>Happy coding, and remember: every expert was once a beginner. Keep
solving problems, and DP will become second nature!</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>Post title：LeetCode (6): Dynamic Programming Basics</li>
        <li>Post author：Chen Kai</li>
        <li>Create time：2022-05-29 00:00:00</li>
        <li>
            Post link：https://www.chenk.top/en/leetcode-dynamic-programming-basics/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/en/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/en/tags/Algorithms/">#Algorithms</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/en/tags/Dynamic-Programming/">#Dynamic Programming</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/en/leetcode-backtracking/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode (7): Backtracking Algorithm</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/en/leetcode-two-pointers/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode (2): Two Pointers - Collision, Fast-Slow &amp; Sliding Window Complete Guide</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情赞美帅气伟大的ck吧~',
                    lang: 'en'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#what-is-dynamic-programming"><span class="nav-number">1.</span> <span class="nav-text">What is Dynamic Programming?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#core-principles"><span class="nav-number">2.</span> <span class="nav-text">Core Principles</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#optimal-substructure"><span class="nav-number">2.1.</span> <span class="nav-text">Optimal Substructure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#overlapping-subproblems"><span class="nav-number">2.2.</span> <span class="nav-text">Overlapping Subproblems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#when-to-use-dynamic-programming"><span class="nav-number">2.3.</span> <span class="nav-text">When to Use Dynamic
Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#the-three-step-dp-process"><span class="nav-number">3.</span> <span class="nav-text">The Three-Step DP Process</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#step-1-define-the-state"><span class="nav-number">3.1.</span> <span class="nav-text">Step 1: Define the State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step-2-find-the-state-transition"><span class="nav-number">3.2.</span> <span class="nav-text">Step 2: Find the State
Transition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step-3-determine-base-cases-and-initialization"><span class="nav-number">3.3.</span> <span class="nav-text">Step 3:
Determine Base Cases and Initialization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#one-dimensional-dynamic-programming"><span class="nav-number">4.</span> <span class="nav-text">One-Dimensional Dynamic
Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-1-climbing-stairs"><span class="nav-number">4.1.</span> <span class="nav-text">Problem 1: Climbing Stairs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-2-house-robber"><span class="nav-number">4.2.</span> <span class="nav-text">Problem 2: House Robber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-3-best-time-to-buy-and-sell-stock"><span class="nav-number">4.3.</span> <span class="nav-text">Problem 3: Best Time
to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-4-coin-change"><span class="nav-number">4.4.</span> <span class="nav-text">Problem 4: Coin Change</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#two-dimensional-dynamic-programming"><span class="nav-number">5.</span> <span class="nav-text">Two-Dimensional Dynamic
Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-5-longest-common-subsequence-lcs"><span class="nav-number">5.1.</span> <span class="nav-text">Problem 5: Longest
Common Subsequence (LCS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-6-edit-distance"><span class="nav-number">5.2.</span> <span class="nav-text">Problem 6: Edit Distance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-7-01-knapsack-problem"><span class="nav-number">5.3.</span> <span class="nav-text">Problem 7: 0&#x2F;1 Knapsack
Problem</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#space-optimization-techniques"><span class="nav-number">6.</span> <span class="nav-text">Space Optimization
Techniques</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rolling-array-1d-to-variables"><span class="nav-number">6.1.</span> <span class="nav-text">1. Rolling Array (1D to
Variables)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-to-1d-row-by-row-processing"><span class="nav-number">6.2.</span> <span class="nav-text">2. 2D to 1D (Row-by-Row
Processing)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#backward-iteration-for-1d-optimization"><span class="nav-number">6.3.</span> <span class="nav-text">3. Backward Iteration
for 1D Optimization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dp-vs-recursion-vs-memoization"><span class="nav-number">7.</span> <span class="nav-text">DP vs Recursion vs
Memoization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pure-recursion"><span class="nav-number">7.1.</span> <span class="nav-text">Pure Recursion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memoization-top-down-dp"><span class="nav-number">7.2.</span> <span class="nav-text">Memoization (Top-Down DP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tabulation-bottom-up-dp"><span class="nav-number">7.3.</span> <span class="nav-text">Tabulation (Bottom-Up DP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#comparison"><span class="nav-number">7.4.</span> <span class="nav-text">Comparison</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#complexity-analysis"><span class="nav-number">8.</span> <span class="nav-text">Complexity Analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#time-complexity"><span class="nav-number">8.1.</span> <span class="nav-text">Time Complexity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#space-complexity"><span class="nav-number">8.2.</span> <span class="nav-text">Space Complexity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#example-analysis-coin-change"><span class="nav-number">8.3.</span> <span class="nav-text">Example Analysis: Coin Change</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#common-dp-patterns"><span class="nav-number">9.</span> <span class="nav-text">Common DP Patterns</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-1-linear-dp"><span class="nav-number">9.1.</span> <span class="nav-text">Pattern 1: Linear DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-2-interval-dp"><span class="nav-number">9.2.</span> <span class="nav-text">Pattern 2: Interval DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-3-tree-dp"><span class="nav-number">9.3.</span> <span class="nav-text">Pattern 3: Tree DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-4-state-machine-dp"><span class="nav-number">9.4.</span> <span class="nav-text">Pattern 4: State Machine DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-5-digit-dp"><span class="nav-number">9.5.</span> <span class="nav-text">Pattern 5: Digit DP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qa-common-questions"><span class="nav-number">10.</span> <span class="nav-text">Q&amp;A: Common Questions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#q1-how-do-i-know-if-a-problem-is-a-dp-problem"><span class="nav-number">10.1.</span> <span class="nav-text">Q1: How do I know
if a problem is a DP problem?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q2-should-i-use-top-down-memoization-or-bottom-up-tabulation"><span class="nav-number">10.2.</span> <span class="nav-text">Q2:
Should I use top-down (memoization) or bottom-up (tabulation)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q3-how-do-i-find-the-state-transition-equation"><span class="nav-number">10.3.</span> <span class="nav-text">Q3: How do I
find the state transition equation?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q4-what-if-i-cant-figure-out-the-dp-state"><span class="nav-number">10.4.</span> <span class="nav-text">Q4: What if I can&#39;t
figure out the DP state?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q5-how-do-i-optimize-space-in-2d-dp"><span class="nav-number">10.5.</span> <span class="nav-text">Q5: How do I optimize space
in 2D DP?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q6-can-dp-solve-all-optimization-problems"><span class="nav-number">10.6.</span> <span class="nav-text">Q6: Can DP solve all
optimization problems?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q7-how-do-i-debug-dp-solutions"><span class="nav-number">10.7.</span> <span class="nav-text">Q7: How do I debug DP
solutions?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q8-whats-the-difference-between-dp-and-greedy-algorithms"><span class="nav-number">10.8.</span> <span class="nav-text">Q8:
What&#39;s the difference between DP and greedy algorithms?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q9-how-do-i-handle-dp-with-constraints-like-at-most-k-transactions"><span class="nav-number">10.9.</span> <span class="nav-text">Q9:
How do I handle DP with constraints (like &quot;at most k
transactions&quot;)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q10-is-dp-always-better-than-recursion"><span class="nav-number">10.10.</span> <span class="nav-text">Q10: Is DP always better
than recursion?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#practice-strategy"><span class="nav-number">11.</span> <span class="nav-text">Practice Strategy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#step-1-master-the-fundamentals"><span class="nav-number">11.1.</span> <span class="nav-text">Step 1: Master the
Fundamentals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step-2-learn-1d-patterns"><span class="nav-number">11.2.</span> <span class="nav-text">Step 2: Learn 1D Patterns</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step-3-master-2d-dp"><span class="nav-number">11.3.</span> <span class="nav-text">Step 3: Master 2D DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step-4-advanced-topics"><span class="nav-number">11.4.</span> <span class="nav-text">Step 4: Advanced Topics</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#step-5-problem-solving-framework"><span class="nav-number">11.5.</span> <span class="nav-text">Step 5: Problem-Solving
Framework</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#summary"><span class="nav-number">12.</span> <span class="nav-text">Summary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#additional-resources"><span class="nav-number">13.</span> <span class="nav-text">Additional Resources</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
