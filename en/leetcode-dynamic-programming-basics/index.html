<!DOCTYPE html>



<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode (6): Dynamic Programming Basics |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"en","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/en/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode (6): Dynamic Programming Basics</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-03-16 00:00:00</span>
        <span class="mobile">2023-03-16 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/en/tags/Algorithms/">Algorithms</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/en/tags/Dynamic-Programming/">Dynamic Programming</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>3.6k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>22 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>Dynamic Programming (DP) is one of the most powerful problem-solving paradigms in computer science. While it might seem intimidating at first, understanding its core principles and patterns can transform how you approach optimization problems. This article will guide you through the fundamentals of dynamic programming, from the theoretical foundations to practical LeetCode problem-solving strategies.</p>
<span id="more"></span>
<h2 id="What-is-Dynamic-Programming"><a class="header-anchor" href="#What-is-Dynamic-Programming">¶</a>What is Dynamic Programming?</h2>
<p>Dynamic Programming is a method for solving complex problems by breaking them down into simpler subproblems. The key insight is that instead of solving the same subproblem multiple times, we solve it once and store the result for future use. This approach dramatically improves efficiency for problems that exhibit two critical properties: <strong>optimal substructure</strong> and <strong>overlapping subproblems</strong>.</p>
<p>The term “dynamic programming” was coined by Richard Bellman in the 1950s. Interestingly, Bellman chose this name not because the method involves dynamic or changing behavior, but rather to make it sound impressive enough to secure funding. Despite its somewhat misleading name, DP has become one of the most fundamental techniques in algorithm design.</p>
<h2 id="Core-Principles"><a class="header-anchor" href="#Core-Principles">¶</a>Core Principles</h2>
<h3 id="Optimal-Substructure"><a class="header-anchor" href="#Optimal-Substructure">¶</a>Optimal Substructure</h3>
<p>A problem exhibits <strong>optimal substructure</strong> if an optimal solution to the problem contains optimal solutions to its subproblems. In other words, if we can solve the problem optimally by combining optimal solutions to smaller problems, then the problem has optimal substructure.</p>
<p>Consider the classic example of finding the shortest path in a graph. If the shortest path from node A to node C goes through node B, then the path from A to B must be the shortest path from A to B, and the path from B to C must be the shortest path from B to C. This property allows us to build solutions incrementally.</p>
<p><strong>Example</strong>: In the Fibonacci sequence, $F(n) = F(n-1) + F(n-2)$. The optimal solution for $F(n)$ depends on the optimal solutions for $F(n-1)$ and $F(n-2)$.</p>
<h3 id="Overlapping-Subproblems"><a class="header-anchor" href="#Overlapping-Subproblems">¶</a>Overlapping Subproblems</h3>
<p>A problem has <strong>overlapping subproblems</strong> if the same subproblem is solved multiple times during the computation. This is where DP shines—instead of recalculating the same values repeatedly, we store results in a table (memoization) and reuse them.</p>
<p><strong>Example</strong>: When computing $F(5)$ recursively:</p>
<ul>
<li>$F(5) = F(4) + F(3)$</li>
<li>$F(4) = F(3) + F(2)$</li>
<li>$F(3) = F(2) + F(1)$</li>
</ul>
<p>Notice that $F(3)$ and $F(2)$ are computed multiple times. This redundancy is exactly what DP eliminates.</p>
<h3 id="When-to-Use-Dynamic-Programming"><a class="header-anchor" href="#When-to-Use-Dynamic-Programming">¶</a>When to Use Dynamic Programming</h3>
<p>DP is most effective when:</p>
<ol>
<li>The problem can be broken down into smaller subproblems</li>
<li>These subproblems overlap (same subproblem appears multiple times)</li>
<li>The problem has optimal substructure (optimal solution uses optimal subproblem solutions)</li>
<li>You need to find an optimal value (maximum, minimum, count, etc.) rather than all possible solutions</li>
</ol>
<h2 id="The-Three-Step-DP-Process"><a class="header-anchor" href="#The-Three-Step-DP-Process">¶</a>The Three-Step DP Process</h2>
<p>Every DP problem can be approached systematically using these three steps:</p>
<h3 id="Step-1-Define-the-State"><a class="header-anchor" href="#Step-1-Define-the-State">¶</a>Step 1: Define the State</h3>
<p>The <strong>state</strong> represents a subproblem. You need to identify:</p>
<ul>
<li>What information you need to track</li>
<li>What parameters uniquely identify a subproblem</li>
<li>What the state represents (usually the answer to a subproblem)</li>
</ul>
<p><strong>Example</strong>: For climbing stairs, the state <code>dp[i]</code> represents “the number of ways to reach step $i$”.</p>
<h3 id="Step-2-Find-the-State-Transition"><a class="header-anchor" href="#Step-2-Find-the-State-Transition">¶</a>Step 2: Find the State Transition</h3>
<p>The <strong>state transition</strong> (recurrence relation) describes how to compute a state from previous states. This is the heart of DP—it captures the relationship between subproblems.</p>
<p><strong>Example</strong>: For climbing stairs, <code>dp[i] = dp[i-1] + dp[i-2]</code> because you can reach step $i$ from step $i-1$ or step $i-2$.</p>
<h3 id="Step-3-Determine-Base-Cases-and-Initialization"><a class="header-anchor" href="#Step-3-Determine-Base-Cases-and-Initialization">¶</a>Step 3: Determine Base Cases and Initialization</h3>
<p><strong>Base cases</strong> are the smallest subproblems that can be solved directly without recursion. They prevent infinite recursion and provide starting points for building up solutions.</p>
<p><strong>Example</strong>: For climbing stairs, <code>dp[0] = 1</code> (one way to stay at ground level) and <code>dp[1] = 1</code> (one way to reach the first step).</p>
<h2 id="One-Dimensional-Dynamic-Programming"><a class="header-anchor" href="#One-Dimensional-Dynamic-Programming">¶</a>One-Dimensional Dynamic Programming</h2>
<p>One-dimensional DP problems use a single array to store subproblem solutions. The state typically depends on a single parameter (usually position or index).</p>
<h3 id="Problem-1-Climbing-Stairs"><a class="header-anchor" href="#Problem-1-Climbing-Stairs">¶</a>Problem 1: Climbing Stairs</h3>
<p><strong>LeetCode 70</strong>: You are climbing a staircase. It takes $n$ steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Analysis</strong>:</p>
<ul>
<li><strong>State</strong>: <code>dp[i]</code> = number of ways to reach step $i$</li>
<li><strong>Transition</strong>: <code>dp[i] = dp[i-1] + dp[i-2]</code> (can come from step $i-1$ or $i-2$)</li>
<li><strong>Base cases</strong>: <code>dp[0] = 1</code>, <code>dp[1] = 1</code></li>
</ul>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: $O(n)$ - single pass through the array<br>
<strong>Space Complexity</strong>: $O(n)$ - DP array of size $n+1$</p>
<p><strong>Space Optimization</strong>: Since we only need the last two values, we can reduce space to $O(1)$:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    prev2 = <span class="number">1</span>  <span class="comment"># dp[0]</span></span><br><span class="line">    prev1 = <span class="number">1</span>  <span class="comment"># dp[1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        current = prev1 + prev2</span><br><span class="line">        prev2 = prev1</span><br><span class="line">        prev1 = current</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure>
<h3 id="Problem-2-House-Robber"><a class="header-anchor" href="#Problem-2-House-Robber">¶</a>Problem 2: House Robber</h3>
<p><strong>LeetCode 198</strong>: You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. You cannot rob two adjacent houses. Determine the maximum amount of money you can rob tonight.</p>
<p><strong>Analysis</strong>:</p>
<ul>
<li><strong>State</strong>: <code>dp[i]</code> = maximum money that can be robbed from houses $0$ to $i$</li>
<li><strong>Transition</strong>: At house $i$, we have two choices:
<ul>
<li>Rob house $i$: <code>dp[i] = nums[i] + dp[i-2]</code></li>
<li>Skip house $i$: <code>dp[i] = dp[i-1]</code></li>
<li>Take the maximum: <code>dp[i] = max(nums[i] + dp[i-2], dp[i-1])</code></li>
</ul>
</li>
<li><strong>Base cases</strong>: <code>dp[0] = nums[0]</code>, <code>dp[1] = max(nums[0], nums[1])</code></li>
</ul>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(nums[i] + dp[i-<span class="number">2</span>], dp[i-<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: $O(n)$<br>
<strong>Space Complexity</strong>: $O(n)$, optimizable to $O(1)$</p>
<p><strong>Space-Optimized Version</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    prev2 = nums[<span class="number">0</span>]</span><br><span class="line">    prev1 = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        current = <span class="built_in">max</span>(nums[i] + prev2, prev1)</span><br><span class="line">        prev2 = prev1</span><br><span class="line">        prev1 = current</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure>
<h3 id="Problem-3-Best-Time-to-Buy-and-Sell-Stock"><a class="header-anchor" href="#Problem-3-Best-Time-to-Buy-and-Sell-Stock">¶</a>Problem 3: Best Time to Buy and Sell Stock</h3>
<p><strong>LeetCode 121</strong>: You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on day $i$. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve.</p>
<p><strong>Analysis</strong>:</p>
<ul>
<li><strong>State</strong>: <code>dp[i]</code> = maximum profit achievable up to day $i$</li>
<li><strong>Transition</strong>:
<ul>
<li>Track the minimum price seen so far: <code>min_price = min(min_price, prices[i])</code></li>
<li>Calculate profit if selling today: <code>profit = prices[i] - min_price</code></li>
<li>Update maximum: <code>dp[i] = max(dp[i-1], profit)</code></li>
</ul>
</li>
<li><strong>Base case</strong>: <code>dp[0] = 0</code> (no profit on first day)</li>
</ul>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">prices</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    min_price = prices[<span class="number">0</span>]</span><br><span class="line">    max_profit = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">        min_price = <span class="built_in">min</span>(min_price, prices[i])</span><br><span class="line">        max_profit = <span class="built_in">max</span>(max_profit, prices[i] - min_price)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: $O(n)$<br>
<strong>Space Complexity</strong>: $O(1)$</p>
<p><strong>Alternative DP Approach</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">prices</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(prices)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># dp[i] = max profit up to day i</span></span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    min_price = prices[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        min_price = <span class="built_in">min</span>(min_price, prices[i])</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], prices[i] - min_price)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Problem-4-Coin-Change"><a class="header-anchor" href="#Problem-4-Coin-Change">¶</a>Problem 4: Coin Change</h3>
<p><strong>LeetCode 322</strong>: You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return $-1$.</p>
<p><strong>Analysis</strong>:</p>
<ul>
<li><strong>State</strong>: <code>dp[i]</code> = minimum number of coins needed to make amount $i$</li>
<li><strong>Transition</strong>: For each coin denomination, try using it:
<ul>
<li><code>dp[i] = min(dp[i], dp[i - coin] + 1)</code> for all valid coins</li>
</ul>
</li>
<li><strong>Base case</strong>: <code>dp[0] = 0</code> (0 coins needed for amount 0)</li>
</ul>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">coins, amount</span>):</span><br><span class="line">    <span class="comment"># Initialize with amount + 1 (impossible value)</span></span><br><span class="line">    dp = [amount + <span class="number">1</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> coin &lt;= i:</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coin] + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != amount + <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: $O(amount \times len(coins))$<br>
<strong>Space Complexity</strong>: $O(amount)$</p>
<h2 id="Two-Dimensional-Dynamic-Programming"><a class="header-anchor" href="#Two-Dimensional-Dynamic-Programming">¶</a>Two-Dimensional Dynamic Programming</h2>
<p>Two-dimensional DP problems use a 2D table where the state depends on two parameters. These are often more complex but follow the same principles.</p>
<h3 id="Problem-5-Longest-Common-Subsequence-LCS"><a class="header-anchor" href="#Problem-5-Longest-Common-Subsequence-LCS">¶</a>Problem 5: Longest Common Subsequence (LCS)</h3>
<p><strong>LeetCode 1143</strong>: Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest common subsequence. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.</p>
<p><strong>Analysis</strong>:</p>
<ul>
<li><strong>State</strong>: <code>dp[i][j]</code> = length of LCS of <code>text1[0:i]</code> and <code>text2[0:j]</code></li>
<li><strong>Transition</strong>:
<ul>
<li>If <code>text1[i-1] == text2[j-1]</code>: <code>dp[i][j] = dp[i-1][j-1] + 1</code></li>
<li>Otherwise: <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code></li>
</ul>
</li>
<li><strong>Base cases</strong>: <code>dp[0][j] = 0</code>, <code>dp[i][0] = 0</code> (empty string has LCS length 0)</li>
</ul>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">text1, text2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: $O(m \times n)$<br>
<strong>Space Complexity</strong>: $O(m \times n)$, optimizable to $O(min(m, n))$</p>
<p><strong>Space-Optimized Version</strong> (using only previous row):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">text1, text2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">    <span class="keyword">if</span> m &lt; n:</span><br><span class="line">        text1, text2 = text2, text1</span><br><span class="line">        m, n = n, m</span><br><span class="line">    </span><br><span class="line">    prev = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        curr = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>]:</span><br><span class="line">                curr[j] = prev[j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr[j] = <span class="built_in">max</span>(prev[j], curr[j-<span class="number">1</span>])</span><br><span class="line">        prev = curr</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prev[n]</span><br></pre></td></tr></table></figure>
<h3 id="Problem-6-Edit-Distance"><a class="header-anchor" href="#Problem-6-Edit-Distance">¶</a>Problem 6: Edit Distance</h3>
<p><strong>LeetCode 72</strong>: Given two strings <code>word1</code> and <code>word2</code>, return the minimum number of operations required to convert <code>word1</code> to <code>word2</code>. You have three operations permitted: insert a character, delete a character, or replace a character.</p>
<p><strong>Analysis</strong>:</p>
<ul>
<li><strong>State</strong>: <code>dp[i][j]</code> = minimum operations to convert <code>word1[0:i]</code> to <code>word2[0:j]</code></li>
<li><strong>Transition</strong>:
<ul>
<li>If <code>word1[i-1] == word2[j-1]</code>: <code>dp[i][j] = dp[i-1][j-1]</code> (no operation needed)</li>
<li>Otherwise, take minimum of:
<ul>
<li>Insert: <code>dp[i][j-1] + 1</code></li>
<li>Delete: <code>dp[i-1][j] + 1</code></li>
<li>Replace: <code>dp[i-1][j-1] + 1</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Base cases</strong>:
<ul>
<li><code>dp[0][j] = j</code> (insert all characters)</li>
<li><code>dp[i][0] = i</code> (delete all characters)</li>
</ul>
</li>
</ul>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">word1, word2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Base cases</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        dp[i][<span class="number">0</span>] = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = j</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(</span><br><span class="line">                    dp[i-<span class="number">1</span>][j] + <span class="number">1</span>,      <span class="comment"># delete</span></span><br><span class="line">                    dp[i][j-<span class="number">1</span>] + <span class="number">1</span>,      <span class="comment"># insert</span></span><br><span class="line">                    dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>     <span class="comment"># replace</span></span><br><span class="line">                )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: $O(m \times n)$<br>
<strong>Space Complexity</strong>: $O(m \times n)$, optimizable to $O(min(m, n))$</p>
<h3 id="Problem-7-0-1-Knapsack-Problem"><a class="header-anchor" href="#Problem-7-0-1-Knapsack-Problem">¶</a>Problem 7: 0/1 Knapsack Problem</h3>
<p><strong>Problem</strong>: Given weights and values of $n$ items, put these items in a knapsack of capacity $W$ to get the maximum total value. Each item can be used at most once.</p>
<p><strong>Analysis</strong>:</p>
<ul>
<li><strong>State</strong>: <code>dp[i][w]</code> = maximum value achievable with first $i$ items and weight capacity $w$</li>
<li><strong>Transition</strong>:
<ul>
<li>If item $i$ doesn’t fit: <code>dp[i][w] = dp[i-1][w]</code></li>
<li>Otherwise: <code>dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])</code></li>
</ul>
</li>
<li><strong>Base cases</strong>: <code>dp[0][w] = 0</code> (no items, no value)</li>
</ul>
<p><strong>Solution</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(weights)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (capacity + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, capacity + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> weights[i-<span class="number">1</span>] &gt; w:</span><br><span class="line">                dp[i][w] = dp[i-<span class="number">1</span>][w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(</span><br><span class="line">                    dp[i-<span class="number">1</span>][w],</span><br><span class="line">                    dp[i-<span class="number">1</span>][w - weights[i-<span class="number">1</span>]] + values[i-<span class="number">1</span>]</span><br><span class="line">                )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n][capacity]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: $O(n \times capacity)$<br>
<strong>Space Complexity</strong>: $O(n \times capacity)$, optimizable to $O(capacity)$</p>
<p><strong>Space-Optimized Version</strong> (using 1D array, iterating backwards):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(weights)</span><br><span class="line">    dp = [<span class="number">0</span>] * (capacity + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># Iterate backwards to avoid using updated values</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(capacity, weights[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weights[i]] + values[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[capacity]</span><br></pre></td></tr></table></figure>
<h2 id="Space-Optimization-Techniques"><a class="header-anchor" href="#Space-Optimization-Techniques">¶</a>Space Optimization Techniques</h2>
<p>Space optimization is crucial for DP problems, especially in competitive programming where memory constraints matter. Here are common techniques:</p>
<h3 id="1-Rolling-Array-1D-to-Variables"><a class="header-anchor" href="#1-Rolling-Array-1D-to-Variables">¶</a>1. Rolling Array (1D to Variables)</h3>
<p>When only the last few values are needed, replace arrays with variables:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Before: O(n) space</span></span><br><span class="line">dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># After: O(1) space</span></span><br><span class="line">prev2, prev1 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">current = prev1 + prev2</span><br></pre></td></tr></table></figure>
<h3 id="2-2D-to-1D-Row-by-Row-Processing"><a class="header-anchor" href="#2-2D-to-1D-Row-by-Row-Processing">¶</a>2. 2D to 1D (Row-by-Row Processing)</h3>
<p>When only the previous row is needed, use a 1D array:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Before: O(m*n) space</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># After: O(n) space</span></span><br><span class="line">prev = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">curr = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># Process row by row</span></span><br></pre></td></tr></table></figure>
<h3 id="3-Backward-Iteration-for-1D-Optimization"><a class="header-anchor" href="#3-Backward-Iteration-for-1D-Optimization">¶</a>3. Backward Iteration for 1D Optimization</h3>
<p>For knapsack-like problems, iterate backwards to avoid overwriting values:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Forward iteration (wrong for knapsack)</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(weights[i], capacity + <span class="number">1</span>):</span><br><span class="line">    dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weights[i]] + values[i])</span><br><span class="line">    <span class="comment"># dp[w - weights[i]] might have been updated in this iteration!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Backward iteration (correct)</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(capacity, weights[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weights[i]] + values[i])</span><br><span class="line">    <span class="comment"># dp[w - weights[i]] hasn&#x27;t been updated yet</span></span><br></pre></td></tr></table></figure>
<h2 id="DP-vs-Recursion-vs-Memoization"><a class="header-anchor" href="#DP-vs-Recursion-vs-Memoization">¶</a>DP vs Recursion vs Memoization</h2>
<p>Understanding the relationship between these concepts is crucial:</p>
<h3 id="Pure-Recursion"><a class="header-anchor" href="#Pure-Recursion">¶</a>Pure Recursion</h3>
<p>Recursive solution without optimization:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: $O(2^n)$ (exponential)<br>
<strong>Space Complexity</strong>: $O(n)$ (call stack)</p>
<h3 id="Memoization-Top-Down-DP"><a class="header-anchor" href="#Memoization-Top-Down-DP">¶</a>Memoization (Top-Down DP)</h3>
<p>Store results of recursive calls:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n, memo=&#123;&#125;</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    memo[n] = fib(n-<span class="number">1</span>, memo) + fib(n-<span class="number">2</span>, memo)</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: $O(n)$<br>
<strong>Space Complexity</strong>: $O(n)$ (memo + call stack)</p>
<h3 id="Tabulation-Bottom-Up-DP"><a class="header-anchor" href="#Tabulation-Bottom-Up-DP">¶</a>Tabulation (Bottom-Up DP)</h3>
<p>Build solution iteratively from base cases:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity</strong>: $O(n)$<br>
<strong>Space Complexity</strong>: $O(n)$, optimizable to $O(1)$</p>
<h3 id="Comparison"><a class="header-anchor" href="#Comparison">¶</a>Comparison</h3>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Time</th>
<th>Space</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr>
<td>Recursion</td>
<td>$O(2^n)$</td>
<td>$O(n)$</td>
<td>Intuitive, natural</td>
<td>Exponential time</td>
</tr>
<tr>
<td>Memoization</td>
<td>$O(n)$</td>
<td>$O(n)$</td>
<td>Natural recursion, avoids recomputation</td>
<td>Stack overflow risk</td>
</tr>
<tr>
<td>Tabulation</td>
<td>$O(n)$</td>
<td>$O(n)$ or $O(1)$</td>
<td>No stack overflow, space optimizable</td>
<td>Less intuitive</td>
</tr>
</tbody>
</table>
<p><strong>When to use each</strong>:</p>
<ul>
<li><strong>Recursion</strong>: Only for small inputs or when clarity matters more than performance</li>
<li><strong>Memoization</strong>: When the recursive structure is natural and you want to preserve it</li>
<li><strong>Tabulation</strong>: Preferred for competitive programming, better space optimization, no stack overflow</li>
</ul>
<h2 id="Complexity-Analysis-v18"><a class="header-anchor" href="#Complexity-Analysis-v18">¶</a>Complexity Analysis</h2>
<h3 id="Time-Complexity-v2"><a class="header-anchor" href="#Time-Complexity-v2">¶</a>Time Complexity</h3>
<p>For DP problems, time complexity is typically:</p>
<ul>
<li><strong>1D DP</strong>: $O(n)$ or $O(n \times k)$ where $k$ is the number of choices per state</li>
<li><strong>2D DP</strong>: $O(m \times n)$ or $O(m \times n \times k)$</li>
<li><strong>General</strong>: $O(\text{number of states} \times \text{work per state})$</li>
</ul>
<h3 id="Space-Complexity-v2"><a class="header-anchor" href="#Space-Complexity-v2">¶</a>Space Complexity</h3>
<ul>
<li><strong>Original</strong>: $O(\text{number of states})$</li>
<li><strong>Optimized</strong>: Often reducible to $O(1)$ for 1D or $O(min(m,n))$ for 2D</li>
</ul>
<h3 id="Example-Analysis-Coin-Change"><a class="header-anchor" href="#Example-Analysis-Coin-Change">¶</a>Example Analysis: Coin Change</h3>
<ul>
<li><strong>States</strong>: $O(amount)$ states (one for each amount from 0 to amount)</li>
<li><strong>Work per state</strong>: $O(len(coins))$ (try each coin)</li>
<li><strong>Time</strong>: $O(amount \times len(coins))$</li>
<li><strong>Space</strong>: $O(amount)$</li>
</ul>
<h2 id="Common-DP-Patterns"><a class="header-anchor" href="#Common-DP-Patterns">¶</a>Common DP Patterns</h2>
<h3 id="Pattern-1-Linear-DP"><a class="header-anchor" href="#Pattern-1-Linear-DP">¶</a>Pattern 1: Linear DP</h3>
<p>State depends on a single dimension (position, time, etc.):</p>
<ul>
<li>Climbing Stairs</li>
<li>House Robber</li>
<li>Maximum Subarray</li>
</ul>
<h3 id="Pattern-2-Interval-DP"><a class="header-anchor" href="#Pattern-2-Interval-DP">¶</a>Pattern 2: Interval DP</h3>
<p>Process intervals of increasing length:</p>
<ul>
<li>Palindrome Partitioning</li>
<li>Burst Balloons</li>
<li>Matrix Chain Multiplication</li>
</ul>
<h3 id="Pattern-3-Tree-DP"><a class="header-anchor" href="#Pattern-3-Tree-DP">¶</a>Pattern 3: Tree DP</h3>
<p>DP on trees, often with DFS:</p>
<ul>
<li>House Robber III</li>
<li>Binary Tree Maximum Path Sum</li>
</ul>
<h3 id="Pattern-4-State-Machine-DP"><a class="header-anchor" href="#Pattern-4-State-Machine-DP">¶</a>Pattern 4: State Machine DP</h3>
<p>Track multiple states simultaneously:</p>
<ul>
<li>Best Time to Buy and Sell Stock (with transactions)</li>
<li>House Robber II (circular array)</li>
</ul>
<h3 id="Pattern-5-Digit-DP"><a class="header-anchor" href="#Pattern-5-Digit-DP">¶</a>Pattern 5: Digit DP</h3>
<p>Count numbers with certain properties:</p>
<ul>
<li>Count Numbers with Unique Digits</li>
<li>Numbers At Most N Given Digit Set</li>
</ul>
<h2 id="Q-A-Common-Questions"><a class="header-anchor" href="#Q-A-Common-Questions">¶</a>Q&amp;A: Common Questions</h2>
<h3 id="Q1-How-do-I-know-if-a-problem-is-a-DP-problem"><a class="header-anchor" href="#Q1-How-do-I-know-if-a-problem-is-a-DP-problem">¶</a>Q1: How do I know if a problem is a DP problem?</h3>
<p><strong>A</strong>: Look for these signs:</p>
<ul>
<li>Optimization problem (max, min, count)</li>
<li>Can be broken into subproblems</li>
<li>Subproblems overlap</li>
<li>Has optimal substructure</li>
<li>Often involves sequences, arrays, or strings</li>
</ul>
<h3 id="Q2-Should-I-use-top-down-memoization-or-bottom-up-tabulation"><a class="header-anchor" href="#Q2-Should-I-use-top-down-memoization-or-bottom-up-tabulation">¶</a>Q2: Should I use top-down (memoization) or bottom-up (tabulation)?</h3>
<p><strong>A</strong>:</p>
<ul>
<li><strong>Top-down</strong>: More intuitive if you think recursively, easier to implement from recursive solution</li>
<li><strong>Bottom-up</strong>: Better for space optimization, no stack overflow risk, preferred in interviews</li>
<li><strong>Recommendation</strong>: Learn both, but master bottom-up for competitive programming</li>
</ul>
<h3 id="Q3-How-do-I-find-the-state-transition-equation"><a class="header-anchor" href="#Q3-How-do-I-find-the-state-transition-equation">¶</a>Q3: How do I find the state transition equation?</h3>
<p><strong>A</strong>:</p>
<ol>
<li>Identify what choices you have at each step</li>
<li>Consider all possible transitions from previous states</li>
<li>Write the recurrence relation</li>
<li>Verify with small examples</li>
</ol>
<h3 id="Q4-What-if-I-can’t-figure-out-the-DP-state"><a class="header-anchor" href="#Q4-What-if-I-can’t-figure-out-the-DP-state">¶</a>Q4: What if I can’t figure out the DP state?</h3>
<p><strong>A</strong>:</p>
<ul>
<li>Start with the most obvious state (position, index)</li>
<li>Consider what information you need to make decisions</li>
<li>Look at constraints—they often hint at state dimensions</li>
<li>Practice with simpler problems first</li>
</ul>
<h3 id="Q5-How-do-I-optimize-space-in-2D-DP"><a class="header-anchor" href="#Q5-How-do-I-optimize-space-in-2D-DP">¶</a>Q5: How do I optimize space in 2D DP?</h3>
<p><strong>A</strong>:</p>
<ul>
<li>If only previous row is needed: use 1D array, update row by row</li>
<li>If only diagonal is needed: use variables</li>
<li>If backward dependencies: iterate backwards</li>
<li>Always check if you can reduce dimensions</li>
</ul>
<h3 id="Q6-Can-DP-solve-all-optimization-problems"><a class="header-anchor" href="#Q6-Can-DP-solve-all-optimization-problems">¶</a>Q6: Can DP solve all optimization problems?</h3>
<p><strong>A</strong>: No. DP requires:</p>
<ul>
<li>Optimal substructure</li>
<li>Overlapping subproblems</li>
<li>Finite state space</li>
</ul>
<p>Problems without these properties need other techniques (greedy, divide-and-conquer, etc.).</p>
<h3 id="Q7-How-do-I-debug-DP-solutions"><a class="header-anchor" href="#Q7-How-do-I-debug-DP-solutions">¶</a>Q7: How do I debug DP solutions?</h3>
<p><strong>A</strong>:</p>
<ul>
<li>Print the DP table after filling</li>
<li>Verify base cases</li>
<li>Check state transitions with small examples</li>
<li>Use test cases with known answers</li>
<li>Trace through the algorithm manually</li>
</ul>
<h3 id="Q8-What’s-the-difference-between-DP-and-greedy-algorithms"><a class="header-anchor" href="#Q8-What’s-the-difference-between-DP-and-greedy-algorithms">¶</a>Q8: What’s the difference between DP and greedy algorithms?</h3>
<p><strong>A</strong>:</p>
<ul>
<li><strong>DP</strong>: Considers all possibilities, makes optimal choice at each step based on previous optimal solutions</li>
<li><strong>Greedy</strong>: Makes locally optimal choice without considering future consequences</li>
<li><strong>Key difference</strong>: Greedy doesn’t reconsider past decisions; DP does</li>
</ul>
<h3 id="Q9-How-do-I-handle-DP-with-constraints-like-“at-most-k-transactions”"><a class="header-anchor" href="#Q9-How-do-I-handle-DP-with-constraints-like-“at-most-k-transactions”">¶</a>Q9: How do I handle DP with constraints (like “at most k transactions”)?</h3>
<p><strong>A</strong>: Add a dimension to your state:</p>
<ul>
<li><code>dp[i][k]</code> = state at position $i$ with constraint $k$</li>
<li>Update transitions to account for the constraint</li>
<li>Example: Stock problems with transaction limits</li>
</ul>
<h3 id="Q10-Is-DP-always-better-than-recursion"><a class="header-anchor" href="#Q10-Is-DP-always-better-than-recursion">¶</a>Q10: Is DP always better than recursion?</h3>
<p><strong>A</strong>: Not always:</p>
<ul>
<li><strong>DP is better</strong>: When subproblems overlap significantly</li>
<li><strong>Recursion is fine</strong>: When subproblems don’t overlap (divide-and-conquer)</li>
<li><strong>Rule of thumb</strong>: If you see repeated calculations, use DP</li>
</ul>
<h2 id="Practice-Strategy"><a class="header-anchor" href="#Practice-Strategy">¶</a>Practice Strategy</h2>
<h3 id="Step-1-Master-the-Fundamentals"><a class="header-anchor" href="#Step-1-Master-the-Fundamentals">¶</a>Step 1: Master the Fundamentals</h3>
<p>Start with classic problems:</p>
<ol>
<li>Fibonacci</li>
<li>Climbing Stairs</li>
<li>House Robber</li>
<li>Coin Change</li>
</ol>
<h3 id="Step-2-Learn-1D-Patterns"><a class="header-anchor" href="#Step-2-Learn-1D-Patterns">¶</a>Step 2: Learn 1D Patterns</h3>
<p>Practice these patterns:</p>
<ul>
<li>Linear sequences</li>
<li>State transitions</li>
<li>Space optimization</li>
</ul>
<h3 id="Step-3-Master-2D-DP"><a class="header-anchor" href="#Step-3-Master-2D-DP">¶</a>Step 3: Master 2D DP</h3>
<p>Focus on:</p>
<ul>
<li>String DP (LCS, Edit Distance)</li>
<li>Grid DP (Unique Paths)</li>
<li>Knapsack variants</li>
</ul>
<h3 id="Step-4-Advanced-Topics"><a class="header-anchor" href="#Step-4-Advanced-Topics">¶</a>Step 4: Advanced Topics</h3>
<p>Once comfortable:</p>
<ul>
<li>Interval DP</li>
<li>Tree DP</li>
<li>State machine DP</li>
<li>Digit DP</li>
</ul>
<h3 id="Step-5-Problem-Solving-Framework"><a class="header-anchor" href="#Step-5-Problem-Solving-Framework">¶</a>Step 5: Problem-Solving Framework</h3>
<p>For any DP problem:</p>
<ol>
<li><strong>Identify</strong>: Is this a DP problem?</li>
<li><strong>State</strong>: What does <code>dp[i]</code> or <code>dp[i][j]</code> represent?</li>
<li><strong>Transition</strong>: How do states relate?</li>
<li><strong>Base cases</strong>: What are the smallest subproblems?</li>
<li><strong>Implementation</strong>: Code it up</li>
<li><strong>Optimize</strong>: Can you reduce space?</li>
</ol>
<h2 id="Summary-v3"><a class="header-anchor" href="#Summary-v3">¶</a>Summary</h2>
<p>Dynamic Programming is a powerful technique that transforms exponential-time recursive solutions into polynomial-time iterative ones. The key to mastering DP is:</p>
<ol>
<li><strong>Understand the principles</strong>: Optimal substructure and overlapping subproblems</li>
<li><strong>Follow the process</strong>: State definition → Transition → Base cases</li>
<li><strong>Practice patterns</strong>: 1D linear, 2D string/grid, knapsack, etc.</li>
<li><strong>Optimize space</strong>: Use rolling arrays, reduce dimensions when possible</li>
<li><strong>Build intuition</strong>: Start with simple problems and gradually increase difficulty</li>
</ol>
<p>Remember, DP is not about memorizing solutions—it’s about recognizing patterns and applying systematic problem-solving techniques. With practice, you’ll develop the intuition to identify DP problems and construct efficient solutions.</p>
<p>The problems covered in this article form the foundation of dynamic programming. Master these, and you’ll be well-equipped to tackle more advanced DP problems on LeetCode and in technical interviews. Keep practicing, and don’t be discouraged by initial difficulties—DP becomes more intuitive with experience.</p>
<h2 id="Additional-Resources"><a class="header-anchor" href="#Additional-Resources">¶</a>Additional Resources</h2>
<ul>
<li><strong>LeetCode DP Collection</strong>: Practice problems sorted by difficulty</li>
<li><strong>Classic DP Problems</strong>: Fibonacci, Knapsack, LCS, Edit Distance</li>
<li><strong>Pattern Recognition</strong>: Learn to identify DP patterns quickly</li>
<li><strong>Space Optimization</strong>: Master reducing space complexity</li>
</ul>
<p>Happy coding, and remember: every expert was once a beginner. Keep solving problems, and DP will become second nature!</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>Post title：LeetCode (6): Dynamic Programming Basics</li>
        <li>Post author：Chen Kai</li>
        <li>Create time：2023-03-16 00:00:00</li>
        <li>
            Post link：https://www.chenk.top/en/leetcode-dynamic-programming-basics/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/en/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/en/tags/Algorithms/">#Algorithms</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/en/tags/Dynamic-Programming/">#Dynamic Programming</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/en/leetcode-binary-search/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode (5): Binary Search</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/en/leetcode-sliding-window/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode (4): Sliding Window Technique</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情赞美帅气伟大的ck吧~',
                    lang: 'en'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-Dynamic-Programming"><span class="nav-number">1.</span> <span class="nav-text">What is Dynamic Programming?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Core-Principles"><span class="nav-number">2.</span> <span class="nav-text">Core Principles</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Optimal-Substructure"><span class="nav-number">2.1.</span> <span class="nav-text">Optimal Substructure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Overlapping-Subproblems"><span class="nav-number">2.2.</span> <span class="nav-text">Overlapping Subproblems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#When-to-Use-Dynamic-Programming"><span class="nav-number">2.3.</span> <span class="nav-text">When to Use Dynamic Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Three-Step-DP-Process"><span class="nav-number">3.</span> <span class="nav-text">The Three-Step DP Process</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Step-1-Define-the-State"><span class="nav-number">3.1.</span> <span class="nav-text">Step 1: Define the State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Step-2-Find-the-State-Transition"><span class="nav-number">3.2.</span> <span class="nav-text">Step 2: Find the State Transition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Step-3-Determine-Base-Cases-and-Initialization"><span class="nav-number">3.3.</span> <span class="nav-text">Step 3: Determine Base Cases and Initialization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#One-Dimensional-Dynamic-Programming"><span class="nav-number">4.</span> <span class="nav-text">One-Dimensional Dynamic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem-1-Climbing-Stairs"><span class="nav-number">4.1.</span> <span class="nav-text">Problem 1: Climbing Stairs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem-2-House-Robber"><span class="nav-number">4.2.</span> <span class="nav-text">Problem 2: House Robber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem-3-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-number">4.3.</span> <span class="nav-text">Problem 3: Best Time to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem-4-Coin-Change"><span class="nav-number">4.4.</span> <span class="nav-text">Problem 4: Coin Change</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Two-Dimensional-Dynamic-Programming"><span class="nav-number">5.</span> <span class="nav-text">Two-Dimensional Dynamic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem-5-Longest-Common-Subsequence-LCS"><span class="nav-number">5.1.</span> <span class="nav-text">Problem 5: Longest Common Subsequence (LCS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem-6-Edit-Distance"><span class="nav-number">5.2.</span> <span class="nav-text">Problem 6: Edit Distance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem-7-0-1-Knapsack-Problem"><span class="nav-number">5.3.</span> <span class="nav-text">Problem 7: 0&#x2F;1 Knapsack Problem</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Space-Optimization-Techniques"><span class="nav-number">6.</span> <span class="nav-text">Space Optimization Techniques</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Rolling-Array-1D-to-Variables"><span class="nav-number">6.1.</span> <span class="nav-text">1. Rolling Array (1D to Variables)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2D-to-1D-Row-by-Row-Processing"><span class="nav-number">6.2.</span> <span class="nav-text">2. 2D to 1D (Row-by-Row Processing)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Backward-Iteration-for-1D-Optimization"><span class="nav-number">6.3.</span> <span class="nav-text">3. Backward Iteration for 1D Optimization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DP-vs-Recursion-vs-Memoization"><span class="nav-number">7.</span> <span class="nav-text">DP vs Recursion vs Memoization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Pure-Recursion"><span class="nav-number">7.1.</span> <span class="nav-text">Pure Recursion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memoization-Top-Down-DP"><span class="nav-number">7.2.</span> <span class="nav-text">Memoization (Top-Down DP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tabulation-Bottom-Up-DP"><span class="nav-number">7.3.</span> <span class="nav-text">Tabulation (Bottom-Up DP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Comparison"><span class="nav-number">7.4.</span> <span class="nav-text">Comparison</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Complexity-Analysis-v18"><span class="nav-number">8.</span> <span class="nav-text">Complexity Analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Time-Complexity-v2"><span class="nav-number">8.1.</span> <span class="nav-text">Time Complexity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Space-Complexity-v2"><span class="nav-number">8.2.</span> <span class="nav-text">Space Complexity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Example-Analysis-Coin-Change"><span class="nav-number">8.3.</span> <span class="nav-text">Example Analysis: Coin Change</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Common-DP-Patterns"><span class="nav-number">9.</span> <span class="nav-text">Common DP Patterns</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Pattern-1-Linear-DP"><span class="nav-number">9.1.</span> <span class="nav-text">Pattern 1: Linear DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pattern-2-Interval-DP"><span class="nav-number">9.2.</span> <span class="nav-text">Pattern 2: Interval DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pattern-3-Tree-DP"><span class="nav-number">9.3.</span> <span class="nav-text">Pattern 3: Tree DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pattern-4-State-Machine-DP"><span class="nav-number">9.4.</span> <span class="nav-text">Pattern 4: State Machine DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pattern-5-Digit-DP"><span class="nav-number">9.5.</span> <span class="nav-text">Pattern 5: Digit DP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q-A-Common-Questions"><span class="nav-number">10.</span> <span class="nav-text">Q&amp;A: Common Questions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Q1-How-do-I-know-if-a-problem-is-a-DP-problem"><span class="nav-number">10.1.</span> <span class="nav-text">Q1: How do I know if a problem is a DP problem?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q2-Should-I-use-top-down-memoization-or-bottom-up-tabulation"><span class="nav-number">10.2.</span> <span class="nav-text">Q2: Should I use top-down (memoization) or bottom-up (tabulation)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q3-How-do-I-find-the-state-transition-equation"><span class="nav-number">10.3.</span> <span class="nav-text">Q3: How do I find the state transition equation?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q4-What-if-I-can%E2%80%99t-figure-out-the-DP-state"><span class="nav-number">10.4.</span> <span class="nav-text">Q4: What if I can’t figure out the DP state?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q5-How-do-I-optimize-space-in-2D-DP"><span class="nav-number">10.5.</span> <span class="nav-text">Q5: How do I optimize space in 2D DP?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q6-Can-DP-solve-all-optimization-problems"><span class="nav-number">10.6.</span> <span class="nav-text">Q6: Can DP solve all optimization problems?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q7-How-do-I-debug-DP-solutions"><span class="nav-number">10.7.</span> <span class="nav-text">Q7: How do I debug DP solutions?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q8-What%E2%80%99s-the-difference-between-DP-and-greedy-algorithms"><span class="nav-number">10.8.</span> <span class="nav-text">Q8: What’s the difference between DP and greedy algorithms?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q9-How-do-I-handle-DP-with-constraints-like-%E2%80%9Cat-most-k-transactions%E2%80%9D"><span class="nav-number">10.9.</span> <span class="nav-text">Q9: How do I handle DP with constraints (like “at most k transactions”)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q10-Is-DP-always-better-than-recursion"><span class="nav-number">10.10.</span> <span class="nav-text">Q10: Is DP always better than recursion?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Practice-Strategy"><span class="nav-number">11.</span> <span class="nav-text">Practice Strategy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Step-1-Master-the-Fundamentals"><span class="nav-number">11.1.</span> <span class="nav-text">Step 1: Master the Fundamentals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Step-2-Learn-1D-Patterns"><span class="nav-number">11.2.</span> <span class="nav-text">Step 2: Learn 1D Patterns</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Step-3-Master-2D-DP"><span class="nav-number">11.3.</span> <span class="nav-text">Step 3: Master 2D DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Step-4-Advanced-Topics"><span class="nav-number">11.4.</span> <span class="nav-text">Step 4: Advanced Topics</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Step-5-Problem-Solving-Framework"><span class="nav-number">11.5.</span> <span class="nav-text">Step 5: Problem-Solving Framework</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Summary-v3"><span class="nav-number">12.</span> <span class="nav-text">Summary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Additional-Resources"><span class="nav-number">13.</span> <span class="nav-text">Additional Resources</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
