<!DOCTYPE html>



<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode (5): Binary Search |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"en","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/en/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/en/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/en/tags">TAGS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode (5): Binary Search</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-06-15 00:00:00</span>
        <span class="mobile">2023-06-15 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/en/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/en/tags/Algorithms/">Algorithms</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>13.3k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>83 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>Binary search is one of the most fundamental and powerful algorithms
in computer science. Despite its apparent simplicity, mastering binary
search requires understanding subtle boundary conditions, recognizing
when to apply it, and knowing which template to use for different
problem types. This algorithm appears in countless real-world systems,
from database indexing to version control systems, and mastering it is
essential for any serious programmer. This article provides a
comprehensive guide to binary search, covering everything from basic
concepts to advanced applications in LeetCode problems, along with
practical insights into how this elegant algorithm powers modern
computing systems.</p>
<span id="more"></span>
<h2 id="introduction">Introduction</h2>
<p>Binary search is a divide-and-conquer algorithm that efficiently
locates a target value in a sorted array by repeatedly dividing the
search space in half. The key insight is that if we compare the target
with the middle element, we can eliminate half of the remaining elements
in each iteration.</p>
<p>The algorithm's elegance lies in its logarithmic time complexity:
while linear search takes <span class="math inline">\(O(n)\)</span>
time, binary search achieves <span class="math inline">\(O(\log
n)\)</span> time, making it indispensable for large datasets. To put
this in perspective, searching through a billion elements requires only
about 30 comparisons with binary search, compared to potentially a
billion comparisons with linear search. This dramatic efficiency
improvement makes binary search the algorithm of choice for search
engines, databases, and any system dealing with large sorted datasets.
However, the devil is in the details—off-by-one errors, boundary
handling, and choosing the right template can make or break your
solution. Many programmers struggle with these nuances, which is why
understanding the underlying principles and practicing with various
templates is crucial for mastery.</p>
<h2 id="fundamentals">Fundamentals</h2>
<h3 id="core-concept">Core Concept</h3>
<p>Binary search works on the principle of <strong>elimination</strong>:
at each step, we compare the target with the middle element and
eliminate half of the search space.</p>
<p><strong>Visualization:</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Initial array: [1, 3, 5, 7, 9, 11, 13, 15]</span><br><span class="line">Target: 7</span><br><span class="line"></span><br><span class="line">Step 1: Compare with middle (index 3, value 7)</span><br><span class="line">        [1, 3, 5, 7, 9, 11, 13, 15]</span><br><span class="line">                 ↑</span><br><span class="line">        7 == 7 → Found!</span><br></pre></td></tr></table></figure></p>
<p><strong>Key Requirements:</strong> 1. <strong>Sorted array</strong>:
The array must be sorted (ascending or descending) 2. <strong>Comparable
elements</strong>: Elements must support comparison operations 3.
<strong>Random access</strong>: We need <span class="math inline">\(O(1)\)</span> access to any element by index</p>
<h3 id="time-and-space-complexity">Time and Space Complexity</h3>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>Best case: <span class="math inline">\(O(1)\)</span> - target is at
the middle</li>
<li>Average case: <span class="math inline">\(O(\log n)\)</span> -
typical search</li>
<li>Worst case: <span class="math inline">\(O(\log n)\)</span> - target
at the end or not present</li>
</ul>
<p><strong>Space Complexity:</strong></p>
<ul>
<li>Iterative: <span class="math inline">\(O(1)\)</span> - only a few
variables</li>
<li>Recursive: <span class="math inline">\(O(\log n)\)</span> -
recursion stack depth</li>
</ul>
<p><strong>Why <span class="math inline">\(\log n\)</span>?</strong>
Each iteration eliminates half the elements. Starting with <span class="math inline">\(n\)</span> elements:</p>
<ul>
<li>After 1 iteration: <span class="math inline">\(\frac{n}{2}\)</span>
elements remain</li>
<li>After 2 iterations: <span class="math inline">\(\frac{n}{4}\)</span>
elements remain</li>
<li>After <span class="math inline">\(k\)</span> iterations: <span class="math inline">\(\frac{n}{2^k}\)</span> elements remain</li>
</ul>
<p>We stop when <span class="math inline">\(\frac{n}{2^k} \leq
1\)</span>, which gives us <span class="math inline">\(k \geq \log_2
n\)</span>. Therefore, we need at most <span class="math inline">\(\lceil \log_2 n \rceil\)</span> iterations.</p>
<h2 id="basic-binary-search-template">Basic Binary Search Template</h2>
<p>The most straightforward binary search finds an exact match in a
sorted array.</p>
<h3 id="standard-implementation">Standard Implementation</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Standard binary search for exact match.</span></span><br><span class="line"><span class="string">    Returns index if found, -1 otherwise.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span>  <span class="comment"># Avoid overflow</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>Key Points:</strong> 1. <strong>Loop condition</strong>:
<code>left &lt;= right</code> ensures we check all valid positions 2.
<strong>Mid calculation</strong>:
<code>left + (right - left) // 2</code> prevents integer overflow 3.
<strong>Boundary updates</strong>: <code>mid + 1</code> and
<code>mid - 1</code> exclude the current mid</p>
<h3 id="why-left-right---left-2">Why
<code>left + (right - left) // 2</code>?</h3>
<p>Using <code>(left + right) // 2</code> can cause integer overflow
when <code>left</code> and <code>right</code> are large:</p>
<ul>
<li>If <code>left = 2^31 - 1</code> and <code>right = 2^31 - 1</code>,
then <code>left + right</code> exceeds <code>INT_MAX</code></li>
<li><code>left + (right - left) // 2</code> is mathematically equivalent
but avoids overflow</li>
</ul>
<h3 id="example-walkthrough">Example Walkthrough</h3>
<p><strong>Problem</strong>: Find 7 in
<code>[1, 3, 5, 7, 9, 11, 13, 15]</code></p>
<p>Let's trace through this step by step. We start with the entire array
as our search space, with <code>left=0</code> pointing to the first
element and <code>right=7</code> pointing to the last element. The array
has 8 elements, so our initial search space contains indices 0 through
7. In the first iteration, we calculate
<code>mid = 0 + (7 - 0) // 2 = 3</code>, which gives us the middle
element. We compare <code>nums[3] = 7</code> with our target value 7,
and they match perfectly. Since we found an exact match, we immediately
return index 3. This demonstrates the best-case scenario where binary
search finds the target in constant time.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Initial: left=0, right=7</span><br><span class="line">Iteration 1: mid=3, nums[3]=7 == 7 → Found at index 3</span><br></pre></td></tr></table></figure>
<p><strong>Problem</strong>: Find 6 in
<code>[1, 3, 5, 7, 9, 11, 13, 15]</code></p>
<p>This example demonstrates a more typical case where the target
doesn't exist in the array. We start with the same initial boundaries.
In the first iteration, <code>mid=3</code> gives us
<code>nums[3]=7</code>, which is greater than our target 6. Since the
array is sorted in ascending order, we know that all elements to the
right of index 3 (values 7, 9, 11, 13, 15) are also greater than 6, so
we can safely eliminate the entire right half. We update
<code>right = mid - 1 = 2</code>, effectively reducing our search space
to indices 0 through 2.</p>
<p>In the second iteration, we calculate
<code>mid = 0 + (2 - 0) // 2 = 1</code>, giving us
<code>nums[1]=3</code>. This value is less than our target 6, so we
eliminate the left half (indices 0 and 1) and update
<code>left = mid + 1 = 2</code>. Now our search space contains only
index 2.</p>
<p>In the third iteration, <code>mid=2</code> gives us
<code>nums[2]=5</code>, which is still less than 6. We update
<code>left = mid + 1 = 3</code>. At this point, <code>left=3</code> and
<code>right=2</code>, which means <code>left &gt; right</code>,
violating our loop condition. This indicates that we've exhausted all
possible positions where the target could exist, so we exit the loop and
return -1 to indicate the target was not found.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Initial: left=0, right=7</span><br><span class="line">Iteration 1: mid=3, nums[3]=7 &gt; 6 → right=2 (eliminate right half)</span><br><span class="line">Iteration 2: mid=1, nums[1]=3 &lt; 6 → left=2 (eliminate left half)</span><br><span class="line">Iteration 3: mid=2, nums[2]=5 &lt; 6 → left=3 (eliminate current position)</span><br><span class="line">Iteration 4: left=3 &gt; right=2 → Exit, return -1</span><br></pre></td></tr></table></figure>
<p>This walkthrough illustrates how binary search systematically narrows
down the search space, eliminating half of the remaining possibilities
at each step until either the target is found or we've confirmed it
doesn't exist.</p>
<h2 id="boundary-handling-left-and-right-bound-templates">Boundary
Handling: Left and Right Bound Templates</h2>
<p>Many LeetCode problems require finding the <strong>first</strong> or
<strong>last</strong> occurrence of a target, or the <strong>insertion
position</strong>. These require modified templates.</p>
<h3 id="left-bound-template-first-occurrence">Left Bound Template (First
Occurrence)</h3>
<p>Finds the <strong>leftmost</strong> position where target appears, or
where it should be inserted.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">left_bound</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Find leftmost position of target.</span></span><br><span class="line"><span class="string">    Returns index of first occurrence, or insertion position if not found.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)  <span class="comment"># Note: right = len(nums), not len(nums) - 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid  <span class="comment"># Don&#x27;t exclude mid, it might be the answer</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># left is the insertion position</span></span><br></pre></td></tr></table></figure>
<p><strong>Key Differences:</strong> 1. <strong>Right boundary</strong>:
<code>right = len(nums)</code> instead of <code>len(nums) - 1</code> 2.
<strong>Loop condition</strong>: <code>left &lt; right</code> instead of
<code>left &lt;= right</code> 3. <strong>Right update</strong>:
<code>right = mid</code> instead of <code>right = mid - 1</code> 4.
<strong>Return value</strong>: Returns <code>left</code>, which is the
insertion position</p>
<p><strong>Why these changes?</strong></p>
<ul>
<li><code>right = len(nums)</code> allows returning insertion position
beyond array</li>
<li><code>left &lt; right</code> ensures we don't miss the boundary
case</li>
<li><code>right = mid</code> keeps mid in search space (it might be the
answer)</li>
</ul>
<h3 id="right-bound-template-last-occurrence">Right Bound Template (Last
Occurrence)</h3>
<p>Finds the <strong>rightmost</strong> position where target
appears.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">right_bound</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Find rightmost position of target.</span></span><br><span class="line"><span class="string">    Returns index of last occurrence, or -1 if not found.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># Move right to find last occurrence</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># left is one position after the last occurrence</span></span><br><span class="line">    <span class="keyword">if</span> left == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># Target is smaller than all elements</span></span><br><span class="line">    <span class="keyword">if</span> nums[left - <span class="number">1</span>] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># Target not found</span></span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>Key Points:</strong></p>
<ul>
<li>When <code>nums[mid] == target</code>, we continue searching right
(<code>left = mid + 1</code>)</li>
<li>After loop, <code>left</code> points to the position after the last
occurrence</li>
<li>Return <code>left - 1</code> if target exists, <code>-1</code>
otherwise</li>
</ul>
<h3 id="visual-comparison">Visual Comparison</h3>
<p><strong>Finding target = 5 in
<code>[1, 3, 5, 5, 5, 7, 9]</code>:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Left Bound:</span><br><span class="line"></span><br><span class="line">- Returns index 2 (first occurrence)</span><br><span class="line"></span><br><span class="line">Right Bound:</span><br><span class="line"></span><br><span class="line">- Returns index 4 (last occurrence)</span><br><span class="line"></span><br><span class="line">Standard Search:</span><br><span class="line"></span><br><span class="line">- May return any of indices 2, 3, or 4 (implementation dependent)</span><br></pre></td></tr></table></figure>
<h2 id="classic-leetcode-problems">Classic LeetCode Problems</h2>
<h3 id="problem-1-binary-search-leetcode-704">Problem 1: Binary Search
(LeetCode 704)</h3>
<p><strong>Problem Statement:</strong> Given an array of integers
<code>nums</code> which is sorted in ascending order, and an integer
<code>target</code>, write a function to search <code>target</code> in
<code>nums</code>. If <code>target</code> exists, then return its index.
Otherwise, return <code>-1</code>.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>Edge Cases:</strong></p>
<ul>
<li>Empty array: <code>[]</code> → Returns <code>-1</code></li>
<li>Single element: <code>[5]</code>, target <code>5</code> → Returns
<code>0</code></li>
<li>Target not present: <code>[1, 2, 3]</code>, target <code>4</code> →
Returns <code>-1</code></li>
<li>Target at boundaries: <code>[1, 2, 3]</code>, target <code>1</code>
or <code>3</code> → Returns <code>0</code> or <code>2</code></li>
</ul>
<p><strong>Time Complexity:</strong> <span class="math inline">\(O(\log
n)\)</span><br>
<strong>Space Complexity:</strong> <span class="math inline">\(O(1)\)</span></p>
<h3 id="problem-2-search-insert-position-leetcode-35">Problem 2: Search
Insert Position (LeetCode 35)</h3>
<p><strong>Problem Statement:</strong> Given a sorted array of distinct
integers and a target value, return the index if the target is found. If
not, return the index where it would be if it were inserted in
order.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>Example:</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nums = [1, 3, 5, 6], target = 5</span><br><span class="line">→ Returns 2 (found at index 2)</span><br><span class="line"></span><br><span class="line">nums = [1, 3, 5, 6], target = 2</span><br><span class="line">→ Returns 1 (should be inserted at index 1)</span><br><span class="line"></span><br><span class="line">nums = [1, 3, 5, 6], target = 7</span><br><span class="line">→ Returns 4 (should be inserted at end)</span><br></pre></td></tr></table></figure></p>
<p><strong>Detailed Walkthrough for target = 2:</strong></p>
<p>Let's trace through the case where the target doesn't exist and we
need to find the insertion position. We initialize <code>left=0</code>
and <code>right=4</code> (note that <code>right = len(nums)</code>, not
<code>len(nums) - 1</code>, because we need to handle the case where the
target should be inserted at the end).</p>
<p>In iteration 1, <code>mid = 0 + (4 - 0) // 2 = 2</code>. We compare
<code>nums[2]=5</code> with target <code>2</code>. Since
<code>5 &gt;= 2</code>, we set <code>right = mid = 2</code> to search
for the leftmost insertion position.</p>
<p>In iteration 2, <code>left=0</code> and <code>right=2</code>, so
<code>mid = 0 + (2 - 0) // 2 = 1</code>. We compare
<code>nums[1]=3</code> with target <code>2</code>. Since
<code>3 &gt;= 2</code>, we set <code>right = mid = 1</code>.</p>
<p>In iteration 3, <code>left=0</code> and <code>right=1</code>, so
<code>mid = 0 + (1 - 0) // 2 = 0</code>. We compare
<code>nums[0]=1</code> with target <code>2</code>. Since
<code>1 &lt; 2</code>, we set <code>left = mid + 1 = 1</code>.</p>
<p>Now <code>left=1</code> equals <code>right=1</code>, so we exit the
loop. The function returns <code>left=1</code>, which is indeed the
correct insertion position: if we insert 2 at index 1, the array becomes
<code>[1, 2, 3, 5, 6]</code>, maintaining sorted order.</p>
<p><strong>Key Insight:</strong> This is exactly the left bound
template! The insertion position is the leftmost position where we could
place the target. The template naturally handles all cases: when the
target exists, it returns the first occurrence; when it doesn't exist,
it returns where it should be inserted to maintain sorted order.</p>
<p><strong>Time Complexity:</strong> <span class="math inline">\(O(\log
n)\)</span><br>
<strong>Space Complexity:</strong> <span class="math inline">\(O(1)\)</span></p>
<h3 id="problem-3-find-first-and-last-position-leetcode-34">Problem 3:
Find First and Last Position (LeetCode 34)</h3>
<p><strong>Problem Statement:</strong> Given an array of integers
<code>nums</code> sorted in non-decreasing order, find the starting and
ending position of a given <code>target</code> value. If
<code>target</code> is not found, return <code>[-1, -1]</code>.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">left_bound</span>(<span class="params">nums, target</span>):</span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">right_bound</span>(<span class="params">nums, target</span>):</span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="keyword">return</span> left - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        left_idx = left_bound(nums, target)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Check if target exists</span></span><br><span class="line">        <span class="keyword">if</span> left_idx == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[left_idx] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        right_idx = right_bound(nums, target)</span><br><span class="line">        <span class="keyword">return</span> [left_idx, right_idx]</span><br></pre></td></tr></table></figure>
<p><strong>Walkthrough for <code>nums = [5, 7, 7, 8, 8, 10]</code>,
<code>target = 8</code>:</strong></p>
<p>This problem requires finding both the first and last occurrence of
the target value 8 in an array that contains duplicates. The key insight
is that we need to use two different binary search strategies: one to
find the leftmost occurrence and another to find the rightmost
occurrence.</p>
<p><strong>Finding the Left Bound (First Occurrence):</strong></p>
<p>We initialize <code>left=0</code> and <code>right=6</code> (note that
<code>right = len(nums)</code>, not <code>len(nums) - 1</code>, because
we're using the left-bound template). Our goal is to find the leftmost
position where we could insert the target value 8, which will be the
first occurrence if it exists.</p>
<p>In iteration 1, we calculate <code>mid = 0 + (6 - 0) // 2 = 3</code>.
However, wait—let me recalculate:
<code>mid = 0 + (6 - 0) // 2 = 3</code>. Actually, let's trace more
carefully. With <code>left=0</code> and <code>right=6</code>,
<code>mid = 0 + (6 - 0) // 2 = 3</code>. We check
<code>nums[3]=8</code>, which equals our target. In the left-bound
template, when <code>nums[mid] &gt;= target</code>, we set
<code>right = mid</code> to continue searching left, because
<code>mid</code> itself might be the leftmost occurrence. So
<code>right=3</code>.</p>
<p>In iteration 2, <code>left=0</code> and <code>right=3</code>, so
<code>mid = 0 + (3 - 0) // 2 = 1</code>. We check
<code>nums[1]=7</code>, which is less than 8. Since we're looking for
the leftmost position where the value is at least 8, we know everything
to the left of index 1 is too small. We update
<code>left = mid + 1 = 2</code>.</p>
<p>In iteration 3, <code>left=2</code> and <code>right=3</code>, so
<code>mid = 2 + (3 - 2) // 2 = 2</code>. We check
<code>nums[2]=7</code>, which is still less than 8. We update
<code>left = mid + 1 = 3</code>.</p>
<p>Now <code>left=3</code> equals <code>right=3</code>, so we exit the
loop. The left bound is 3, meaning the first occurrence of 8 is at index
3.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Left Bound:</span><br><span class="line"></span><br><span class="line">- Initial: left=0, right=6</span><br><span class="line">- Iteration 1: mid=3, nums[3]=8 &gt;= 8 → right=3 (keep searching left)</span><br><span class="line">- Iteration 2: mid=1, nums[1]=7 &lt; 8 → left=2 (eliminate left portion)</span><br><span class="line">- Iteration 3: mid=2, nums[2]=7 &lt; 8 → left=3 (eliminate current position)</span><br><span class="line">- left=3 == right=3 → Exit, return 3</span><br></pre></td></tr></table></figure>
<p><strong>Finding the Right Bound (Last Occurrence):</strong></p>
<p>For the right bound, we want to find the rightmost occurrence. We use
a different strategy: when <code>nums[mid] &lt;= target</code>, we
continue searching right by setting <code>left = mid + 1</code>, because
we want to find the last occurrence.</p>
<p>In iteration 1, <code>left=0</code> and <code>right=6</code>,
<code>mid=3</code>. <code>nums[3]=8 &lt;= 8</code>, so we set
<code>left = mid + 1 = 4</code> to continue searching right.</p>
<p>In iteration 2, <code>left=4</code> and <code>right=6</code>,
<code>mid=5</code>. <code>nums[5]=10 &gt; 8</code>, so we set
<code>right=5</code> to search left.</p>
<p>In iteration 3, <code>left=4</code> and <code>right=5</code>,
<code>mid=4</code>. <code>nums[4]=8 &lt;= 8</code>, so we set
<code>left = mid + 1 = 5</code>.</p>
<p>Now <code>left=5</code> equals <code>right=5</code>, so we exit. The
right bound algorithm returns <code>left - 1 = 4</code>, which is the
last occurrence of 8.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Right Bound:</span><br><span class="line"></span><br><span class="line">- Initial: left=0, right=6</span><br><span class="line">- Iteration 1: mid=3, nums[3]=8 &lt;= 8 → left=4 (keep searching right)</span><br><span class="line">- Iteration 2: mid=5, nums[5]=10 &gt; 8 → right=5 (search left)</span><br><span class="line">- Iteration 3: mid=4, nums[4]=8 &lt;= 8 → left=5 (keep searching right)</span><br><span class="line">- left=5 == right=5 → Exit, return 4 (left - 1)</span><br></pre></td></tr></table></figure>
<p><strong>Result: [3, 4]</strong></p>
<p>After finding both bounds, we verify that the target exists by
checking if <code>nums[left_idx] == target</code>. Since
<code>nums[3] == 8</code>, we confirm the target exists and return
<code>[3, 4]</code> as the range of occurrences.</p>
<p><strong>Time Complexity:</strong> <span class="math inline">\(O(\log
n)\)</span><br>
<strong>Space Complexity:</strong> <span class="math inline">\(O(1)\)</span></p>
<h3 id="problem-4-search-in-rotated-sorted-array-leetcode-33">Problem 4:
Search in Rotated Sorted Array (LeetCode 33)</h3>
<p><strong>Problem Statement:</strong> There is an integer array
<code>nums</code> sorted in ascending order (with distinct values).
Prior to being passed to your function, <code>nums</code> is rotated at
an unknown pivot index. Given the target value, return the index of
<code>target</code> in <code>nums</code>, or <code>-1</code> if it is
not in <code>nums</code>.</p>
<p><strong>Key Insight:</strong> Even though the array is rotated, at
least one half is always sorted. We can use this property to eliminate
half the search space.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Left half is sorted</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="comment"># Right half is sorted</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>Visualization:</strong></p>
<p>This problem demonstrates one of the most elegant applications of
binary search: even when an array isn't fully sorted, we can still use
binary search by identifying which half maintains sorted order. The key
insight is that in a rotated sorted array, at least one half is always
sorted, and we can use this property to eliminate half the search
space.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Rotated array: [4, 5, 6, 7, 0, 1, 2]</span><br><span class="line">Target: 0</span><br><span class="line"></span><br><span class="line">Step 1: mid=3, nums[3]=7</span><br><span class="line">        We check if the left half is sorted: nums[0]=4 &lt;= nums[3]=7 ✓</span><br><span class="line">        Left half [4,5,6,7] is sorted</span><br><span class="line">        Is target 0 in the sorted left half&#x27;s range [4,7]? No</span><br><span class="line">        Therefore, target must be in the right half</span><br><span class="line">        → Search right half: left=4</span><br><span class="line"></span><br><span class="line">Step 2: mid=5, nums[5]=1</span><br><span class="line">        We check if the left half is sorted: nums[4]=0 &lt;= nums[5]=1 ✓</span><br><span class="line">        Actually, let&#x27;s check the right half: nums[5]=1 &gt; nums[6]=2 ✗</span><br><span class="line">        So the right half [1,2] is sorted (but let&#x27;s verify: nums[5]=1 &lt;= nums[6]=2 ✓)</span><br><span class="line">        Wait, let me reconsider. With left=4, right=6, mid=5:</span><br><span class="line">        Check left half [4,5]: nums[4]=0 &lt;= nums[5]=1 ✓, so left half is sorted</span><br><span class="line">        Is target 0 in [0,1]? Yes!</span><br><span class="line">        → Search left: right=4</span><br><span class="line"></span><br><span class="line">Step 3: mid=4, nums[4]=0 == 0 → Found!</span><br></pre></td></tr></table></figure>
<p>Let me provide a clearer step-by-step visualization:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Array: [4, 5, 6, 7, 0, 1, 2]</span><br><span class="line">Indices: 0  1  2  3  4  5  6</span><br><span class="line">Target: 0</span><br><span class="line"></span><br><span class="line">Initial: left=0, right=6</span><br><span class="line"></span><br><span class="line">Iteration 1:</span><br><span class="line">  mid = 3, nums[3] = 7</span><br><span class="line">  Check: nums[left]=4 &lt;= nums[mid]=7? Yes → Left half [0..3] is sorted</span><br><span class="line">  Is target in sorted left half range [4,7]? No (0 &lt; 4)</span><br><span class="line">  → Target must be in right half [4..6]</span><br><span class="line">  Update: left = 4</span><br><span class="line"></span><br><span class="line">Iteration 2:</span><br><span class="line">  left=4, right=6</span><br><span class="line">  mid = 5, nums[5] = 1</span><br><span class="line">  Check: nums[left]=0 &lt;= nums[mid]=1? Yes → Left half [4..5] is sorted</span><br><span class="line">  Is target in sorted left half range [0,1]? Yes (0 is in [0,1])</span><br><span class="line">  → Target is in left half [4..5]</span><br><span class="line">  Update: right = 4</span><br><span class="line"></span><br><span class="line">Iteration 3:</span><br><span class="line">  left=4, right=4</span><br><span class="line">  mid = 4, nums[4] = 0</span><br><span class="line">  nums[4] == target → Found at index 4!</span><br></pre></td></tr></table></figure>
<p>This visualization shows how we systematically eliminate half the
search space at each step, even though the array is rotated. The
critical observation is that by checking which half is sorted and
whether the target falls within that sorted half's range, we can always
eliminate half the possibilities.</p>
<p><strong>Edge Cases:</strong></p>
<ul>
<li>Not rotated: <code>[1, 2, 3, 4, 5]</code> → Works normally</li>
<li>Fully rotated: <code>[5, 1, 2, 3, 4]</code> → Handled correctly</li>
<li>Single element: <code>[1]</code> → Returns correct index</li>
<li>Target not present: Returns <code>-1</code></li>
</ul>
<p><strong>Time Complexity:</strong> <span class="math inline">\(O(\log
n)\)</span><br>
<strong>Space Complexity:</strong> <span class="math inline">\(O(1)\)</span></p>
<h3 id="problem-5-find-peak-element-leetcode-162">Problem 5: Find Peak
Element (LeetCode 162)</h3>
<p><strong>Problem Statement:</strong> A peak element is an element that
is strictly greater than its neighbors. Given a 0-indexed integer array
<code>nums</code>, find a peak element, and return its index. If the
array contains multiple peaks, return the index to any of the peaks. You
may imagine that `nums[-1] = nums[n] = -$.</p>
<p><strong>Key Insight:</strong> We can use binary search even though
the array isn't sorted! If <code>nums[mid] &lt; nums[mid + 1]</code>,
there must be a peak on the right (because we can always go up).
Similarly, if <code>nums[mid] &gt; nums[mid + 1]</code>, there's a peak
on the left.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># Peak is on the right</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Peak is on the left (including mid)</span></span><br><span class="line">                right = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>Visualization:</strong></p>
<p>This problem is fascinating because it demonstrates that binary
search doesn't always require a fully sorted array. Instead, it relies
on a specific property: if we're on an upward slope, there must be a
peak to the right; if we're on a downward slope, there must be a peak to
the left (or we're already at a peak).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Array: [1, 2, 3, 1]</span><br><span class="line">Indices: 0  1  2  3</span><br><span class="line"></span><br><span class="line">Initial: left=0, right=3</span><br><span class="line"></span><br><span class="line">Step 1: mid=1, nums[1]=2</span><br><span class="line">        Compare: nums[1]=2 &lt; nums[2]=3</span><br><span class="line">        We&#x27;re on an upward slope → Peak must be to the right</span><br><span class="line">        Reasoning: Since nums[2] &gt; nums[1], and we can continue going right,</span><br><span class="line">                   and we know nums[n] = -∞, there must be a peak somewhere to the right</span><br><span class="line">        → Move right: left=2</span><br><span class="line"></span><br><span class="line">Step 2: left=2, right=3</span><br><span class="line">        mid=2, nums[2]=3</span><br><span class="line">        Compare: nums[2]=3 &gt; nums[3]=1</span><br><span class="line">        We&#x27;re on a downward slope → Peak is to the left (possibly at current position)</span><br><span class="line">        Reasoning: Since nums[2] &gt; nums[3], we&#x27;re going down. The peak could be</span><br><span class="line">                   at index 2 itself, or somewhere to the left. Since nums[-1] = -∞,</span><br><span class="line">                   there must be a peak in the left portion including index 2.</span><br><span class="line">        → Move left: right=2</span><br><span class="line"></span><br><span class="line">Step 3: left=2 == right=2 → Exit</span><br><span class="line">        Return: 2 (which is indeed a peak: 3 &gt; 2 and 3 &gt; 1)</span><br></pre></td></tr></table></figure>
<p><strong>Why this works:</strong> The key insight is that we can
always make progress toward a peak. If
<code>nums[mid] &lt; nums[mid + 1]</code>, we know we're ascending, and
since the boundary is -∞, there must be a peak ahead. If
<code>nums[mid] &gt; nums[mid + 1]</code>, we're descending, and the
peak is behind us (possibly at mid itself). This property guarantees
that binary search will converge to a peak.</p>
<p><strong>Why This Works:</strong></p>
<ul>
<li>If <code>nums[mid] &lt; nums[mid + 1]</code>, we're on an upward
slope. Since <code>nums[n] = -\infty</code>, there must be a peak to the
right.</li>
<li>If <code>nums[mid] &gt; nums[mid + 1]</code>, we're on a downward
slope. Since <code>nums[-1] = -\infty</code>, there must be a peak to
the left (possibly at mid).</li>
</ul>
<p><strong>Time Complexity:</strong> <span class="math inline">\(O(\log
n)\)</span><br>
<strong>Space Complexity:</strong> <span class="math inline">\(O(1)\)</span></p>
<h3 id="problem-6-search-a-2d-matrix-leetcode-74">Problem 6: Search a 2D
Matrix (LeetCode 74)</h3>
<p><strong>Problem Statement:</strong> Write an efficient algorithm that
searches for a value <code>target</code> in an <code>m x n</code>
integer matrix <code>matrix</code>. This matrix has the following
properties:</p>
<ul>
<li>Integers in each row are sorted from left to right</li>
<li>The first integer of each row is greater than the last integer of
the previous row</li>
</ul>
<p><strong>Approach 1: Treat as 1D Array</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        left, right = <span class="number">0</span>, m * n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            row, col = mid // n, mid % n</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][col] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>Approach 2: Two Binary Searches</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Binary search for row</span></span><br><span class="line">        top, bottom = <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> top &lt; bottom:</span><br><span class="line">            mid = top + (bottom - top) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] &lt;= target &lt;= matrix[mid][-<span class="number">1</span>]:</span><br><span class="line">                top = bottom = mid</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[mid][<span class="number">0</span>] &gt; target:</span><br><span class="line">                bottom = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                top = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Binary search within row</span></span><br><span class="line">        row = top</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(matrix[row]) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[row][mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>Example:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Matrix:</span><br><span class="line">[</span><br><span class="line">  [1,  3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 60]</span><br><span class="line">]</span><br><span class="line">Target: 3</span><br><span class="line"></span><br><span class="line">Approach 1:</span><br><span class="line"></span><br><span class="line">- Treat as [1,3,5,7,10,11,16,20,23,30,34,60]</span><br><span class="line">- Binary search finds index 1 → row=0, col=1 → Found!</span><br><span class="line"></span><br><span class="line">Approach 2:</span><br><span class="line"></span><br><span class="line">- Find row: target 3 is in row 0</span><br><span class="line">- Search row 0: Found at index 1</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity:</strong> <span class="math inline">\(O(\log(mn))\)</span> for approach 1, <span class="math inline">\(O(\log m + \log n)\)</span> for approach 2<br>
<strong>Space Complexity:</strong> <span class="math inline">\(O(1)\)</span></p>
<h3 id="problem-7-search-a-2d-matrix-ii-leetcode-240">Problem 7: Search
a 2D Matrix II (LeetCode 240)</h3>
<p><strong>Problem Statement:</strong> Write an efficient algorithm that
searches for a value <code>target</code> in an <code>m x n</code>
integer matrix <code>matrix</code>. This matrix has the following
properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right</li>
<li>Integers in each column are sorted in ascending from top to
bottom</li>
</ul>
<p><strong>Key Insight:</strong> Unlike Problem 6, we can't treat this
as a 1D array because rows don't connect seamlessly. However, we can use
a clever approach: start from the top-right corner and eliminate one row
or column at a time.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># Start from top-right corner</span></span><br><span class="line">        row, col = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> row &lt; m <span class="keyword">and</span> col &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][col] &gt; target:</span><br><span class="line">                <span class="comment"># Current element is too large, eliminate this column</span></span><br><span class="line">                col -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Current element is too small, eliminate this row</span></span><br><span class="line">                row += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>Visualization:</strong></p>
<p>This problem requires a clever insight: we can't use standard binary
search because the matrix doesn't have the same properties as Problem 6.
However, by starting from the top-right corner, we can eliminate either
an entire row or an entire column with each comparison, guaranteeing
progress.</p>
<p>The key observation is that from the top-right corner:</p>
<ul>
<li>All elements to the left are smaller (because rows are sorted
left-to-right)</li>
<li>All elements below are larger (because columns are sorted
top-to-bottom)</li>
<li>This property allows us to eliminate either a row or column at each
step</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Matrix:</span><br><span class="line">[</span><br><span class="line">  [1,  4,  7,  11, 15],</span><br><span class="line">  [2,  5,  8,  12, 19],</span><br><span class="line">  [3,  6,  9,  16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">Target: 5</span><br><span class="line"></span><br><span class="line">Step 1: Start at (0, 4) = 15</span><br><span class="line">        Compare: 15 &gt; 5</span><br><span class="line">        Since 15 &gt; 5 and the column is sorted top-to-bottom,</span><br><span class="line">        all elements below (15) in this column are also &gt; 5</span><br><span class="line">        → Eliminate entire column 4, move left: col = 3</span><br><span class="line"></span><br><span class="line">Step 2: At (0, 3) = 11</span><br><span class="line">        Compare: 11 &gt; 5</span><br><span class="line">        Same reasoning: all elements below 11 in column 3 are &gt; 5</span><br><span class="line">        → Eliminate entire column 3, move left: col = 2</span><br><span class="line"></span><br><span class="line">Step 3: At (0, 2) = 7</span><br><span class="line">        Compare: 7 &gt; 5</span><br><span class="line">        All elements below 7 in column 2 are &gt; 5</span><br><span class="line">        → Eliminate entire column 2, move left: col = 1</span><br><span class="line"></span><br><span class="line">Step 4: At (0, 1) = 4</span><br><span class="line">        Compare: 4 &lt; 5</span><br><span class="line">        Since 4 &lt; 5 and the row is sorted left-to-right,</span><br><span class="line">        all elements to the left of 4 in this row are also &lt; 5</span><br><span class="line">        → Eliminate entire row 0, move down: row = 1</span><br><span class="line"></span><br><span class="line">Step 5: At (1, 1) = 5</span><br><span class="line">        Compare: 5 == 5 → Found!</span><br></pre></td></tr></table></figure>
<p>This approach is elegant because it guarantees that we eliminate
either a row or column at each step. In the worst case, we eliminate all
rows and columns except one, giving us <span class="math inline">\(O(m +
n)\)</span> time complexity, which is optimal for this problem
structure. The key is recognizing the sorted properties of both rows and
columns and leveraging them to make progress in two dimensions
simultaneously.</p>
<p><strong>Why This Works:</strong></p>
<ul>
<li>Starting from top-right, all elements to the left are smaller, all
elements below are larger</li>
<li>If <code>matrix[row][col] &gt; target</code>, everything in this
column below is also larger → eliminate column</li>
<li>If <code>matrix[row][col] &lt; target</code>, everything in this row
to the left is also smaller → eliminate row</li>
<li>Each comparison eliminates either a row or a column, guaranteeing
progress</li>
</ul>
<p><strong>Time Complexity:</strong> <span class="math inline">\(O(m +
n)\)</span> - at most <span class="math inline">\(m + n\)</span>
comparisons<br>
<strong>Space Complexity:</strong> <span class="math inline">\(O(1)\)</span></p>
<h3 id="problem-8-find-k-closest-elements-leetcode-658">Problem 8: Find
K Closest Elements (LeetCode 658)</h3>
<p><strong>Problem Statement:</strong> Given a sorted integer array
<code>arr</code>, two integers <code>k</code> and <code>x</code>, return
the <code>k</code> closest integers to <code>x</code> in the array. The
result should also be sorted in ascending order. An integer
<code>a</code> is closer to <code>x</code> than an integer
<code>b</code> if <code>|a - x| &lt; |b - x|</code>, or
<code>|a - x| == |b - x|</code> and <code>a &lt; b</code>.</p>
<p><strong>Key Insight:</strong> We need to find the left boundary of
the window containing <code>k</code> closest elements. We can use binary
search to find the optimal starting position.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findClosestElements</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># Binary search for the left boundary of the window</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - k</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Compare distances: if arr[mid+k] is closer than arr[mid], move right</span></span><br><span class="line">            <span class="comment"># We want to minimize the distance, so if right side is better, move left</span></span><br><span class="line">            <span class="keyword">if</span> x - arr[mid] &gt; arr[mid + k] - x:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arr[left:left + k]</span><br></pre></td></tr></table></figure>
<p><strong>Explanation:</strong></p>
<ul>
<li>We're searching for the left boundary of a window of size
<code>k</code></li>
<li>The search space is <code>[0, len(arr) - k]</code> because we need
<code>k</code> elements</li>
<li>At each step, compare <code>arr[mid]</code> and
<code>arr[mid + k]</code>:
<ul>
<li>If <code>x - arr[mid] &gt; arr[mid + k] - x</code>, the right side
is closer → move left boundary right</li>
<li>Otherwise, the left side is closer or equal → keep searching
left</li>
</ul></li>
</ul>
<p><strong>Example:</strong></p>
<p>This problem requires finding a window of k elements that are closest
to x. The key insight is that we can use binary search to find the
optimal starting position of this window. We compare the distances from
x to the leftmost and rightmost elements of a candidate window to
determine which direction to search.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">arr = [1, 2, 3, 4, 5], k = 4, x = 3</span><br><span class="line"></span><br><span class="line">We need to find 4 closest elements to 3. The possible windows are:</span><br><span class="line"></span><br><span class="line">- Window starting at 0: [1, 2, 3, 4] → distances: |1-3|=2, |2-3|=1, |3-3|=0, |4-3|=1</span><br><span class="line">- Window starting at 1: [2, 3, 4, 5] → distances: |2-3|=1, |3-3|=0, |4-3|=1, |5-3|=2</span><br><span class="line"></span><br><span class="line">Initial: left = 0, right = 1 (len - k = 5 - 4 = 1)</span><br><span class="line">         We can only start windows at positions 0 or 1 (since we need 4 elements)</span><br><span class="line"></span><br><span class="line">Iteration 1: mid = 0</span><br><span class="line">             Consider window starting at mid=0: [arr[0], arr[1], arr[2], arr[3]] = [1, 2, 3, 4]</span><br><span class="line">             Compare distances:</span><br><span class="line"></span><br><span class="line">               - Distance from x to leftmost: x - arr[0] = 3 - 1 = 2</span><br><span class="line">               - Distance from x to rightmost: arr[0+k] - x = arr[4] - x = 5 - 3 = 2</span><br><span class="line">             </span><br><span class="line">             The comparison x - arr[mid] &gt; arr[mid + k] - x checks:</span><br><span class="line"></span><br><span class="line">               - If the rightmost element is closer than the leftmost, move window right</span><br><span class="line">               - If leftmost is closer or equal, keep searching left</span><br><span class="line">             </span><br><span class="line">             Here: 2 &gt; 2? No → The leftmost element is not significantly farther</span><br><span class="line">             → Keep searching left (or stay): right = 0</span><br><span class="line"></span><br><span class="line">left = 0 == right = 0 → Exit</span><br><span class="line">Return arr[0:4] = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">Verification: The window [1, 2, 3, 4] has elements with distances [2, 1, 0, 1] from x=3.</span><br><span class="line">              The alternative window [2, 3, 4, 5] has distances [1, 0, 1, 2].</span><br><span class="line">              Both have the same maximum distance (2), but [1, 2, 3, 4] is chosen because</span><br><span class="line">              when distances are equal, we prefer the smaller element (1 &lt; 2).</span><br></pre></td></tr></table></figure>
<p>This example demonstrates how binary search can be applied to
optimization problems where we're searching for an optimal position
rather than a specific value. The comparison logic
<code>x - arr[mid] &gt; arr[mid + k] - x</code> elegantly determines
which direction contains the better window.</p>
<p><strong>Time Complexity:</strong> <span class="math inline">\(O(\log(n - k) + k)\)</span> - binary search +
slicing<br>
<strong>Space Complexity:</strong> <span class="math inline">\(O(1)\)</span> excluding output array</p>
<h2 id="binary-search-on-answer">Binary Search on Answer</h2>
<p>Sometimes, the problem doesn't explicitly ask for binary search, but
we can use it to search for the answer in a solution space.</p>
<h3 id="concept">Concept</h3>
<p>Instead of searching in an array, we search for the <strong>optimal
answer</strong> in a range of possible values. This works when: 1. We
can check if a candidate answer is valid 2. The validity function is
monotonic (if answer <span class="math inline">\(x\)</span> is valid,
then all <span class="math inline">\(y &gt; x\)</span> are valid, or
vice versa)</p>
<h3 id="problem-koko-eating-bananas-leetcode-875">Problem: Koko Eating
Bananas (LeetCode 875)</h3>
<p><strong>Problem Statement:</strong> Koko loves to eat bananas. There
are <code>n</code> piles of bananas, the <code>i</code>-th pile has
<code>piles[i]</code> bananas. The guards have gone and will come back
in <code>h</code> hours. Koko can decide her bananas-per-hour eating
speed of <code>k</code>. Each hour, she chooses some pile of bananas and
eats <code>k</code> bananas from that pile. If the pile has less than
<code>k</code> bananas, she eats all of them instead and will not eat
any more bananas during this hour. Koko wants to finish eating all the
bananas before the guards return. Return the minimum integer
<code>k</code> such that she can eat all the bananas within
<code>h</code> hours.</p>
<p><strong>Solution:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minEatingSpeed</span>(<span class="params">self, piles: <span class="type">List</span>[<span class="built_in">int</span>], h: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">can_finish</span>(<span class="params">speed</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Check if Koko can finish with given speed.&quot;&quot;&quot;</span></span><br><span class="line">            hours = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> pile <span class="keyword">in</span> piles:</span><br><span class="line">                hours += (pile + speed - <span class="number">1</span>) // speed  <span class="comment"># Ceiling division</span></span><br><span class="line">                <span class="keyword">if</span> hours &gt; h:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Binary search on answer: speed ranges from 1 to max(piles)</span></span><br><span class="line">        left, right = <span class="number">1</span>, <span class="built_in">max</span>(piles)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> can_finish(mid):</span><br><span class="line">                <span class="comment"># This speed works, try smaller</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># This speed is too slow</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>Key Insight:</strong></p>
<ul>
<li>We're not searching in an array, but in the <strong>solution
space</strong> of possible speeds <code>[1, max(piles)]</code></li>
<li>If speed <span class="math inline">\(k\)</span> allows finishing in
time, then all speeds <span class="math inline">\(&gt; k\)</span> also
work (monotonic property)</li>
<li>We want the <strong>minimum</strong> valid speed, so we use the left
bound template</li>
</ul>
<p><strong>Example:</strong></p>
<p>This problem demonstrates binary search on answer space beautifully.
We're not searching in an array of speeds, but rather searching for the
optimal speed value in a continuous range. The key is recognizing that
if a certain speed works, all faster speeds also work (monotonic
property), so we can use binary search to find the minimum valid
speed.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">piles = [3, 6, 7, 11], h = 8</span><br><span class="line"></span><br><span class="line">We need to find the minimum speed that allows finishing in 8 hours.</span><br><span class="line"></span><br><span class="line">Check speed = 4:</span><br><span class="line"></span><br><span class="line">- Pile 3: ⌈3/4⌉ = 1 hour (ceiling division: 3 bananas / 4 per hour = 0.75, rounded up = 1)</span><br><span class="line">- Pile 6: ⌈6/4⌉ = 2 hours (6 / 4 = 1.5, rounded up = 2)</span><br><span class="line">- Pile 7: ⌈7/4⌉ = 2 hours (7 / 4 = 1.75, rounded up = 2)</span><br><span class="line">- Pile 11: ⌈11/4⌉ = 3 hours (11 / 4 = 2.75, rounded up = 3)</span><br><span class="line">- Total: 1 + 2 + 2 + 3 = 8 hours → Valid!</span><br><span class="line"></span><br><span class="line">Check speed = 3:</span><br><span class="line"></span><br><span class="line">- Pile 3: ⌈3/3⌉ = 1 hour</span><br><span class="line">- Pile 6: ⌈6/3⌉ = 2 hours</span><br><span class="line">- Pile 7: ⌈7/3⌉ = 3 hours (7 / 3 = 2.33, rounded up = 3)</span><br><span class="line">- Pile 11: ⌈11/3⌉ = 4 hours (11 / 3 = 3.67, rounded up = 4)</span><br><span class="line">- Total: 1 + 2 + 3 + 4 = 10 hours → Invalid (exceeds 8 hours)</span><br><span class="line"></span><br><span class="line">Binary search process:</span><br><span class="line"></span><br><span class="line">- Search space: [1, 11] (minimum possible speed is 1, maximum needed is max(piles) = 11)</span><br><span class="line">- Check mid = 6: Can finish in time? Yes → Try smaller, right = 6</span><br><span class="line">- Check mid = 3: Can finish in time? No → Need faster, left = 4</span><br><span class="line">- Check mid = 4: Can finish in time? Yes → Try smaller, right = 4</span><br><span class="line">- left = 4 == right = 4 → Exit, minimum speed = 4</span><br></pre></td></tr></table></figure>
<p>This example illustrates the power of binary search on answer space:
instead of checking every possible speed from 1 to 11 (which would be 11
checks), binary search finds the answer in only 4 checks, demonstrating
logarithmic efficiency even when the answer space isn't explicitly an
array.</p>
<p><strong>Time Complexity:</strong> <span class="math inline">\(O(n
\log(\max(piles)))\)</span><br>
<strong>Space Complexity:</strong> <span class="math inline">\(O(1)\)</span></p>
<h3 id="more-binary-search-on-answer-problems">More Binary Search on
Answer Problems</h3>
<ol type="1">
<li><strong>Split Array Largest Sum (LeetCode 410)</strong>: Binary
search on the maximum sum</li>
<li><strong>Capacity To Ship Packages (LeetCode 1011)</strong>: Binary
search on ship capacity</li>
<li><strong>Minimize Maximum Distance to Gas Station (LeetCode
774)</strong>: Binary search on maximum distance</li>
<li><strong>Kth Smallest Number in Multiplication Table (LeetCode
668)</strong>: Binary search on the answer value</li>
</ol>
<h2 id="common-mistakes-and-debugging-tips">Common Mistakes and
Debugging Tips</h2>
<h3 id="mistake-1-infinite-loops">Mistake 1: Infinite Loops</h3>
<p><strong>Problem:</strong> Using <code>left &lt; right</code> with
<code>right = mid - 1</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># WRONG</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid - <span class="number">1</span>  <span class="comment"># Can cause infinite loop!</span></span><br></pre></td></tr></table></figure>
<p><strong>Fix:</strong> Match loop condition with boundary updates:</p>
<ul>
<li><code>left &lt;= right</code> → use
<code>right = mid - 1</code></li>
<li><code>left &lt; right</code> → use <code>right = mid</code></li>
</ul>
<h3 id="mistake-2-off-by-one-errors">Mistake 2: Off-by-One Errors</h3>
<p><strong>Problem:</strong> Returning wrong index</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># WRONG for insertion position</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># Should be len(nums)</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">return</span> right  <span class="comment"># Should return left</span></span><br></pre></td></tr></table></figure>
<p><strong>Fix:</strong> Understand what each template returns:</p>
<ul>
<li>Left bound template returns insertion position</li>
<li>Right bound template returns <code>left - 1</code> for last
occurrence</li>
</ul>
<h3 id="mistake-3-integer-overflow">Mistake 3: Integer Overflow</h3>
<p><strong>Problem:</strong> Using <code>(left + right) // 2</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># WRONG (can overflow)</span></span><br><span class="line">mid = (left + right) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CORRECT</span></span><br><span class="line">mid = left + (right - left) // <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="mistake-4-not-handling-empty-arrays">Mistake 4: Not Handling
Empty Arrays</h3>
<p><strong>Problem:</strong> Accessing <code>nums[0]</code> without
checking</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># WRONG</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># If nums is empty, len(nums) - 1 = -1, and nums[-1] is wrong!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CORRECT</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<h3 id="debugging-tips">Debugging Tips</h3>
<ol type="1">
<li><p><strong>Print mid and boundaries</strong>: Add print statements
to track search progress <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;left=<span class="subst">&#123;left&#125;</span>, right=<span class="subst">&#123;right&#125;</span>, mid=<span class="subst">&#123;mid&#125;</span>, nums[mid]=<span class="subst">&#123;nums[mid]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Test edge cases</strong>:</p>
<ul>
<li>Empty array</li>
<li>Single element</li>
<li>Two elements</li>
<li>Target at boundaries</li>
<li>Target not present</li>
<li>Duplicate elements (for left/right bound problems)</li>
</ul></li>
<li><p><strong>Verify loop invariants</strong>:</p>
<ul>
<li>At each iteration, the answer (if exists) is in
<code>[left, right]</code></li>
<li>The loop terminates (boundaries converge)</li>
</ul></li>
<li><p><strong>Check return value</strong>: Make sure you're returning
the correct variable (<code>left</code>, <code>right</code>,
<code>mid</code>, or <code>left - 1</code>)</p></li>
</ol>
<h2 id="complexity-analysis-deep-dive">Complexity Analysis Deep
Dive</h2>
<h3 id="why-logarithmic">Why Logarithmic?</h3>
<p>Binary search's efficiency comes from the <strong>exponential
reduction</strong> of the search space. Let's prove the time complexity
more rigorously.</p>
<p><strong>Recurrence Relation:</strong> <span class="math display">\[T(n) = T\left(\frac{n}{2}\right) +
O(1)\]</span></p>
<p><strong>Solving the recurrence:</strong></p>
<ul>
<li><span class="math inline">\(T(n) = T(\frac{n}{2}) + 1\)</span></li>
<li><span class="math inline">\(T(\frac{n}{2}) = T(\frac{n}{4}) +
1\)</span></li>
<li><span class="math inline">\(T(\frac{n}{4}) = T(\frac{n}{8}) +
1\)</span></li>
<li>...</li>
<li><span class="math inline">\(T(1) = 1\)</span></li>
</ul>
<p>Substituting back: <span class="math display">\[T(n) = 1 + 1 + 1 +
\ldots + 1 = \log_2 n\]</span></p>
<p>Therefore, <span class="math inline">\(T(n) = O(\log n)\)</span>.</p>
<h3 id="space-complexity">Space Complexity</h3>
<p><strong>Iterative:</strong></p>
<ul>
<li>Only uses a constant number of variables: <code>left</code>,
<code>right</code>, <code>mid</code></li>
<li>Space: <span class="math inline">\(O(1)\)</span></li>
</ul>
<p><strong>Recursive:</strong></p>
<ul>
<li>Each recursive call adds one frame to the stack</li>
<li>Maximum depth: <span class="math inline">\(\log_2 n\)</span></li>
<li>Space: <span class="math inline">\(O(\log n)\)</span></li>
</ul>
<h3 id="comparison-with-other-search-methods">Comparison with Other
Search Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th>Requirements</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linear Search</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>None</td>
</tr>
<tr>
<td>Binary Search</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>Sorted array</td>
</tr>
<tr>
<td>Hash Table</td>
<td><span class="math inline">\(O(1)\)</span> average</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>When to use Binary Search:</strong></p>
<ul>
<li>Array is sorted (or can be sorted)</li>
<li>Need to find exact match, range, or insertion position</li>
<li>Memory is constrained (hash table uses more space)</li>
<li>Need to solve "binary search on answer" problems</li>
</ul>
<h2 id="qa-common-questions">Q&amp;A: Common Questions</h2>
<h3 id="q1-when-should-i-use-left-right-vs-left-right">Q1: When should I
use <code>left &lt;= right</code> vs <code>left &lt; right</code>?</h3>
<p><strong>A:</strong> This is one of the most common sources of
confusion in binary search. The choice between these two conditions
fundamentally changes how the algorithm behaves and what it returns.</p>
<p>Use <code>left &lt;= right</code> when you want to check every
position including when <code>left == right</code>. This is the standard
template for finding an exact match, where you need to verify every
possible position before concluding the target doesn't exist. The loop
continues until the search space is completely exhausted, meaning
<code>left</code> has moved past <code>right</code>.</p>
<p>Use <code>left &lt; right</code> when you're using the left-bound or
right-bound template, where <code>left</code> will converge to the
answer position. In these templates, you're not looking for an exact
match but rather a boundary position. The loop terminates when
<code>left</code> equals <code>right</code>, at which point
<code>left</code> (or <code>left - 1</code> for right-bound) contains
the answer.</p>
<p><strong>Detailed Example:</strong></p>
<p>Consider searching for target 5 in array
<code>[1, 3, 5, 7, 9]</code>:</p>
<p>With <code>left &lt;= right</code>:</p>
<ul>
<li>The loop continues until <code>left &gt; right</code></li>
<li>You check position <code>mid</code> when
<code>left == right</code></li>
<li>This ensures you don't miss the target if it's at the boundary</li>
</ul>
<p>With <code>left &lt; right</code>:</p>
<ul>
<li>The loop stops when <code>left == right</code></li>
<li>You never check the final position where <code>left == right</code>
inside the loop</li>
<li>This works for boundary-finding because <code>left</code> converges
to the boundary position</li>
</ul>
<p><strong>When to use each:</strong></p>
<ul>
<li>Standard search: <code>left &lt;= right</code> (check all positions,
return <code>mid</code> or <code>-1</code>)</li>
<li>Insertion position: <code>left &lt; right</code> (left converges to
insertion point)</li>
<li>First occurrence: <code>left &lt; right</code> (left converges to
first occurrence)</li>
<li>Last occurrence: <code>left &lt; right</code> (left converges to
position after last occurrence)</li>
</ul>
<h3 id="q2-why-do-we-use-right-mid-instead-of-right-mid---1-in-left-bound-template">Q2:
Why do we use <code>right = mid</code> instead of
<code>right = mid - 1</code> in left-bound template?</h3>
<p><strong>A:</strong> This is a critical distinction that many
programmers struggle with. The reason is that <code>mid</code> itself
might be the answer we're looking for, and we need to keep it in the
search space to ensure we find the leftmost occurrence.</p>
<p>When <code>nums[mid] == target</code>, we've found an occurrence of
the target, but we don't know if it's the leftmost one. There could be
more occurrences to the left. If we set <code>right = mid - 1</code>, we
would exclude <code>mid</code> from consideration, potentially losing
the correct answer. By setting <code>right = mid</code>, we keep
<code>mid</code> in the search space while eliminating everything to its
right.</p>
<p><strong>Detailed walkthrough:</strong></p>
<p>Consider finding the leftmost occurrence of 5 in
<code>[3, 5, 5, 5, 7]</code>:</p>
<ul>
<li>Initial: <code>left=0, right=5</code></li>
<li>Iteration 1: <code>mid=2, nums[2]=5 == 5</code>
<ul>
<li>If we use <code>right = mid - 1 = 1</code>: We'd exclude index 2,
but index 2 might be the answer (though we know index 1 is actually the
leftmost)</li>
<li>If we use <code>right = mid = 2</code>: We keep index 2 in the
search space and continue searching left</li>
</ul></li>
<li>Iteration 2: <code>mid=1, nums[1]=5 == 5</code>
<ul>
<li>We set <code>right = mid = 1</code> to continue searching left</li>
</ul></li>
<li>Iteration 3: <code>mid=0, nums[0]=3 &lt; 5</code>
<ul>
<li>We set <code>left = mid + 1 = 1</code></li>
</ul></li>
<li>Now <code>left=1 == right=1</code>, exit. The answer is
<code>left=1</code>, which is correct.</li>
</ul>
<p><strong>Key insight:</strong> In the left-bound template, we're
searching for the leftmost position where
<code>nums[pos] &gt;= target</code>. The position <code>mid</code>
itself satisfies this condition, so we must keep it in the search space.
Setting <code>right = mid</code> ensures we don't lose valid answers
while still making progress toward the leftmost position.</p>
<h3 id="q3-how-do-i-know-which-template-to-use">Q3: How do I know which
template to use?</h3>
<p><strong>A:</strong></p>
<ul>
<li><strong>Standard template</strong>: Finding exact match, any
occurrence</li>
<li><strong>Left-bound template</strong>: Finding first occurrence,
insertion position, minimum valid answer</li>
<li><strong>Right-bound template</strong>: Finding last occurrence,
maximum valid answer</li>
</ul>
<h3 id="q4-can-binary-search-work-on-unsorted-arrays">Q4: Can binary
search work on unsorted arrays?</h3>
<p><strong>A:</strong> Generally no, but there are exceptions:</p>
<ul>
<li><strong>Peak element</strong>: Works because of the specific
property (at least one half has a peak)</li>
<li><strong>Rotated sorted array</strong>: Works because at least one
half is sorted</li>
<li><strong>Binary search on answer</strong>: Works when the validity
function is monotonic</li>
</ul>
<h3 id="q5-what-if-the-array-has-duplicates">Q5: What if the array has
duplicates?</h3>
<p><strong>A:</strong> Standard binary search may return any occurrence.
Use left-bound or right-bound templates to find specific occurrences.
The key is understanding what happens when
<code>nums[mid] == target</code>:</p>
<ul>
<li>Left-bound: <code>right = mid</code> (keep searching left)</li>
<li>Right-bound: <code>left = mid + 1</code> (keep searching right)</li>
</ul>
<h3 id="q6-how-do-i-handle-negative-numbers-or-very-large-numbers">Q6:
How do I handle negative numbers or very large numbers?</h3>
<p><strong>A:</strong> Binary search works the same way. The key is
using <code>left + (right - left) // 2</code> to avoid overflow. For
very large arrays, ensure your language's integer type can handle the
indices.</p>
<h3 id="q7-is-binary-search-always-faster-than-linear-search">Q7: Is
binary search always faster than linear search?</h3>
<p><strong>A:</strong> This is a nuanced question that depends on
several factors. While binary search has superior asymptotic complexity,
real-world performance involves more than just big-O notation.</p>
<p>For large arrays, binary search is almost always faster. The
logarithmic time complexity means that even for arrays with millions of
elements, binary search requires only about 20-30 comparisons, compared
to potentially millions for linear search.</p>
<p>However, there are important considerations:</p>
<ul>
<li><p><strong>Small arrays</strong> (<span class="math inline">\(n &lt;
10\)</span>): Linear search might be faster due to overhead. Binary
search has more overhead per iteration (calculating mid, multiple
comparisons), while linear search is simpler. For very small arrays, the
constant factors matter more than the asymptotic complexity.</p></li>
<li><p><strong>Cache locality</strong>: Linear search has better cache
performance because it accesses memory sequentially. Modern CPUs are
optimized for sequential access patterns, and linear search can benefit
from prefetching and cache line utilization. Binary search jumps around
in memory, which can cause more cache misses.</p></li>
<li><p><strong>Setup cost</strong>: Binary search requires a sorted
array. If your data isn't already sorted, you need to sort it first,
which is <span class="math inline">\(O(n \log n)\)</span>. If you only
need to search once, linear search might be faster overall. However, if
you need to perform multiple searches, the one-time sorting cost is
amortized across all searches.</p></li>
<li><p><strong>Branch prediction</strong>: Modern CPUs use branch
prediction to optimize code execution. Linear search has more
predictable branching patterns (usually just "continue" until found),
while binary search has less predictable branches that can hurt
performance on some architectures.</p></li>
</ul>
<p><strong>Practical recommendation:</strong> Use binary search
when:</p>
<ul>
<li>The array is already sorted or will be searched multiple times</li>
<li>The array is reasonably large (<span class="math inline">\(n &gt;
20\)</span>)</li>
<li>You need guaranteed <span class="math inline">\(O(\log n)\)</span>
performance</li>
</ul>
<p>Use linear search when:</p>
<ul>
<li>The array is very small (<span class="math inline">\(n &lt;
10\)</span>)</li>
<li>The array is unsorted and you only need to search once</li>
<li>Cache performance is critical and the array fits in cache</li>
</ul>
<h3 id="q8-how-do-i-modify-binary-search-for-descending-arrays">Q8: How
do I modify binary search for descending arrays?</h3>
<p><strong>A:</strong> Simply reverse the comparison: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">    <span class="keyword">return</span> mid</span><br><span class="line"><span class="keyword">elif</span> nums[mid] &gt; target:  <span class="comment"># Reversed!</span></span><br><span class="line">    left = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    right = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="q9-whats-the-difference-between-mid-left-right-2-and-mid-left-right---left-2">Q9:
What's the difference between <code>mid = (left + right) // 2</code> and
<code>mid = left + (right - left) // 2</code>?</h3>
<p><strong>A:</strong> Mathematically equivalent, but the second form
prevents integer overflow:</p>
<ul>
<li>First: <code>left + right</code> can overflow if both are large</li>
<li>Second: <code>right - left</code> is safer, then add to
<code>left</code></li>
</ul>
<h3 id="q10-how-do-i-debug-a-binary-search-thats-not-working">Q10: How
do I debug a binary search that's not working?</h3>
<p><strong>A:</strong> 1. <strong>Add print statements</strong> for
<code>left</code>, <code>right</code>, <code>mid</code>, and
<code>nums[mid]</code> to track the search progress: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;left=<span class="subst">&#123;left&#125;</span>, right=<span class="subst">&#123;right&#125;</span>, mid=<span class="subst">&#123;mid&#125;</span>, nums[mid]=<span class="subst">&#123;nums[mid]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># ... rest of code</span></span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p><strong>Verify loop condition matches boundary
updates</strong>:</p>
<ul>
<li><code>left &lt;= right</code> → use
<code>right = mid - 1</code></li>
<li><code>left &lt; right</code> → use <code>right = mid</code></li>
</ul></li>
<li><p><strong>Check edge cases systematically</strong>:</p>
<ul>
<li>Empty array: <code>[]</code></li>
<li>Single element: <code>[1]</code></li>
<li>Two elements: <code>[1, 2]</code></li>
<li>Target at boundaries: first or last element</li>
<li>Target doesn't exist: smaller than min or larger than max</li>
<li>Duplicate elements (for left/right bound problems)</li>
</ul></li>
<li><p><strong>Ensure correct return value</strong>:</p>
<ul>
<li>Standard search: return <code>mid</code> if found, <code>-1</code>
otherwise</li>
<li>Left bound: return <code>left</code> (but check bounds first)</li>
<li>Right bound: return <code>left - 1</code> (but check bounds
first)</li>
</ul></li>
<li><p><strong>Verify array is sorted</strong>: Binary search only works
on sorted arrays. If your code isn't working, double-check the
input.</p></li>
<li><p><strong>Trace through examples with duplicates</strong>: For
left/right bound problems, manually trace through examples like
<code>[1, 2, 2, 2, 3]</code> with target <code>2</code>.</p></li>
<li><p><strong>Check for infinite loops</strong>: If your code hangs,
verify that boundaries are actually converging. Add a counter to detect
infinite loops: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterations = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right <span class="keyword">and</span> iterations &lt; <span class="number">100</span>:</span><br><span class="line">    iterations += <span class="number">1</span></span><br><span class="line">    <span class="comment"># ... rest of code</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="q11-how-do-i-handle-floating-point-binary-search">Q11: How do I
handle floating-point binary search?</h3>
<p><strong>A:</strong> Floating-point binary search is similar but uses
a tolerance to determine when to stop:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_float</span>(<span class="params">func, target, left, right, tolerance=<span class="number">1e-9</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Find x such that func(x) == target (within tolerance).</span></span><br><span class="line"><span class="string">    Assumes func is monotonic.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> right - left &gt; tolerance:</span><br><span class="line">        mid = (left + right) / <span class="number">2.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> func(mid) &lt; target:</span><br><span class="line">            left = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (left + right) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p><strong>Key differences:</strong></p>
<ul>
<li>Use <code>(left + right) / 2.0</code> instead of integer
division</li>
<li>Loop condition: <code>right - left &gt; tolerance</code> instead of
<code>left &lt; right</code></li>
<li>No <code>+1</code> or <code>-1</code> in updates (floating-point
doesn't need it)</li>
</ul>
<p><strong>Example: Finding square root with precision</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt_binary_search</span>(<span class="params">x, precision=<span class="number">1e-9</span></span>):</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">    </span><br><span class="line">    left, right = <span class="number">0.0</span>, <span class="built_in">float</span>(x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> right - left &gt; precision:</span><br><span class="line">        mid = (left + right) / <span class="number">2.0</span></span><br><span class="line">        square = mid * mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> square &lt; x:</span><br><span class="line">            left = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (left + right) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<h3 id="q12-can-binary-search-be-used-for-optimization-problems">Q12:
Can binary search be used for optimization problems?</h3>
<p><strong>A:</strong> Yes! Binary search is excellent for optimization
problems where: 1. We can check if a solution is feasible 2. The
feasibility function is monotonic</p>
<p><strong>Example: Minimize Maximum Distance to Gas Station (LeetCode
774)</strong></p>
<p>Given positions of gas stations and number of new stations to add,
minimize the maximum distance between adjacent stations.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minmaxGasDist</span>(<span class="params">stations, k</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">can_achieve</span>(<span class="params">max_dist</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Check if we can achieve max distance &lt;= max_dist with k stations.&quot;&quot;&quot;</span></span><br><span class="line">        stations_needed = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stations) - <span class="number">1</span>):</span><br><span class="line">            gap = stations[i + <span class="number">1</span>] - stations[i]</span><br><span class="line">            stations_needed += <span class="built_in">int</span>(gap / max_dist)</span><br><span class="line">            <span class="keyword">if</span> stations_needed &gt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">max</span>(stations[i + <span class="number">1</span>] - stations[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stations) - <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> right - left &gt; <span class="number">1e-6</span>:  <span class="comment"># Floating-point tolerance</span></span><br><span class="line">        mid = (left + right) / <span class="number">2.0</span></span><br><span class="line">        <span class="keyword">if</span> can_achieve(mid):</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h3 id="q13-how-do-i-modify-binary-search-for-descending-arrays">Q13:
How do I modify binary search for descending arrays?</h3>
<p><strong>A:</strong> Simply reverse the comparison operators:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_descending</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:  <span class="comment"># Reversed: in descending, larger means go right</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>Key change:</strong> <code>nums[mid] &lt; target</code>
becomes <code>nums[mid] &gt; target</code> because in descending order,
larger values are to the left.</p>
<h3 id="q14-whats-the-relationship-between-binary-search-and-divide-and-conquer">Q14:
What's the relationship between binary search and
divide-and-conquer?</h3>
<p><strong>A:</strong> Binary search is a special case of
divide-and-conquer where:</p>
<ul>
<li><strong>Divide</strong>: Split the search space in half by comparing
with the middle element</li>
<li><strong>Conquer</strong>: Recursively search in the relevant
half</li>
<li><strong>Combine</strong>: Return the result (no combination needed,
we just return what we find)</li>
</ul>
<p>However, binary search is typically implemented iteratively for
better space efficiency (<span class="math inline">\(O(1)\)</span> vs
<span class="math inline">\(O(\log n)\)</span>).</p>
<p><strong>Recursive version:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_recursive</span>(<span class="params">nums, target, left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left &gt; right:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">        <span class="keyword">return</span> binary_search_recursive(nums, target, mid + <span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> binary_search_recursive(nums, target, left, mid - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Iterative version (preferred):</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_iterative</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="q15-how-do-i-handle-binary-search-when-the-array-might-have-duplicates">Q15:
How do I handle binary search when the array might have duplicates?</h3>
<p><strong>A:</strong> Use left-bound or right-bound templates depending
on what you need:</p>
<ul>
<li><strong>Find first occurrence</strong>: Use left-bound template</li>
<li><strong>Find last occurrence</strong>: Use right-bound
template<br>
</li>
<li><strong>Find any occurrence</strong>: Standard template works, but
result is non-deterministic</li>
<li><strong>Count occurrences</strong>: Find both bounds, then
<code>right_bound - left_bound + 1</code></li>
</ul>
<p><strong>Example: Count occurrences of target</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_occurrences</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">left_bound</span>(<span class="params">nums, target</span>):</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">right_bound</span>(<span class="params">nums, target</span>):</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    left_idx = left_bound(nums, target)</span><br><span class="line">    <span class="keyword">if</span> left_idx == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[left_idx] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    right_idx = right_bound(nums, target)</span><br><span class="line">    <span class="keyword">return</span> right_idx - left_idx + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="advanced-binary-search-patterns">Advanced Binary Search
Patterns</h2>
<p>Beyond the standard templates, there are several advanced patterns
that appear frequently in competitive programming and technical
interviews.</p>
<h3 id="pattern-1-binary-search-on-answer-space">Pattern 1: Binary
Search on Answer Space</h3>
<p>We've already seen this with "Koko Eating Bananas," but it's worth
exploring more deeply. The key insight is that we're not searching in an
array, but in a <strong>solution space</strong> where we can verify if a
candidate answer is valid.</p>
<p><strong>When to Use:</strong></p>
<ul>
<li>Problem asks for "minimum maximum" or "maximum minimum"</li>
<li>We can check if a value satisfies the condition</li>
<li>The validity function is monotonic (if <span class="math inline">\(x\)</span> works, then all <span class="math inline">\(y &gt; x\)</span> work, or vice versa)</li>
</ul>
<p><strong>Template:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_answer</span>():</span><br><span class="line">    <span class="comment"># 1. Determine answer range</span></span><br><span class="line">    left, right = min_possible, max_possible</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. Binary search</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> is_valid(mid):</span><br><span class="line">            <span class="comment"># Try smaller (or larger, depending on problem)</span></span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>Example: Split Array Largest Sum (LeetCode 410)</strong></p>
<p>Given an array <code>nums</code> and integer <code>m</code>, split
<code>nums</code> into <code>m</code> non-empty subarrays such that the
largest sum among these subarrays is minimized.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">splitArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">can_split</span>(<span class="params">max_sum</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Check if we can split into m subarrays with max sum &lt;= max_sum.&quot;&quot;&quot;</span></span><br><span class="line">            subarrays = <span class="number">1</span></span><br><span class="line">            current_sum = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> current_sum + num &gt; max_sum:</span><br><span class="line">                    subarrays += <span class="number">1</span></span><br><span class="line">                    current_sum = num</span><br><span class="line">                    <span class="keyword">if</span> subarrays &gt; m:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    current_sum += num</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        left, right = <span class="built_in">max</span>(nums), <span class="built_in">sum</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> can_split(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h3 id="pattern-2-binary-search-with-custom-comparison">Pattern 2:
Binary Search with Custom Comparison</h3>
<p>Sometimes, the comparison isn't straightforward. We need to define a
custom comparison function.</p>
<p><strong>Example: Search in Rotated Sorted Array with Duplicates
(LeetCode 81)</strong></p>
<p>When duplicates exist, <code>nums[left] &lt;= nums[mid]</code>
doesn't guarantee the left half is sorted. We need to handle the case
where <code>nums[left] == nums[mid]</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Handle duplicates: can&#x27;t determine which half is sorted</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] == nums[mid] == nums[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[left] &lt;= nums[mid]:</span><br><span class="line">                <span class="comment"># Left half is sorted</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Right half is sorted</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="pattern-3-binary-search-on-function-values">Pattern 3: Binary
Search on Function Values</h3>
<p>Instead of searching in an array, we search for a value where a
function meets certain criteria.</p>
<p><strong>Example: Sqrt(x) (LeetCode 69)</strong></p>
<p>Find the integer square root of <code>x</code> without using built-in
functions.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">1</span>, x // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left + <span class="number">1</span>) // <span class="number">2</span>  <span class="comment"># Use +1 to avoid infinite loop</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> mid * mid &gt; x:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p><strong>Key Point:</strong> Notice
<code>mid = left + (right - left + 1) // 2</code>. This ensures we don't
get stuck when <code>left = mid</code> and
<code>right = left + 1</code>.</p>
<h3 id="pattern-4-binary-search-with-two-pointers">Pattern 4: Binary
Search with Two Pointers</h3>
<p>Combine binary search with two pointers for more complex
problems.</p>
<p><strong>Example: 4Sum II (LeetCode 454) - Variant
Approach</strong></p>
<p>While this problem has a hash table solution, we can also use binary
search by sorting and then using two pointers with binary search for the
remaining two numbers.</p>
<h3 id="pattern-5-binary-search-on-index-range">Pattern 5: Binary Search
on Index Range</h3>
<p>Sometimes we need to search for an index that satisfies certain
properties, not a value.</p>
<p><strong>Example: H-Index II (LeetCode 275)</strong></p>
<p>Given a sorted array of citations, find the h-index using binary
search.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(citations)</span><br><span class="line">        left, right = <span class="number">0</span>, n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># Check if citations[mid] papers have at least citations[mid] citations</span></span><br><span class="line">            <span class="keyword">if</span> citations[mid] &gt;= n - mid:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n - left</span><br></pre></td></tr></table></figure>
<h2 id="variations-and-extensions">Variations and Extensions</h2>
<h3 id="variation-1-search-in-rotated-arrays">Variation 1: Search in
Rotated Arrays</h3>
<p>Even though rotated arrays are not fully sorted, at least one half is
always sorted, which we can exploit for binary search.</p>
<p><strong>Key Technique:</strong> 1. Determine which half is sorted:
<code>nums[left] &lt;= nums[mid]</code> means left half is sorted 2.
Check if target is in the sorted half's range 3. If not in sorted half,
search in the unsorted half</p>
<p><strong>Extended Problems:</strong></p>
<ul>
<li><ol start="33" type="1">
<li>Search in Rotated Sorted Array (no duplicates)</li>
</ol></li>
<li><ol start="81" type="1">
<li>Search in Rotated Sorted Array II (with duplicates, needs special
handling)</li>
</ol></li>
<li><ol start="153" type="1">
<li>Find Minimum in Rotated Sorted Array</li>
</ol></li>
<li><ol start="154" type="1">
<li>Find Minimum in Rotated Sorted Array II (with duplicates)</li>
</ol></li>
</ul>
<h3 id="variation-2-2d-binary-search">Variation 2: 2D Binary Search</h3>
<p>2D matrices can also be searched using binary search by converting 2D
indices to 1D indices.</p>
<p><strong>Conversion Formulas:</strong></p>
<ul>
<li>1D index <code>idx</code> → 2D coordinates:
<code>row = idx // n</code>, <code>col = idx % n</code></li>
<li>2D coordinates <code>(row, col)</code> → 1D index:
<code>idx = row * n + col</code></li>
</ul>
<p><strong>Extended Problems:</strong></p>
<ul>
<li><ol start="74" type="1">
<li>Search a 2D Matrix (first element of each row &gt; last element of
previous row)</li>
</ol></li>
<li><ol start="240" type="1">
<li>Search a 2D Matrix II (each row and column sorted, more
complex)</li>
</ol></li>
</ul>
<h3 id="variation-3-binary-search-on-answer">Variation 3: Binary Search
on Answer</h3>
<p>When the answer lies in a range and we can check if a value satisfies
the condition, we can binary search in the answer space.</p>
<p><strong>Problem-Solving Steps:</strong> 1. Determine the answer range
<code>[left, right]</code> 2. Write a check function
<code>check(mid)</code>: determine if <code>mid</code> satisfies the
condition 3. Narrow the search range based on the check result 4. Return
the optimal answer</p>
<p><strong>Classic Problems:</strong></p>
<ul>
<li><ol start="875" type="1">
<li>Koko Eating Bananas</li>
</ol></li>
<li><ol start="410" type="1">
<li>Split Array Largest Sum</li>
</ol></li>
<li><ol start="1011" type="1">
<li>Capacity To Ship Packages Within D Days</li>
</ol></li>
<li><ol start="1482" type="1">
<li>Minimum Number of Days to Make m Bouquets</li>
</ol></li>
</ul>
<h3 id="variation-4-finding-peaks">Variation 4: Finding Peaks</h3>
<p>Even if arrays aren't fully sorted, binary search can work if certain
properties are satisfied (e.g., unimodal, bimodal).</p>
<p><strong>Key Insight:</strong> Following the upward direction will
always lead to a peak.</p>
<p><strong>Extended Problems:</strong></p>
<ul>
<li><ol start="162" type="1">
<li>Find Peak Element</li>
</ol></li>
<li><ol start="852" type="1">
<li>Peak Index in a Mountain Array</li>
</ol></li>
</ul>
<h2 id="common-mistakes-and-debugging-tips-1">Common Mistakes and
Debugging Tips</h2>
<h3 id="mistake-1-infinite-loops-1">Mistake 1: Infinite Loops</h3>
<p><strong>Cause:</strong> Loop condition doesn't match boundary
updates.</p>
<p><strong>Wrong Example:</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># WRONG: Using left &lt; right but right = mid - 1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid - <span class="number">1</span>  <span class="comment"># Can cause infinite loop!</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Fix:</strong></p>
<ul>
<li>If using <code>left &lt;= right</code>, use
<code>right = mid - 1</code></li>
<li>If using <code>left &lt; right</code>, use
<code>right = mid</code></li>
</ul>
<h3 id="mistake-2-index-out-of-bounds">Mistake 2: Index Out of
Bounds</h3>
<p><strong>Cause:</strong> Not checking if index is within valid range
before returning.</p>
<p><strong>Wrong Example:</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_left_boundary</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># WRONG: Didn&#x27;t check if left is out of bounds</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Fix:</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check if index is out of bounds</span></span><br><span class="line"><span class="keyword">if</span> left &gt;= <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> left</span><br></pre></td></tr></table></figure></p>
<h3 id="mistake-3-integer-overflow-1">Mistake 3: Integer Overflow</h3>
<p><strong>Cause:</strong> Using <code>(left + right) // 2</code> to
calculate midpoint.</p>
<p><strong>Fix:</strong> Always use
<code>left + (right - left) // 2</code></p>
<h3 id="mistake-4-incorrect-boundary-handling">Mistake 4: Incorrect
Boundary Handling</h3>
<p><strong>Common Edge Cases:</strong></p>
<ul>
<li>Empty array: <code>len(nums) == 0</code></li>
<li>Single element: <code>len(nums) == 1</code></li>
<li>Target at array boundaries</li>
<li>Target doesn't exist and is smaller than min / larger than max</li>
<li>Array has duplicate elements</li>
</ul>
<p><strong>Debugging Tips:</strong></p>
<ol type="1">
<li><p><strong>Print intermediate states:</strong>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;left=<span class="subst">&#123;left&#125;</span>, right=<span class="subst">&#123;right&#125;</span>, mid=<span class="subst">&#123;mid&#125;</span>, nums[mid]=<span class="subst">&#123;nums[mid]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Use assertions:</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="number">0</span> &lt;= left &lt; <span class="built_in">len</span>(nums), <span class="string">f&quot;left=<span class="subst">&#123;left&#125;</span> out of range&quot;</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">0</span> &lt;= right &lt; <span class="built_in">len</span>(nums), <span class="string">f&quot;right=<span class="subst">&#123;right&#125;</span> out of range&quot;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Test cases:</strong></p>
<ul>
<li><code>[]</code> (empty array)</li>
<li><code>[1]</code> (single element)</li>
<li><code>[1, 2, 3]</code>, target = 1 (at boundary)</li>
<li><code>[1, 2, 3]</code>, target = 0 (doesn't exist, smaller than
min)</li>
<li><code>[1, 2, 2, 2, 3]</code>, target = 2 (with duplicates)</li>
</ul></li>
</ol>
<h2 id="practical-tips">Practical Tips</h2>
<h3 id="how-to-quickly-identify-binary-search-problems">How to Quickly
Identify Binary Search Problems</h3>
<p>Consider binary search when you see these characteristics: 1.
<strong>Sorted array</strong>: Array is already sorted (or can be
sorted) 2. <strong>Search target</strong>: Need to find a value,
position, or value satisfying a condition 3. <strong>Time complexity
requirement</strong>: Requires <span class="math inline">\(O(\log
n)\)</span> time complexity 4. <strong>Answer range</strong>: Answer
lies in a determined range (binary search on answer)</p>
<h3 id="decision-tree-for-template-selection">Decision Tree for Template
Selection</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">What does the problem ask for?</span><br><span class="line">├─ Find unique target value → Use standard template</span><br><span class="line">├─ Find first occurrence → Use left-bound template</span><br><span class="line">├─ Find last occurrence → Use right-bound template</span><br><span class="line">└─ Find insertion position → Use left-bound template (return left)</span><br></pre></td></tr></table></figure>
<h3 id="problem-solving-steps">Problem-Solving Steps</h3>
<ol type="1">
<li><strong>Determine search space</strong>: Searching in array or
answer range?</li>
<li><strong>Choose template</strong>: Select appropriate template based
on problem requirements</li>
<li><strong>Determine loop condition</strong>:
<code>left &lt;= right</code> or <code>left &lt; right</code>?</li>
<li><strong>Write comparison logic</strong>: How to update boundaries
based on <code>nums[mid]</code> and <code>target</code>?</li>
<li><strong>Handle edge cases</strong>: Empty array, single element,
target doesn't exist, etc.</li>
<li><strong>Verify answer</strong>: Check correctness of return
value</li>
</ol>
<h3 id="performance-optimization-tips">Performance Optimization
Tips</h3>
<ol type="1">
<li><strong>Early termination</strong>: Return immediately if target is
found</li>
<li><strong>Reduce comparisons</strong>: Merge similar condition
checks</li>
<li><strong>Space optimization</strong>: If only index is needed, don't
store full array</li>
</ol>
<h3 id="combining-with-other-algorithms">Combining with Other
Algorithms</h3>
<ol type="1">
<li><strong>Binary search + sliding window</strong>: Use binary search
to determine optimal window size when size is uncertain</li>
<li><strong>Binary search + dynamic programming</strong>: Use binary
search to optimize DP state transitions when searching is needed</li>
<li><strong>Binary search + greedy</strong>: Use binary search to verify
greedy strategy when validation is needed</li>
</ol>
<h2 id="real-world-applications-of-binary-search">Real-World
Applications of Binary Search</h2>
<p>While binary search is fundamental to algorithm interviews, its true
power lies in its widespread use across real-world systems.
Understanding these applications helps you appreciate why this algorithm
is so important and gives you insight into how major systems handle
large-scale search operations efficiently.</p>
<h3 id="database-indexing-and-query-optimization">Database Indexing and
Query Optimization</h3>
<p>Modern databases rely heavily on binary search for efficient data
retrieval. When you create an index on a column in a database like
PostgreSQL or MySQL, the database engine typically builds a B-tree or
similar data structure that uses binary search principles for
lookups.</p>
<p><strong>How it works:</strong> When you execute a query like
<code>SELECT * FROM users WHERE id = 12345</code>, the database doesn't
scan every row. Instead, it uses the index structure, which is
essentially a sorted array of key-value pairs. The database performs a
binary search on this index to locate the exact position where
<code>id = 12345</code> would be, then uses that information to quickly
retrieve the corresponding row from disk.</p>
<p><strong>Performance impact:</strong> Without binary search, finding a
record in a table with a billion rows would require scanning potentially
billions of rows. With binary search on an index, the same operation
requires only about 30 comparisons, reducing query time from minutes to
milliseconds. This is why database administrators spend significant time
designing proper indexes—they're leveraging binary search's logarithmic
efficiency.</p>
<p><strong>Example scenario:</strong> Consider an e-commerce platform
storing millions of product records. When a customer searches for a
product by its unique product ID, the database uses binary search on the
product ID index to instantly locate the product, rather than scanning
through millions of records sequentially.</p>
<h3 id="version-control-systems-git-bisect">Version Control Systems: Git
Bisect</h3>
<p>One of the most elegant applications of binary search is Git's
<code>bisect</code> command, which helps developers find the exact
commit that introduced a bug. This tool demonstrates binary search's
power in problem-solving beyond simple array searching.</p>
<p><strong>How it works:</strong> When you discover a bug in your
codebase, you know it exists in the current version but didn't exist in
some earlier version. Git bisect uses binary search to systematically
narrow down which commit introduced the bug. You mark the current commit
as "bad" and an earlier known-good commit as "good." Git then checks out
the middle commit between these two points, and you test whether the bug
exists. Based on your answer, Git eliminates half of the remaining
commits and repeats the process.</p>
<p><strong>Visualization:</strong> If you have 1000 commits between the
good and bad versions, linear search would require checking up to 1000
commits. Binary search reduces this to at most 10 checks (since <span class="math inline">\(\log_2(1000) \approx 10\)</span>). This makes
debugging large codebases with extensive commit histories dramatically
more efficient.</p>
<p><strong>Real-world impact:</strong> In large software projects with
thousands of commits, manually checking each commit would be
impractical. Git bisect makes it feasible to track down bugs introduced
weeks or months ago, saving developers countless hours of debugging
time.</p>
<h3 id="system-design-load-balancing-and-resource-allocation">System
Design: Load Balancing and Resource Allocation</h3>
<p>Binary search plays a crucial role in distributed systems design,
particularly in load balancing and resource allocation scenarios. When
systems need to distribute work across multiple servers or allocate
resources efficiently, binary search helps find optimal
configurations.</p>
<p><strong>Load balancing example:</strong> Consider a system that needs
to route requests to servers based on their current load. If servers are
sorted by their current capacity, binary search can quickly identify
which server has the appropriate capacity to handle a new request. This
is more efficient than checking every server sequentially, especially in
systems with hundreds or thousands of servers.</p>
<p><strong>Resource allocation:</strong> In cloud computing platforms,
when allocating virtual machines or containers, the system needs to find
the smallest available resource that meets the requirements. By
maintaining sorted lists of available resources and using binary search,
cloud platforms can efficiently match requests to resources, optimizing
utilization and reducing allocation time.</p>
<h3 id="search-engines-and-information-retrieval">Search Engines and
Information Retrieval</h3>
<p>Search engines use binary search extensively in their indexing and
retrieval systems. While the full-text search algorithms are more
complex, binary search is fundamental to many underlying operations.</p>
<p><strong>Inverted index lookup:</strong> Search engines build inverted
indexes that map words to lists of documents containing those words.
These lists are typically sorted by document ID or relevance score. When
processing a search query, the engine uses binary search to quickly
locate specific entries in these sorted lists, enabling fast
intersection of multiple word lists to find documents matching complex
queries.</p>
<p><strong>Ranking and sorting:</strong> When search results need to be
sorted by relevance, date, or other criteria, binary search helps
maintain sorted order efficiently. This is particularly important when
dealing with millions of search results that need to be ranked and
presented to users in real-time.</p>
<h3 id="operating-systems-memory-management">Operating Systems: Memory
Management</h3>
<p>Operating systems use binary search principles in memory management,
particularly in algorithms that manage free memory blocks or page
tables.</p>
<p><strong>Buddy system:</strong> Some memory allocators use a buddy
system where free memory blocks are organized in sorted lists by size.
When allocating memory, the system uses binary search to quickly find
the smallest block that's large enough for the request, optimizing
memory usage.</p>
<p><strong>Page table lookups:</strong> In virtual memory systems, page
tables need to be searched efficiently. While modern systems use more
sophisticated structures like hash tables, binary search principles
still apply in various lookup scenarios, especially in systems with
limited memory where simpler structures are preferred.</p>
<h3 id="network-protocols-and-routing">Network Protocols and
Routing</h3>
<p>Binary search finds applications in network routing and protocol
implementations, where efficient lookup of routing tables and protocol
handlers is critical for performance.</p>
<p><strong>Routing table lookup:</strong> Network routers maintain
routing tables that need to be searched quickly to determine where to
forward packets. While modern routers use more sophisticated data
structures, binary search principles are fundamental to many routing
algorithms, especially in software routers and network simulation
systems.</p>
<p><strong>Protocol version negotiation:</strong> When systems need to
negotiate protocol versions or capabilities, they often maintain sorted
lists of supported versions. Binary search enables efficient lookup to
find the highest compatible version between two systems.</p>
<h3 id="game-development-and-graphics">Game Development and
Graphics</h3>
<p>In game development, binary search is used for various optimization
tasks, from collision detection to rendering optimizations.</p>
<p><strong>Spatial partitioning:</strong> Game engines often partition
space into sorted regions for efficient collision detection. Binary
search helps quickly locate which spatial region contains a particular
object, enabling efficient collision queries.</p>
<p><strong>Animation and interpolation:</strong> When animating between
keyframes or interpolating values, binary search can quickly locate the
appropriate keyframe range for a given time value, especially when
keyframes are stored in sorted arrays.</p>
<h3 id="financial-systems-trading-and-risk-management">Financial
Systems: Trading and Risk Management</h3>
<p>Financial systems use binary search for various operations, from
matching orders to calculating risk metrics.</p>
<p><strong>Order book matching:</strong> In stock exchanges, buy and
sell orders are typically maintained in sorted order books. Binary
search enables fast lookup to find matching orders or determine the best
available price, which is critical for high-frequency trading where
microseconds matter.</p>
<p><strong>Risk calculation:</strong> When calculating portfolio risk or
performing stress tests, systems often need to search through sorted
historical data. Binary search enables efficient lookup of historical
prices, volatility measures, and other financial metrics.</p>
<h3 id="why-these-applications-matter">Why These Applications
Matter</h3>
<p>Understanding these real-world applications helps you appreciate
binary search beyond interview problems. When you encounter a problem
that involves searching through sorted data, maintaining sorted order,
or finding optimal values in a range, binary search should be one of the
first algorithms you consider. The logarithmic time complexity makes it
scalable to massive datasets, which is why it's foundational to so many
critical systems.</p>
<p>Moreover, recognizing these patterns helps you identify opportunities
to apply binary search in your own projects. Whether you're building a
search feature, optimizing database queries, or designing a system that
needs efficient lookups, binary search provides a powerful tool for
achieving optimal performance.</p>
<h2 id="summary">Summary</h2>
<p>Binary search is a powerful algorithm that achieves logarithmic time
complexity by eliminating half the search space in each iteration.
Mastering it requires:</p>
<ol type="1">
<li><strong>Understanding the fundamentals</strong>: How elimination
works, why it's logarithmic</li>
<li><strong>Knowing the templates</strong>: Standard, left-bound, and
right-bound</li>
<li><strong>Recognizing when to apply</strong>: Sorted arrays, rotated
arrays, binary search on answer</li>
<li><strong>Avoiding common mistakes</strong>: Infinite loops,
off-by-one errors, overflow</li>
<li><strong>Handling edge cases</strong>: Empty arrays, single elements,
boundaries, duplicates</li>
</ol>
<p><strong>Key Takeaways:</strong></p>
<ul>
<li><strong>Standard template</strong>: <code>left &lt;= right</code>,
<code>right = mid - 1</code>, returns <code>mid</code> or
<code>-1</code></li>
<li><strong>Left-bound template</strong>: <code>left &lt; right</code>,
<code>right = mid</code>, returns <code>left</code> (insertion
position)</li>
<li><strong>Right-bound template</strong>: <code>left &lt; right</code>,
<code>left = mid + 1</code>, returns <code>left - 1</code> (last
occurrence)</li>
<li><strong>Always use</strong>:
<code>mid = left + (right - left) // 2</code> to prevent overflow</li>
<li><strong>Binary search on answer</strong>: Search solution space when
validity is monotonic</li>
</ul>
<p><strong>Practice Problems by Difficulty:</strong></p>
<p><strong>Easy:</strong></p>
<ul>
<li>Binary Search (704)</li>
<li>Search Insert Position (35)</li>
<li>First Bad Version (278)</li>
</ul>
<p><strong>Medium:</strong></p>
<ul>
<li>Find First and Last Position (34)</li>
<li>Search in Rotated Sorted Array (33)</li>
<li>Find Peak Element (162)</li>
<li>Search a 2D Matrix (74)</li>
</ul>
<p><strong>Hard:</strong></p>
<ul>
<li>Split Array Largest Sum (410)</li>
<li>Koko Eating Bananas (875)</li>
<li>Capacity To Ship Packages (1011)</li>
</ul>
<p>With practice, binary search becomes intuitive, and you'll recognize
opportunities to apply it even in problems that don't explicitly mention
searching. The key is identifying the monotonic property that allows
elimination of half the solution space.</p>
<h2 id="interview-tips-for-binary-search">Interview Tips for Binary
Search</h2>
<p>Binary search is a favorite topic in technical interviews because it
tests multiple skills: algorithm knowledge, boundary handling, code
quality, and problem-solving approach. Here's how to excel in binary
search interview questions.</p>
<h3 id="before-you-start-coding">Before You Start Coding</h3>
<ol type="1">
<li><p><strong>Clarify the problem</strong>: Ask questions to ensure you
understand:</p>
<ul>
<li>Is the array sorted? In what order (ascending/descending)?</li>
<li>Are there duplicate elements?</li>
<li>What should be returned (index, boolean, value, insertion
position)?</li>
<li>What if the target doesn't exist?</li>
<li>Are there any constraints (array size, value range)?</li>
</ul></li>
<li><p><strong>Discuss your approach</strong>: Explain your strategy
before coding:</p>
<ul>
<li>Which template will you use (standard, left-bound,
right-bound)?</li>
<li>Why this template fits the problem?</li>
<li>How will you handle edge cases?</li>
</ul></li>
<li><p><strong>Estimate complexity</strong>: Mention time and space
complexity upfront to show you understand the algorithm's
efficiency.</p></li>
</ol>
<h3 id="during-coding">During Coding</h3>
<ol type="1">
<li><p><strong>Use clear variable names</strong>: <code>left</code>,
<code>right</code>, <code>mid</code> are standard and clear. Avoid
abbreviations.</p></li>
<li><p><strong>Prevent overflow</strong>: Always use
<code>mid = left + (right - left) // 2</code> and mention why:
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Good: Mention overflow prevention</span></span><br><span class="line">mid = left + (right - left) // <span class="number">2</span>  <span class="comment"># Prevents integer overflow</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Comment key decisions</strong>: Explain why you chose
specific loop conditions or boundary updates: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using left &lt; right because we want left to converge to insertion position</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Handle edge cases explicitly</strong>: Don't assume the
input is well-formed: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># Handle empty array</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Think out loud</strong>: Explain your thought process as
you code. This helps interviewers understand your reasoning and catch
mistakes early.</p></li>
</ol>
<h3 id="after-coding">After Coding</h3>
<ol type="1">
<li><p><strong>Walk through examples</strong>: Trace through your code
with examples:</p>
<ul>
<li>Normal case: target exists</li>
<li>Edge cases: empty array, single element, target at boundaries</li>
<li>Special cases: duplicates (for left/right bound problems)</li>
</ul></li>
<li><p><strong>Test your code</strong>: Mentally execute your code with
test cases: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: Search for 5 in [1, 3, 5, 7, 9]</span></span><br><span class="line"><span class="comment"># left=0, right=4</span></span><br><span class="line"><span class="comment"># mid=2, nums[2]=5 == 5 → Found!</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Discuss optimizations</strong>: If time permits, mention
potential optimizations:</p>
<ul>
<li>Early termination when target is found</li>
<li>Reducing comparisons by combining conditions</li>
<li>Space optimizations if applicable</li>
</ul></li>
<li><p><strong>Mention alternatives</strong>: Show you know other
approaches:</p>
<ul>
<li>"We could also use a hash table for O(1) lookup, but that requires
O(n) space and the array must be sorted anyway for binary search to
work."</li>
</ul></li>
</ol>
<h3 id="common-interview-scenarios">Common Interview Scenarios</h3>
<p><strong>Scenario 1: "Find the first occurrence of
target"</strong></p>
<p><strong>Your response should include:</strong></p>
<ul>
<li>"This is a left-bound problem, so I'll use the left-bound
template"</li>
<li>"I'll use left-closed-right-open interval
<code>[left, right)</code>"</li>
<li>"When <code>nums[mid] == target</code>, I'll set
<code>right = mid</code> to continue searching left"</li>
<li>"After the loop, I need to check if <code>left</code> is valid and
<code>nums[left] == target</code>"</li>
</ul>
<p><strong>Scenario 2: "Search in a rotated sorted array"</strong></p>
<p><strong>Your response should include:</strong></p>
<ul>
<li>"Even though the array is rotated, at least one half is always
sorted"</li>
<li>"I'll check which half is sorted by comparing
<code>nums[left]</code> and <code>nums[mid]</code>"</li>
<li>"If target is in the sorted half's range, search there; otherwise
search the other half"</li>
<li>"Handle the edge case where <code>nums[left] == nums[mid]</code>
(for duplicates)"</li>
</ul>
<p><strong>Scenario 3: "Find the minimum value in a rotated sorted
array"</strong></p>
<p><strong>Your response should include:</strong></p>
<ul>
<li>"This is similar to peak finding - we can use binary search"</li>
<li>"Compare <code>nums[mid]</code> with <code>nums[right]</code> to
determine which half contains the minimum"</li>
<li>"If <code>nums[mid] &lt; nums[right]</code>, the minimum is in the
left half (including mid)"</li>
<li>"Otherwise, the minimum is in the right half"</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid</h3>
<ol type="1">
<li><p><strong>Don't memorize without understanding</strong>:
Interviewers can tell if you're just reciting code. Understand why each
line is there.</p></li>
<li><p><strong>Don't skip edge cases</strong>: Always mention how you'll
handle empty arrays, single elements, boundaries, etc.</p></li>
<li><p><strong>Don't ignore integer overflow</strong>: Always use the
safe midpoint calculation, even in Python where it's less
critical.</p></li>
<li><p><strong>Don't forget to verify</strong>: After coding, verify
your solution works for the examples you discussed.</p></li>
<li><p><strong>Don't give up on debugging</strong>: If your code has a
bug, stay calm and debug systematically:</p>
<ul>
<li>Add print statements (mentally or on paper)</li>
<li>Trace through with a small example</li>
<li>Check your loop condition and boundary updates</li>
</ul></li>
</ol>
<h3 id="sample-interview-dialogue">Sample Interview Dialogue</h3>
<p><strong>Interviewer</strong>: "Given a sorted array with duplicates,
find the first and last position of target."</p>
<p><strong>You</strong>: "I'll use the left-bound and right-bound
templates. Let me clarify: should I return <code>[-1, -1]</code> if
target doesn't exist? [Interviewer confirms] Great. I'll implement two
helper functions: <code>left_bound</code> and <code>right_bound</code>.
The left-bound function uses <code>left &lt; right</code> and
<code>right = mid</code> when <code>nums[mid] &gt;= target</code>. The
right-bound function uses <code>left = mid + 1</code> when
<code>nums[mid] &lt;= target</code>. After finding both bounds, I'll
check if target exists, and return the range."</p>
<p><strong>Interviewer</strong>: "Good approach. Can you code it?"</p>
<p><strong>You</strong>: [Code with comments explaining key
decisions]</p>
<p><strong>Interviewer</strong>: "Walk me through with
<code>nums = [5, 7, 7, 8, 8, 10]</code>, <code>target = 8</code>."</p>
<p><strong>You</strong>: "For left-bound: Initially
<code>left=0, right=6</code>. <code>mid=3, nums[3]=8 &gt;= 8</code>, so
<code>right=3</code>. <code>mid=1, nums[1]=7 &lt; 8</code>, so
<code>left=2</code>. <code>mid=2, nums[2]=7 &lt; 8</code>, so
<code>left=3</code>. <code>left=3 == right=3</code>, exit. Left bound is
3. For right-bound: [similar walkthrough]. Right bound is 4. So the
answer is <code>[3, 4]</code>."</p>
<p><strong>Interviewer</strong>: "What's the time complexity?"</p>
<p><strong>You</strong>: "Both binary searches are <span class="math inline">\(O(\log n)\)</span>, so overall it's <span class="math inline">\(O(\log n)\)</span>. Space is <span class="math inline">\(O(1)\)</span>."</p>
<p>This approach demonstrates understanding, clear communication, and
thoroughness - exactly what interviewers are looking for.</p>
<h3 id="additional-interview-dialogue-examples">Additional Interview
Dialogue Examples</h3>
<p><strong>Scenario 1: Handling Edge Cases</strong></p>
<p><strong>Interviewer</strong>: "How would you modify your solution if
the array could be empty?"</p>
<p><strong>You</strong>: "Good catch! I should add an early return at
the beginning. If <code>len(nums) == 0</code>, I'll immediately return
<code>[-1, -1]</code> since there's nothing to search. This prevents any
index out of bounds errors and handles the edge case explicitly."</p>
<p><strong>Interviewer</strong>: "What if the target is smaller than all
elements?"</p>
<p><strong>You</strong>: "In that case, the left-bound function would
return <code>left=0</code>, but when we check
<code>nums[0] != target</code>, we'd correctly return
<code>[-1, -1]</code>. Similarly, if the target is larger than all
elements, <code>left_bound</code> would return
<code>left=len(nums)</code>, and our check
<code>left_idx == len(nums)</code> would catch this and return
<code>[-1, -1]</code>. So the current implementation handles these cases
correctly."</p>
<p><strong>Scenario 2: Optimization Discussion</strong></p>
<p><strong>Interviewer</strong>: "Can you optimize this further?"</p>
<p><strong>You</strong>: "A few potential optimizations come to mind.
First, if we find the left bound and it's out of bounds or doesn't match
the target, we can return <code>[-1, -1]</code> immediately without
searching for the right bound, since we know the target doesn't exist.
Second, if the array is very large and we're searching for a value that
likely doesn't exist, we could first do a quick standard binary search
to check existence before finding bounds. However, for most cases, the
current <span class="math inline">\(O(\log n)\)</span> solution is
already optimal, and these optimizations might add complexity without
significant benefit unless we have specific performance
requirements."</p>
<p><strong>Interviewer</strong>: "What if we needed to find the count of
occurrences?"</p>
<p><strong>You</strong>: "That's straightforward! Once we have both
bounds, if the target exists, the count is simply
<code>right_idx - left_idx + 1</code>. If the target doesn't exist (we
return <code>[-1, -1]</code>), the count would be 0. This is actually
more efficient than scanning the entire array, which would be <span class="math inline">\(O(n)\)</span>, whereas finding bounds is <span class="math inline">\(O(\log n)\)</span>."</p>
<p><strong>Scenario 3: Alternative Approaches</strong></p>
<p><strong>Interviewer</strong>: "Could you solve this with a single
binary search?"</p>
<p><strong>You</strong>: "Interesting question! While it's theoretically
possible to find both bounds in a single pass by tracking additional
state, it would be more complex and wouldn't improve the time
complexity—we'd still need <span class="math inline">\(O(\log
n)\)</span> time. The two-pass approach is cleaner, easier to
understand, and leverages well-known templates. However, if we really
wanted a single pass, we could modify the binary search to track the
leftmost and rightmost positions seen so far, but this adds complexity
without clear benefits. I'd stick with the two-pass approach for
maintainability."</p>
<p><strong>Interviewer</strong>: "What if the array had millions of
elements and we needed to do this search many times?"</p>
<p><strong>You</strong>: "In that case, we might consider preprocessing.
If we're searching for the same target multiple times, we could cache
the results. If we're searching for different targets but the array
doesn't change, we could build additional data structures like a hash
map of value-to-range mappings, but that would require <span class="math inline">\(O(n)\)</span> space. For a general solution that
handles arbitrary targets, the binary search approach is still optimal.
The logarithmic complexity means even with millions of elements, each
search is very fast—about 20-30 comparisons."</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>Post title：LeetCode (5): Binary Search</li>
        <li>Post author：Chen Kai</li>
        <li>Create time：2023-06-15 00:00:00</li>
        <li>
            Post link：https://www.chenk.top/en/leetcode-binary-search/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/en/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/en/tags/Algorithms/">#Algorithms</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/en/leetcode-linked-list-operations/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode (3): Linked List Operations - Reversal, Cycle Detection &amp; Merging</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/en/leetcode-two-pointers/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode (2): Two Pointers - Collision, Fast-Slow &amp; Sliding Window Complete Guide</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情赞美帅气伟大的ck吧~',
                    lang: 'en'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fundamentals"><span class="nav-number">2.</span> <span class="nav-text">Fundamentals</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#core-concept"><span class="nav-number">2.1.</span> <span class="nav-text">Core Concept</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#time-and-space-complexity"><span class="nav-number">2.2.</span> <span class="nav-text">Time and Space Complexity</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#basic-binary-search-template"><span class="nav-number">3.</span> <span class="nav-text">Basic Binary Search Template</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#standard-implementation"><span class="nav-number">3.1.</span> <span class="nav-text">Standard Implementation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#why-left-right---left-2"><span class="nav-number">3.2.</span> <span class="nav-text">Why
left + (right - left) &#x2F;&#x2F; 2?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#example-walkthrough"><span class="nav-number">3.3.</span> <span class="nav-text">Example Walkthrough</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#boundary-handling-left-and-right-bound-templates"><span class="nav-number">4.</span> <span class="nav-text">Boundary
Handling: Left and Right Bound Templates</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#left-bound-template-first-occurrence"><span class="nav-number">4.1.</span> <span class="nav-text">Left Bound Template (First
Occurrence)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#right-bound-template-last-occurrence"><span class="nav-number">4.2.</span> <span class="nav-text">Right Bound Template (Last
Occurrence)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#visual-comparison"><span class="nav-number">4.3.</span> <span class="nav-text">Visual Comparison</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#classic-leetcode-problems"><span class="nav-number">5.</span> <span class="nav-text">Classic LeetCode Problems</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-1-binary-search-leetcode-704"><span class="nav-number">5.1.</span> <span class="nav-text">Problem 1: Binary Search
(LeetCode 704)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-2-search-insert-position-leetcode-35"><span class="nav-number">5.2.</span> <span class="nav-text">Problem 2: Search
Insert Position (LeetCode 35)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-3-find-first-and-last-position-leetcode-34"><span class="nav-number">5.3.</span> <span class="nav-text">Problem 3:
Find First and Last Position (LeetCode 34)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-4-search-in-rotated-sorted-array-leetcode-33"><span class="nav-number">5.4.</span> <span class="nav-text">Problem 4:
Search in Rotated Sorted Array (LeetCode 33)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-5-find-peak-element-leetcode-162"><span class="nav-number">5.5.</span> <span class="nav-text">Problem 5: Find Peak
Element (LeetCode 162)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-6-search-a-2d-matrix-leetcode-74"><span class="nav-number">5.6.</span> <span class="nav-text">Problem 6: Search a 2D
Matrix (LeetCode 74)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-7-search-a-2d-matrix-ii-leetcode-240"><span class="nav-number">5.7.</span> <span class="nav-text">Problem 7: Search
a 2D Matrix II (LeetCode 240)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-8-find-k-closest-elements-leetcode-658"><span class="nav-number">5.8.</span> <span class="nav-text">Problem 8: Find
K Closest Elements (LeetCode 658)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binary-search-on-answer"><span class="nav-number">6.</span> <span class="nav-text">Binary Search on Answer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#concept"><span class="nav-number">6.1.</span> <span class="nav-text">Concept</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-koko-eating-bananas-leetcode-875"><span class="nav-number">6.2.</span> <span class="nav-text">Problem: Koko Eating
Bananas (LeetCode 875)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#more-binary-search-on-answer-problems"><span class="nav-number">6.3.</span> <span class="nav-text">More Binary Search on
Answer Problems</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#common-mistakes-and-debugging-tips"><span class="nav-number">7.</span> <span class="nav-text">Common Mistakes and
Debugging Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mistake-1-infinite-loops"><span class="nav-number">7.1.</span> <span class="nav-text">Mistake 1: Infinite Loops</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mistake-2-off-by-one-errors"><span class="nav-number">7.2.</span> <span class="nav-text">Mistake 2: Off-by-One Errors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mistake-3-integer-overflow"><span class="nav-number">7.3.</span> <span class="nav-text">Mistake 3: Integer Overflow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mistake-4-not-handling-empty-arrays"><span class="nav-number">7.4.</span> <span class="nav-text">Mistake 4: Not Handling
Empty Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#debugging-tips"><span class="nav-number">7.5.</span> <span class="nav-text">Debugging Tips</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#complexity-analysis-deep-dive"><span class="nav-number">8.</span> <span class="nav-text">Complexity Analysis Deep
Dive</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#why-logarithmic"><span class="nav-number">8.1.</span> <span class="nav-text">Why Logarithmic?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#space-complexity"><span class="nav-number">8.2.</span> <span class="nav-text">Space Complexity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#comparison-with-other-search-methods"><span class="nav-number">8.3.</span> <span class="nav-text">Comparison with Other
Search Methods</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qa-common-questions"><span class="nav-number">9.</span> <span class="nav-text">Q&amp;A: Common Questions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#q1-when-should-i-use-left-right-vs-left-right"><span class="nav-number">9.1.</span> <span class="nav-text">Q1: When should I
use left &lt;&#x3D; right vs left &lt; right?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q2-why-do-we-use-right-mid-instead-of-right-mid---1-in-left-bound-template"><span class="nav-number">9.2.</span> <span class="nav-text">Q2:
Why do we use right &#x3D; mid instead of
right &#x3D; mid - 1 in left-bound template?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q3-how-do-i-know-which-template-to-use"><span class="nav-number">9.3.</span> <span class="nav-text">Q3: How do I know which
template to use?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q4-can-binary-search-work-on-unsorted-arrays"><span class="nav-number">9.4.</span> <span class="nav-text">Q4: Can binary
search work on unsorted arrays?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q5-what-if-the-array-has-duplicates"><span class="nav-number">9.5.</span> <span class="nav-text">Q5: What if the array has
duplicates?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q6-how-do-i-handle-negative-numbers-or-very-large-numbers"><span class="nav-number">9.6.</span> <span class="nav-text">Q6:
How do I handle negative numbers or very large numbers?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q7-is-binary-search-always-faster-than-linear-search"><span class="nav-number">9.7.</span> <span class="nav-text">Q7: Is
binary search always faster than linear search?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q8-how-do-i-modify-binary-search-for-descending-arrays"><span class="nav-number">9.8.</span> <span class="nav-text">Q8: How
do I modify binary search for descending arrays?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q9-whats-the-difference-between-mid-left-right-2-and-mid-left-right---left-2"><span class="nav-number">9.9.</span> <span class="nav-text">Q9:
What&#39;s the difference between mid &#x3D; (left + right) &#x2F;&#x2F; 2 and
mid &#x3D; left + (right - left) &#x2F;&#x2F; 2?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q10-how-do-i-debug-a-binary-search-thats-not-working"><span class="nav-number">9.10.</span> <span class="nav-text">Q10: How
do I debug a binary search that&#39;s not working?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q11-how-do-i-handle-floating-point-binary-search"><span class="nav-number">9.11.</span> <span class="nav-text">Q11: How do I
handle floating-point binary search?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q12-can-binary-search-be-used-for-optimization-problems"><span class="nav-number">9.12.</span> <span class="nav-text">Q12:
Can binary search be used for optimization problems?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q13-how-do-i-modify-binary-search-for-descending-arrays"><span class="nav-number">9.13.</span> <span class="nav-text">Q13:
How do I modify binary search for descending arrays?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q14-whats-the-relationship-between-binary-search-and-divide-and-conquer"><span class="nav-number">9.14.</span> <span class="nav-text">Q14:
What&#39;s the relationship between binary search and
divide-and-conquer?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q15-how-do-i-handle-binary-search-when-the-array-might-have-duplicates"><span class="nav-number">9.15.</span> <span class="nav-text">Q15:
How do I handle binary search when the array might have duplicates?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#advanced-binary-search-patterns"><span class="nav-number">10.</span> <span class="nav-text">Advanced Binary Search
Patterns</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-1-binary-search-on-answer-space"><span class="nav-number">10.1.</span> <span class="nav-text">Pattern 1: Binary
Search on Answer Space</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-2-binary-search-with-custom-comparison"><span class="nav-number">10.2.</span> <span class="nav-text">Pattern 2:
Binary Search with Custom Comparison</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-3-binary-search-on-function-values"><span class="nav-number">10.3.</span> <span class="nav-text">Pattern 3: Binary
Search on Function Values</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-4-binary-search-with-two-pointers"><span class="nav-number">10.4.</span> <span class="nav-text">Pattern 4: Binary
Search with Two Pointers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-5-binary-search-on-index-range"><span class="nav-number">10.5.</span> <span class="nav-text">Pattern 5: Binary Search
on Index Range</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#variations-and-extensions"><span class="nav-number">11.</span> <span class="nav-text">Variations and Extensions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#variation-1-search-in-rotated-arrays"><span class="nav-number">11.1.</span> <span class="nav-text">Variation 1: Search in
Rotated Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#variation-2-2d-binary-search"><span class="nav-number">11.2.</span> <span class="nav-text">Variation 2: 2D Binary Search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#variation-3-binary-search-on-answer"><span class="nav-number">11.3.</span> <span class="nav-text">Variation 3: Binary Search
on Answer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#variation-4-finding-peaks"><span class="nav-number">11.4.</span> <span class="nav-text">Variation 4: Finding Peaks</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#common-mistakes-and-debugging-tips-1"><span class="nav-number">12.</span> <span class="nav-text">Common Mistakes and
Debugging Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mistake-1-infinite-loops-1"><span class="nav-number">12.1.</span> <span class="nav-text">Mistake 1: Infinite Loops</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mistake-2-index-out-of-bounds"><span class="nav-number">12.2.</span> <span class="nav-text">Mistake 2: Index Out of
Bounds</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mistake-3-integer-overflow-1"><span class="nav-number">12.3.</span> <span class="nav-text">Mistake 3: Integer Overflow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mistake-4-incorrect-boundary-handling"><span class="nav-number">12.4.</span> <span class="nav-text">Mistake 4: Incorrect
Boundary Handling</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#practical-tips"><span class="nav-number">13.</span> <span class="nav-text">Practical Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#how-to-quickly-identify-binary-search-problems"><span class="nav-number">13.1.</span> <span class="nav-text">How to Quickly
Identify Binary Search Problems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decision-tree-for-template-selection"><span class="nav-number">13.2.</span> <span class="nav-text">Decision Tree for Template
Selection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-solving-steps"><span class="nav-number">13.3.</span> <span class="nav-text">Problem-Solving Steps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#performance-optimization-tips"><span class="nav-number">13.4.</span> <span class="nav-text">Performance Optimization
Tips</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#combining-with-other-algorithms"><span class="nav-number">13.5.</span> <span class="nav-text">Combining with Other
Algorithms</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#real-world-applications-of-binary-search"><span class="nav-number">14.</span> <span class="nav-text">Real-World
Applications of Binary Search</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#database-indexing-and-query-optimization"><span class="nav-number">14.1.</span> <span class="nav-text">Database Indexing and
Query Optimization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#version-control-systems-git-bisect"><span class="nav-number">14.2.</span> <span class="nav-text">Version Control Systems: Git
Bisect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#system-design-load-balancing-and-resource-allocation"><span class="nav-number">14.3.</span> <span class="nav-text">System
Design: Load Balancing and Resource Allocation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search-engines-and-information-retrieval"><span class="nav-number">14.4.</span> <span class="nav-text">Search Engines and
Information Retrieval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#operating-systems-memory-management"><span class="nav-number">14.5.</span> <span class="nav-text">Operating Systems: Memory
Management</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#network-protocols-and-routing"><span class="nav-number">14.6.</span> <span class="nav-text">Network Protocols and
Routing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#game-development-and-graphics"><span class="nav-number">14.7.</span> <span class="nav-text">Game Development and
Graphics</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#financial-systems-trading-and-risk-management"><span class="nav-number">14.8.</span> <span class="nav-text">Financial
Systems: Trading and Risk Management</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#why-these-applications-matter"><span class="nav-number">14.9.</span> <span class="nav-text">Why These Applications
Matter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#summary"><span class="nav-number">15.</span> <span class="nav-text">Summary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#interview-tips-for-binary-search"><span class="nav-number">16.</span> <span class="nav-text">Interview Tips for Binary
Search</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#before-you-start-coding"><span class="nav-number">16.1.</span> <span class="nav-text">Before You Start Coding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#during-coding"><span class="nav-number">16.2.</span> <span class="nav-text">During Coding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#after-coding"><span class="nav-number">16.3.</span> <span class="nav-text">After Coding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#common-interview-scenarios"><span class="nav-number">16.4.</span> <span class="nav-text">Common Interview Scenarios</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#red-flags-to-avoid"><span class="nav-number">16.5.</span> <span class="nav-text">Red Flags to Avoid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sample-interview-dialogue"><span class="nav-number">16.6.</span> <span class="nav-text">Sample Interview Dialogue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#additional-interview-dialogue-examples"><span class="nav-number">16.7.</span> <span class="nav-text">Additional Interview
Dialogue Examples</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
