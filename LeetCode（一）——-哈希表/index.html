<!DOCTYPE html>



<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode（一）—— 哈希表 |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"zh-CN","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode（一）—— 哈希表</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-05-20 00:00:00</span>
        <span class="mobile">2022-05-20 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>11.7k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>48 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>哈希表是算法面试和实际系统中投资回报率最高的数据结构之一：通过牺牲少量内存开销换取快速的成员查询和查找操作，可以将"扫描所有元素"的暴力解法优化为接近线性的高效算法。本文通过三个经典
LeetCode
问题——<strong>两数之和</strong>、<strong>最长连续序列</strong>和<strong>字母异位词分组</strong>——系统性地构建可复用的哈希表思维模式，教你如何设计键值、如何存储数据，以及如何避免常见的边界情况错误。我们还将深入探讨高级模式（互补搜索、频率统计、滑动窗口）、性能对比、面试技巧和调试清单。</p>
<span id="more"></span>
<h1 id="系列导航">系列导航</h1>
<p>📚 <strong>LeetCode 算法精讲系列</strong>（共 10 篇）： 1. <strong>→
哈希表</strong>（两数之和、最长连续序列、字母异位词分组）←
<em>当前文章</em> 2. 双指针技巧（对撞指针、快慢指针、滑动窗口） 3.
链表操作（反转、环检测、合并） 4.
二叉树遍历与递归（中序/前序/后序、最近公共祖先） 5.
动态规划入门（一维/二维 DP、状态转移） 6. 回溯算法（排列、组合、剪枝）
7. 二分查找进阶（整数/实数二分、答案二分） 8.
栈与队列（单调栈、优先队列、双端队列） 9.
图算法（BFS/DFS、拓扑排序、并查集） 10.
贪心与位运算（贪心策略、位操作技巧）</p>
<hr>
<h1 id="哈希表基础回顾">哈希表基础回顾</h1>
<h2 id="什么是哈希表">什么是哈希表？</h2>
<p>哈希表（Hash
Table）是一种根据键（Key）直接访问内存存储位置的数据结构。通过哈希函数将键映射到数组的某个位置，从而实现平均
<span class="math inline">\(O(1)\)</span>
时间复杂度的查找、插入和删除操作。</p>
<p><strong>核心优势</strong>： - <strong>快速查找</strong>：平均 <span class="math inline">\(O(1)\)</span> 时间复杂度 -
<strong>灵活键类型</strong>：不仅限于整数，可以是字符串、元组等 -
<strong>动态扩容</strong>：可以根据需要自动调整大小</p>
<p><strong>性能特点</strong>： - <strong>插入</strong>：平均 <span class="math inline">\(O(1)\)</span> - <strong>查找</strong>：平均 <span class="math inline">\(O(1)\)</span> - <strong>删除</strong>：平均 <span class="math inline">\(O(1)\)</span></p>
<p>最坏情况下性能可能退化（例如恶意碰撞），但对于面试题和大多数实际应用场景，平均情况才是关键。</p>
<h2 id="不同语言中的实现">不同语言中的实现</h2>
<p><strong>Python</strong>： - <code>dict</code> 是哈希映射（键 → 值） -
<code>set</code> 是哈希集合（仅成员关系）</p>
<p><strong>Java</strong>： - <code>HashMap&lt;K,V&gt;</code> 用于键值对
- <code>HashSet&lt;E&gt;</code> 用于唯一元素</p>
<p><strong>C++</strong>： - <code>unordered_map&lt;K,V&gt;</code>
用于键值对 - <code>unordered_set&lt;T&gt;</code> 用于成员关系</p>
<hr>
<h1 id="问题一两数之和">问题一：两数之和</h1>
<h2 id="问题描述">问题描述</h2>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值
<code>target</code>，请你在该数组中找出<strong>和为目标值</strong>的那<strong>两个</strong>整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p><strong>示例</strong>： - 输入：<code>nums = [2,7,11,15]</code>,
<code>target = 9</code> - 输出：<code>[0,1]</code>（因为
<code>nums[0] + nums[1] = 2 + 7 = 9</code>）</p>
<p><strong>约束条件</strong>： - <span class="math inline">\(2 \leq
\texttt{nums.length} \leq 10^4\)</span> - <span class="math inline">\(-10^9 \leq \texttt{nums[i]} \leq 10^9\)</span> -
只会存在一个有效答案</p>
<h2 id="暴力解法用于对比">暴力解法（用于对比）</h2>
<p><strong>朴素思路</strong>：检查所有可能的数对</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">twoSum_bruteforce</span>(<span class="params">nums, target</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                <span class="keyword">return</span> [i, j]</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>： - <strong>时间复杂度</strong>：<span class="math inline">\(O(n^2)\)</span>，需要检查所有 <span class="math inline">\(\binom{n}{2} = \frac{n(n-1)}{2}\)</span> 个数对 -
<strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span>，只使用了常数额外空间</p>
<p><strong>为什么效率低</strong>：当 <code>nums.length = 10,000</code>
时，需要执行约 5000 万次操作！</p>
<h2 id="哈希表解法互补模式">哈希表解法：互补模式</h2>
<p><strong>核心洞察</strong>：从左到右扫描数组时，维护一个映射关系：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值 → 索引</span><br></pre></td></tr></table></figure>
<p>当你看到 <code>num</code> 时，你需要的配对是
<code>target - num</code>（即<strong>互补数</strong>）。如果它已经在映射中，问题解决；否则，存储当前值和索引。</p>
<h3 id="python-实现">Python 实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        seen = &#123;&#125;  <span class="comment"># 值 → 索引</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            complement = target - num</span><br><span class="line">            <span class="keyword">if</span> complement <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> [seen[complement], i]</span><br><span class="line">            seen[num] = i</span><br><span class="line">        <span class="keyword">return</span> []  <span class="comment"># 无解（根据约束条件不应该发生）</span></span><br></pre></td></tr></table></figure>
<h3 id="java-实现">Java 实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; seen = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (seen.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;seen.get(complement), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            seen.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么这样可行">为什么这样可行？</h3>
<p><strong>一次遍历逻辑</strong>： 1. 在索引 <span class="math inline">\(i\)</span> 处，检查 <code>target - nums[i]</code>
是否之前见过 2. 如果是，立即找到配对 3. 如果不是，存储
<code>nums[i] → i</code> 供后续查找</p>
<p><strong>时间演化过程</strong>（对于
<code>nums = [2, 7, 11, 15]</code>, <code>target = 9</code>）：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th><code>i</code></th>
<th><code>num</code></th>
<th><code>complement</code></th>
<th><code>seen</code></th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>2</td>
<td>7</td>
<td><code>&#123;&#125;</code></td>
<td>未找到，存储 <code>&#123;2: 0&#125;</code></td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>7</td>
<td>2</td>
<td><code>&#123;2: 0&#125;</code></td>
<td><strong>找到！</strong> 返回 <code>[0, 1]</code></td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>（单次遍历）</li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>（哈希表最多存储 <span class="math inline">\(n\)</span> 个条目）</li>
</ul>
<p><strong>时空权衡</strong>：我们牺牲 <span class="math inline">\(O(n)\)</span> 的内存空间，将时间复杂度从 <span class="math inline">\(O(n^2)\)</span> 降低到 <span class="math inline">\(O(n)\)</span>。</p>
<h2 id="常见陷阱与边界情况">常见陷阱与边界情况</h2>
<h3 id="陷阱一重复值处理">陷阱一：重复值处理</h3>
<p><strong>情况</strong>：<code>nums = [3, 3]</code>,
<code>target = 6</code></p>
<p><strong>问题</strong>：如果值重复，存储 <code>值 → 索引</code>
是否仍然有效？</p>
<p><strong>答案</strong>：<strong>是的</strong>，因为我们在覆盖之前先检查：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次迭代：i=0, num=3</span></span><br><span class="line">complement = <span class="number">6</span> - <span class="number">3</span> = <span class="number">3</span>  <span class="comment"># 尚未在 seen 中</span></span><br><span class="line">seen[<span class="number">3</span>] = <span class="number">0</span>  <span class="comment"># 存储 &#123;3: 0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次迭代：i=1, num=3</span></span><br><span class="line">complement = <span class="number">6</span> - <span class="number">3</span> = <span class="number">3</span>  <span class="comment"># 在 seen 中找到！</span></span><br><span class="line"><span class="keyword">return</span> [seen[<span class="number">3</span>], <span class="number">1</span>]  <span class="comment"># [0, 1]</span></span><br></pre></td></tr></table></figure>
<h3 id="陷阱二对不能使用同一元素两次的误解">陷阱二：对"不能使用同一元素两次"的误解</h3>
<p><strong>约束说明</strong>："你不能重复使用同一个元素"</p>
<p><strong>困惑</strong>：这是指相同的<strong>值</strong>还是相同的<strong>索引</strong>？</p>
<p><strong>澄清</strong>：指的是相同的<strong>索引</strong>。所以
<code>[3, 3]</code> 且 <code>target = 6</code>
是有效的（不同索引）。</p>
<h3 id="陷阱三不要排序">陷阱三：不要排序！</h3>
<p><strong>诱惑</strong>："让我先排序，然后使用双指针"</p>
<p><strong>问题</strong>：排序会破坏原始索引，但题目要求返回<strong>原始索引</strong>！</p>
<p><strong>解决方案</strong>：如果必须使用双指针方法，存储
<code>(值, 原始索引)</code> 元组并按值排序。</p>
<h3 id="陷阱四返回顺序的差一错误">陷阱四：返回顺序的差一错误</h3>
<p><strong>错误</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [i, seen[complement]]  <span class="comment"># 顺序错误！</span></span><br></pre></td></tr></table></figure>
<p><strong>正确</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [seen[complement], i]  <span class="comment"># 较早的索引在前</span></span><br></pre></td></tr></table></figure>
<h2 id="实际应用类比">实际应用类比</h2>
<ul>
<li><strong>电商</strong>："我有 100
元。这两件商品能符合我的预算吗？"</li>
<li><strong>交易</strong>："这个流中的任何两个订单能否抵消到目标风险敞口？"</li>
<li><strong>化学</strong>："哪两种反应物结合得到这个分子量？"</li>
</ul>
<hr>
<h1 id="问题二最长连续序列">问题二：最长连续序列</h1>
<h2 id="问题描述-1">问题描述</h2>
<p>给定一个未排序的整数数组
<code>nums</code>，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <span class="math inline">\(O(n)\)</span>
的算法解决此问题。</p>
<p><strong>示例</strong>： -
输入：<code>nums = [100, 4, 200, 1, 3, 2]</code> -
输出：<code>4</code>（序列是 <code>[1, 2, 3, 4]</code>）</p>
<p><strong>约束条件</strong>： - <span class="math inline">\(0 \leq
\texttt{nums.length} \leq 10^5\)</span> - <span class="math inline">\(-10^9 \leq \texttt{nums[i]} \leq 10^9\)</span></p>
<h2 id="为什么不直接排序">为什么不直接排序？</h2>
<p><strong>朴素方法</strong>：排序后扫描连续段</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestConsecutive_sort</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    longest = <span class="number">1</span></span><br><span class="line">    current = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> nums[i] == nums[i-<span class="number">1</span>] + <span class="number">1</span>:</span><br><span class="line">            current += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            longest = <span class="built_in">max</span>(longest, current)</span><br><span class="line">            current = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(longest, current)</span><br></pre></td></tr></table></figure>
<p><strong>复杂度</strong>：<span class="math inline">\(O(n \log
n)\)</span>（排序占主导）</p>
<p><strong>问题</strong>：违反了 <span class="math inline">\(O(n)\)</span> 的约束！</p>
<h2 id="哈希集合解法从序列起点开始">哈希集合解法：从序列起点开始</h2>
<p><strong>关键洞察</strong>：一个数字 <span class="math inline">\(x\)</span> 是<strong>序列起点</strong>当且仅当
<span class="math inline">\(x-1\)</span>
<strong>不在</strong>集合中。只从序列起点开始计数；否则，你会多次计算同一个序列。</p>
<h3 id="算法步骤">算法步骤</h3>
<ol type="1">
<li>将所有数字放入集合中，以便 <span class="math inline">\(O(1)\)</span>
成员查询</li>
<li>对于每个数字 <span class="math inline">\(x\)</span>：
<ul>
<li>如果 <span class="math inline">\(x-1\)</span>
在集合中，<strong>跳过</strong>（不是起点）</li>
<li>如果 <span class="math inline">\(x-1\)</span>
<strong>不在</strong>集合中，计数连续数字 <span class="math inline">\(x,
x+1, x+2, \dots\)</span></li>
</ul></li>
</ol>
<h3 id="python-实现-1">Python 实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestConsecutive</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    num_set = <span class="built_in">set</span>(nums)</span><br><span class="line">    longest = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> num_set:</span><br><span class="line">        <span class="comment"># 只从序列起点开始计数</span></span><br><span class="line">        <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">            current_num = num</span><br><span class="line">            current_length = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计数连续数字</span></span><br><span class="line">            <span class="keyword">while</span> current_num + <span class="number">1</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                current_num += <span class="number">1</span></span><br><span class="line">                current_length += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            longest = <span class="built_in">max</span>(longest, current_length)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> longest</span><br></pre></td></tr></table></figure>
<h3 id="为什么这是-on">为什么这是 <span class="math inline">\(O(n)\)</span>？</h3>
<p><strong>误解</strong>："内层 <code>while</code> 循环使其成为 <span class="math inline">\(O(n^2)\)</span>！"</p>
<p><strong>实际情况</strong>：每个数字最多被访问<strong>两次</strong>：
1. 一次在外层循环中 2. 一次作为序列的一部分（内层循环）</p>
<p><strong>证明</strong>：内层 <code>while</code> 只在
<code>num - 1</code> 不在集合中时运行。所以每个序列 <span class="math inline">\([a, a+1, \dots, a+k]\)</span> 恰好被扫描一次（从
<span class="math inline">\(a\)</span> 开始）。</p>
<p><strong>总操作数</strong>：<span class="math inline">\(O(n)\)</span>（外层）+ <span class="math inline">\(O(n)\)</span>（所有序列的内层）= <span class="math inline">\(O(n)\)</span></p>
<h2 id="复杂度分析-1">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>（见上述证明）</li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>（哈希集合）</li>
</ul>
<h2 id="示例逐步解析">示例逐步解析</h2>
<p><strong>输入</strong>：<code>nums = [100, 4, 200, 1, 3, 2]</code></p>
<p><strong>步骤 1</strong>：构建集合
<code>&#123;100, 4, 200, 1, 3, 2&#125;</code></p>
<p><strong>步骤 2</strong>：遍历集合</p>
<table>
<thead>
<tr>
<th><code>num</code></th>
<th><code>num-1</code> 在集合中？</th>
<th>操作</th>
<th><code>current_length</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>否（99 不在集合中）</td>
<td>开始序列</td>
<td>计数 <code>100</code> → 长度 1</td>
</tr>
<tr>
<td>4</td>
<td>是（3 在集合中）</td>
<td><strong>跳过</strong></td>
<td>-</td>
</tr>
<tr>
<td>200</td>
<td>否（199 不在集合中）</td>
<td>开始序列</td>
<td>计数 <code>200</code> → 长度 1</td>
</tr>
<tr>
<td>1</td>
<td>否（0 不在集合中）</td>
<td><strong>开始序列</strong></td>
<td>计数 <code>1,2,3,4</code> → 长度 <strong>4</strong></td>
</tr>
<tr>
<td>3</td>
<td>是（2 在集合中）</td>
<td><strong>跳过</strong></td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>是（1 在集合中）</td>
<td><strong>跳过</strong></td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong>输出</strong>：<code>4</code></p>
<h2 id="常见边界情况">常见边界情况</h2>
<h3 id="边界情况一空数组">边界情况一：空数组</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = []</span><br><span class="line"><span class="comment"># 输出：0</span></span><br></pre></td></tr></table></figure>
<h3 id="边界情况二全部重复">边界情况二：全部重复</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 集合变为 &#123;1&#125;，输出：1</span></span><br></pre></td></tr></table></figure>
<h3 id="边界情况三无连续数字">边界情况三：无连续数字</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment"># 每个数字都是自己的序列，输出：1</span></span><br></pre></td></tr></table></figure>
<h3 id="边界情况四整个数组连续">边界情况四：整个数组连续</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 序列 [1,2,3,4,5]，输出：5</span></span><br></pre></td></tr></table></figure>
<h3 id="边界情况五负数">边界情况五：负数</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [-<span class="number">1</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 序列 [-2,-1,0,1,2]，输出：5</span></span><br></pre></td></tr></table></figure>
<h2 id="实际应用">实际应用</h2>
<ul>
<li><strong>版本控制</strong>：查找连续提交的最长序列</li>
<li><strong>游戏</strong>：检测最长连胜记录</li>
<li><strong>时间序列</strong>：查找没有缺失数据的最长时期</li>
</ul>
<hr>
<h1 id="问题三字母异位词分组">问题三：字母异位词分组</h1>
<h2 id="问题描述-2">问题描述</h2>
<p>给你一个字符串数组，请你将<strong>字母异位词</strong>组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong>是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<p><strong>示例</strong>： -
输入：<code>strs = ["eat","tea","tan","ate","nat","bat"]</code> -
输出：<code>[["bat"],["nat","tan"],["ate","eat","tea"]]</code></p>
<p><strong>约束条件</strong>： - <span class="math inline">\(1 \leq
\texttt{strs.length} \leq 10^4\)</span> - <span class="math inline">\(0
\leq \texttt{strs[i].length} \leq 100\)</span> - <code>strs[i]</code>
由小写英文字母组成</p>
<h2 id="关键洞察什么是好的哈希键">关键洞察：什么是好的哈希键？</h2>
<p><strong>字母异位词</strong>具有相同的字符但顺序不同。我们需要一个<strong>规范形式</strong>，对所有字母异位词都相同。</p>
<h3 id="方法一排序字符串作为键">方法一：排序字符串作为键</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">strs</span>):</span><br><span class="line">    groups = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">        key = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">sorted</span>(s))  <span class="comment"># 规范形式</span></span><br><span class="line">        groups[key].append(s)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(groups.values())</span><br></pre></td></tr></table></figure>
<p><strong>示例</strong>： - <code>"eat"</code> → 排序 →
<code>"aet"</code> - <code>"tea"</code> → 排序 → <code>"aet"</code> -
<code>"ate"</code> → 排序 → <code>"aet"</code></p>
<p>全部映射到同一个键！</p>
<p><strong>复杂度</strong>： - <strong>时间复杂度</strong>：<span class="math inline">\(O(n \cdot k \log k)\)</span>，其中 <span class="math inline">\(n = \texttt{len(strs)}\)</span>，<span class="math inline">\(k = \texttt{最大字符串长度}\)</span> -
<strong>空间复杂度</strong>：<span class="math inline">\(O(n \cdot
k)\)</span></p>
<h3 id="方法二字符计数作为键更快">方法二：字符计数作为键（更快！）</h3>
<p>不排序，而是统计字符频率：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict, Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">groupAnagrams_optimized</span>(<span class="params">strs</span>):</span><br><span class="line">    groups = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">        <span class="comment"># 统计字符：&#123;&#x27;e&#x27;:1, &#x27;a&#x27;:1, &#x27;t&#x27;:1&#125;</span></span><br><span class="line">        count = Counter(s)</span><br><span class="line">        <span class="comment"># 转换为元组（可哈希）：((&#x27;a&#x27;,1), (&#x27;e&#x27;,1), (&#x27;t&#x27;,1))</span></span><br><span class="line">        key = <span class="built_in">tuple</span>(<span class="built_in">sorted</span>(count.items()))</span><br><span class="line">        groups[key].append(s)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(groups.values())</span><br></pre></td></tr></table></figure>
<p><strong>复杂度</strong>： - <strong>时间复杂度</strong>：<span class="math inline">\(O(n \cdot k)\)</span>（计数是 <span class="math inline">\(O(k)\)</span>，排序 26 个字母是 <span class="math inline">\(O(1)\)</span>） -
<strong>空间复杂度</strong>：<span class="math inline">\(O(n \cdot
k)\)</span></p>
<p><strong>为什么更快</strong>：计数 <span class="math inline">\(k\)</span> 个字符是 <span class="math inline">\(O(k)\)</span>，但排序是 <span class="math inline">\(O(k \log k)\)</span>。</p>
<h3 id="方法三固定大小数组作为键小写英文字母最佳">方法三：固定大小数组作为键（小写英文字母最佳）</h3>
<p>对于小写英文字母（共 26 个），使用固定大小的计数数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">groupAnagrams_fastest</span>(<span class="params">strs</span>):</span><br><span class="line">    groups = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">        <span class="comment"># 计数数组：[a的数量, b的数量, ..., z的数量]</span></span><br><span class="line">        count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            count[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 转换为元组（可哈希）</span></span><br><span class="line">        key = <span class="built_in">tuple</span>(count)</span><br><span class="line">        groups[key].append(s)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(groups.values())</span><br></pre></td></tr></table></figure>
<p><strong>复杂度</strong>： - <strong>时间复杂度</strong>：<span class="math inline">\(O(n \cdot k)\)</span> -
<strong>空间复杂度</strong>：<span class="math inline">\(O(n \cdot
k)\)</span></p>
<p><strong>为什么最快</strong>：完全不需要排序，只需遍历每个字符串一次。</p>
<h2 id="复杂度对比">复杂度对比</h2>
<table>
<colgroup>
<col style="width: 17%">
<col style="width: 32%">
<col style="width: 32%">
<col style="width: 17%">
</colgroup>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>排序字符串</strong></td>
<td><span class="math inline">\(O(n \cdot k \log k)\)</span></td>
<td><span class="math inline">\(O(n \cdot k)\)</span></td>
<td>简单，通用</td>
</tr>
<tr>
<td><strong>Counter + 排序</strong></td>
<td><span class="math inline">\(O(n \cdot k)\)</span></td>
<td><span class="math inline">\(O(n \cdot k)\)</span></td>
<td>更快，适用于任何字符集</td>
</tr>
<tr>
<td><strong>固定数组</strong></td>
<td><span class="math inline">\(O(n \cdot k)\)</span></td>
<td><span class="math inline">\(O(n \cdot k)\)</span></td>
<td><strong>最快</strong>，仅限小写英文字母</td>
</tr>
</tbody>
</table>
<h2 id="示例逐步解析-1">示例逐步解析</h2>
<p><strong>输入</strong>：<code>strs = ["eat", "tea", "tan", "ate", "nat", "bat"]</code></p>
<p><strong>使用排序字符串键</strong>：</p>
<table>
<thead>
<tr>
<th>字符串</th>
<th>排序键</th>
<th>分组</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>"eat"</code></td>
<td><code>"aet"</code></td>
<td>组 A</td>
</tr>
<tr>
<td><code>"tea"</code></td>
<td><code>"aet"</code></td>
<td>组 A</td>
</tr>
<tr>
<td><code>"tan"</code></td>
<td><code>"ant"</code></td>
<td>组 B</td>
</tr>
<tr>
<td><code>"ate"</code></td>
<td><code>"aet"</code></td>
<td>组 A</td>
</tr>
<tr>
<td><code>"nat"</code></td>
<td><code>"ant"</code></td>
<td>组 B</td>
</tr>
<tr>
<td><code>"bat"</code></td>
<td><code>"abt"</code></td>
<td>组 C</td>
</tr>
</tbody>
</table>
<p><strong>输出</strong>：<code>[["eat","tea","ate"], ["tan","nat"], ["bat"]]</code></p>
<h2 id="边界情况">边界情况</h2>
<h3 id="边界情况一空字符串">边界情况一：空字符串</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strs = [<span class="string">&quot;&quot;</span>]</span><br><span class="line"><span class="comment"># 输出：[[&quot;&quot;]]</span></span><br></pre></td></tr></table></figure>
<h3 id="边界情况二单字符">边界情况二：单字符</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strs = [<span class="string">&quot;a&quot;</span>]</span><br><span class="line"><span class="comment"># 输出：[[&quot;a&quot;]]</span></span><br></pre></td></tr></table></figure>
<h3 id="边界情况三无字母异位词">边界情况三：无字母异位词</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strs = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line"><span class="comment"># 输出：[[&quot;abc&quot;], [&quot;def&quot;], [&quot;ghi&quot;]]</span></span><br></pre></td></tr></table></figure>
<h3 id="边界情况四全部是字母异位词">边界情况四：全部是字母异位词</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strs = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;bca&quot;</span>, <span class="string">&quot;cab&quot;</span>]</span><br><span class="line"><span class="comment"># 输出：[[&quot;abc&quot;, &quot;bca&quot;, &quot;cab&quot;]]</span></span><br></pre></td></tr></table></figure>
<h2 id="实际应用-1">实际应用</h2>
<ul>
<li><strong>拼写检查</strong>：按字母组成对拼写错误分组</li>
<li><strong>基因组学</strong>：聚类具有相同核苷酸计数的 DNA 序列</li>
<li><strong>数据去重</strong>：查找具有相同属性（顺序不同）的记录</li>
</ul>
<hr>
<h1 id="高级哈希表模式">高级哈希表模式</h1>
<h2 id="模式一互补搜索两数之和变体">模式一：互补搜索（两数之和变体）</h2>
<p><strong>使用时机</strong>：需要找到满足条件的数对</p>
<p><strong>示例</strong>： - 三数之和（扩展到三元组） - 四数之和 -
统计具有给定差值的数对</p>
<h2 id="模式二频率统计">模式二：频率统计</h2>
<p><strong>使用时机</strong>：需要跟踪出现次数</p>
<p><strong>示例</strong>： - 前 K 个高频元素 - 第一个唯一字符 -
有效的字母异位词（比排序更简单）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">s, t</span>):</span><br><span class="line">    <span class="keyword">return</span> Counter(s) == Counter(t)</span><br></pre></td></tr></table></figure>
<h2 id="模式三滑动窗口-哈希映射">模式三：滑动窗口 + 哈希映射</h2>
<p><strong>使用时机</strong>：固定大小窗口的跟踪</p>
<p><strong>示例</strong>：最多包含 K 个不同字符的最长子串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstringKDistinct</span>(<span class="params">s, k</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    char_count = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        char_count[s[right]] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果不同字符太多，缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(char_count) &gt; k:</span><br><span class="line">            char_count[s[left]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> char_count[s[left]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> char_count[s[left]]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h2 id="模式四前缀和与哈希映射">模式四：前缀和与哈希映射</h2>
<p><strong>使用时机</strong>：需要子数组和</p>
<p><strong>示例</strong>：和为 K 的子数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">nums, k</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">    prefix_sum = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    sum_count = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    sum_count[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment"># 基本情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        prefix_sum += num</span><br><span class="line">        <span class="comment"># 检查是否存在 (prefix_sum - k)</span></span><br><span class="line">        <span class="keyword">if</span> prefix_sum - k <span class="keyword">in</span> sum_count:</span><br><span class="line">            count += sum_count[prefix_sum - k]</span><br><span class="line">        sum_count[prefix_sum] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="哈希表内部机制进阶知识">哈希表内部机制（进阶知识）</h1>
<h2 id="python-dict-的工作原理">Python <code>dict</code> 的工作原理</h2>
<p><strong>底层实现</strong>： 1.
<strong>哈希函数</strong>：将键转换为整数 <code>hash(key)</code> 2.
<strong>桶选择</strong>：<code>index = hash(key) % table_size</code> 3.
<strong>碰撞处理</strong>：Python
使用<strong>开放寻址</strong>和探测</p>
<p><strong>负载因子</strong>：当
<code>num_entries / table_size &gt; 2/3</code> 时，Python
<strong>调整大小</strong>（加倍大小）。</p>
<h2 id="碰撞解决">碰撞解决</h2>
<h3 id="开放寻址python">开放寻址（Python）</h3>
<p>当桶被占用时，探测下一个槽位： - 线性探测：尝试
<code>index+1, index+2, ...</code> - 二次探测：尝试
<code>index+1^2, index+2^2, ...</code></p>
<h3 id="链式法java-hashmap">链式法（Java <code>HashMap</code>）</h3>
<p>每个桶存储一个<strong>链表</strong>（如果太长则使用树）来存储碰撞的条目。</p>
<h2 id="哈希函数质量">哈希函数质量</h2>
<p><strong>好的哈希函数</strong>： - 确定性（相同键 → 相同哈希） -
均匀分布（避免聚集） - 计算快速</p>
<p><strong>Python 的 <code>hash()</code></strong>： -
整数：<code>hash(x) = x</code>（对于小的 <span class="math inline">\(x\)</span>） - 字符串：使用 SipHash（密码学质量）
- 自定义对象：重写 <code>__hash__</code> 和 <code>__eq__</code></p>
<hr>
<h1 id="常见错误与调试清单">常见错误与调试清单</h1>
<h2 id="错误一插入前忘记检查">错误一：插入前忘记检查</h2>
<p><strong>错误</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seen[num] = i</span><br><span class="line"><span class="keyword">if</span> target - num <span class="keyword">in</span> seen:</span><br><span class="line">    <span class="keyword">return</span> [seen[target - num], i]</span><br></pre></td></tr></table></figure>
<p><strong>正确</strong>：在插入<strong>之前</strong>检查（避免自配对）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> target - num <span class="keyword">in</span> seen:</span><br><span class="line">    <span class="keyword">return</span> [seen[target - num], i]</span><br><span class="line">seen[num] = i</span><br></pre></td></tr></table></figure>
<h2 id="错误二使用不可哈希的键">错误二：使用不可哈希的键</h2>
<p><strong>错误</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># 列表不可哈希！</span></span><br><span class="line">groups[key].append(value)  <span class="comment"># TypeError</span></span><br></pre></td></tr></table></figure>
<p><strong>修复</strong>：转换为元组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<h2 id="错误三修改哈希键">错误三：修改哈希键</h2>
<p><strong>危险</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">groups[<span class="built_in">tuple</span>(key)] = <span class="string">&quot;value&quot;</span></span><br><span class="line">key.append(<span class="number">3</span>)  <span class="comment"># 哈希后不要修改！</span></span><br></pre></td></tr></table></figure>
<p><strong>规则</strong>：将哈希键视为<strong>不可变</strong>。</p>
<h2 id="错误四索引计算中的差一错误">错误四：索引计算中的差一错误</h2>
<p><strong>仔细检查</strong>： - 返回的是 <code>[i, j]</code> 还是
<code>[j, i]</code>？ - 题目要求的是 0 索引还是 1 索引输出？</p>
<h2 id="调试清单">调试清单</h2>
<p>✅ <strong>编码前</strong>： 1.
键应该是什么？（值、计数、排序形式？） 2.
值应该是什么？（索引、列表、计数？） 3. 需要 <code>dict</code> 还是
<code>set</code>？</p>
<p>✅ <strong>编码后</strong>： 1. 测试空输入 2. 测试单个元素 3.
测试重复值 4. 测试全部唯一元素 5.
打印每一步的哈希表内容（对于小输入）</p>
<hr>
<h1 id="面试技巧">面试技巧</h1>
<h2 id="技巧一表达你的思考过程">技巧一：表达你的思考过程</h2>
<p><strong>模板</strong>： &gt;
"我注意到我们在寻找数对/分组/匹配，这提示使用哈希表。我将存储 [X]
作为键，[Y] 作为值。查找将是 [Z]。"</p>
<h2 id="技巧二从暴力解法开始">技巧二：从暴力解法开始</h2>
<p>即使你知道哈希表解法，也要说： &gt; "暴力解法是 <span class="math inline">\(O(n^2)\)</span>，使用嵌套循环。我们可以使用哈希映射优化到
<span class="math inline">\(O(n)\)</span>。"</p>
<h2 id="技巧三澄清约束条件">技巧三：澄清约束条件</h2>
<p>询问： - 数组可以有重复值吗？ - 数组是否已排序？ -
预期大小是多少？（影响空间复杂度考虑） - 有负数吗？</p>
<h2 id="技巧四分析权衡">技巧四：分析权衡</h2>
<p>在你的解法之后，提及： &gt; "这用 <span class="math inline">\(O(n)\)</span> 空间换取 <span class="math inline">\(O(n)\)</span> 时间。如果内存紧张，我们可以回退到
<span class="math inline">\(O(n \log n)\)</span> 的排序方法。"</p>
<h2 id="技巧五大声处理边界情况">技巧五：大声处理边界情况</h2>
<p>逐步说明： - 空数组 - 单个元素 - 全部重复 - 全部唯一</p>
<hr>
<h1 id="时间节省技巧">时间节省技巧</h1>
<h2 id="技巧一使用-collections.counter">技巧一：使用
<code>collections.Counter</code></h2>
<p>而不是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">freq = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">    freq[x] = freq.get(x, <span class="number">0</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">freq = Counter(nums)</span><br></pre></td></tr></table></figure>
<h2 id="技巧二使用-collections.defaultdict">技巧二：使用
<code>collections.defaultdict</code></h2>
<p>而不是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">groups = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> groups:</span><br><span class="line">        groups[key] = []</span><br><span class="line">    groups[key].append(item)</span><br></pre></td></tr></table></figure>
<p>写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">groups = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    groups[key].append(item)</span><br></pre></td></tr></table></figure>
<h2 id="技巧三使用-enumerate-获取索引值">技巧三：使用
<code>enumerate</code> 获取索引+值</h2>
<p>而不是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    num = nums[i]</span><br></pre></td></tr></table></figure>
<p>写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="性能对比哈希表-vs-替代方案">性能对比：哈希表 vs 替代方案</h1>
<table>
<colgroup>
<col style="width: 17%">
<col style="width: 25%">
<col style="width: 17%">
<col style="width: 22%">
<col style="width: 17%">
</colgroup>
<thead>
<tr>
<th>问题</th>
<th>暴力解法</th>
<th>排序</th>
<th>哈希表</th>
<th>胜者</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>两数之和</strong></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><strong>哈希表</strong></td>
</tr>
<tr>
<td><strong>最长连续序列</strong></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><strong>哈希表</strong></td>
</tr>
<tr>
<td><strong>字母异位词分组</strong></td>
<td><span class="math inline">\(O(n^2 k)\)</span></td>
<td><span class="math inline">\(O(n k \log k)\)</span></td>
<td><span class="math inline">\(O(n k)\)</span></td>
<td><strong>哈希表</strong></td>
</tr>
<tr>
<td><strong>查找重复</strong></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><strong>哈希表</strong></td>
</tr>
</tbody>
</table>
<p><strong>排序胜出的情况</strong>： - 需要排序输出 - 空间极度受限（需要
<span class="math inline">\(O(1)\)</span>） - 数据已经部分排序</p>
<hr>
<h1 id="练习题目10-道推荐">练习题目（10 道推荐）</h1>
<h2 id="简单">简单</h2>
<ol type="1">
<li><strong>存在重复元素</strong>（LeetCode 217）</li>
<li><strong>有效的字母异位词</strong>（LeetCode 242）</li>
<li><strong>两个数组的交集</strong>（LeetCode 349）</li>
</ol>
<h2 id="中等">中等</h2>
<ol start="4" type="1">
<li><strong>字母异位词分组</strong>（LeetCode 49）← 本文已覆盖</li>
<li><strong>前 K 个高频元素</strong>（LeetCode 347）</li>
<li><strong>和为 K 的子数组</strong>（LeetCode 560）</li>
<li><strong>无重复字符的最长子串</strong>（LeetCode 3）</li>
</ol>
<h2 id="困难">困难</h2>
<ol start="8" type="1">
<li><strong>最长连续序列</strong>（LeetCode 128）← 本文已覆盖</li>
<li><strong>串联所有单词的子串</strong>（LeetCode 30）</li>
<li><strong>缺失的第一个正数</strong>（LeetCode 41）←
技巧：使用数组作为哈希表！</li>
</ol>
<hr>
<h1 id="总结一页纸掌握哈希表">总结：一页纸掌握哈希表</h1>
<p><strong>何时使用</strong>： - 需要快速查找（平均 <span class="math inline">\(O(1)\)</span>） - 寻找数对/互补数 - 按键分组 -
频率统计 - 检查成员关系</p>
<p><strong>常见模式</strong>： 1.
<strong>互补搜索</strong>：存储已见值，检查
<code>target - current</code> 2.
<strong>规范形式</strong>：按排序/规范化键分组 3.
<strong>频率映射</strong>：使用 <code>Counter</code> 或
<code>defaultdict(int)</code> 统计出现次数 4.
<strong>滑动窗口</strong>：在固定大小窗口中跟踪状态</p>
<p><strong>要避免的陷阱</strong>： - 插入前检查（避免自配对） -
使用不可变键（元组，不是列表） - 正确处理重复值 -
不要忘记边界情况（空、单个元素）</p>
<p><strong>面试模板</strong>： 1. 识别快速查找的需求 2. 决定键和值的类型
3. 用示例逐步说明 4. 使用 <code>dict</code>/<code>set</code> 编码 5.
分析复杂度 6. 测试边界情况</p>
<p><strong>记忆口诀</strong>： &gt; <strong>哈希表用空间换时间：<span class="math inline">\(O(n)\)</span> 内存换取 <span class="math inline">\(O(1)\)</span>
查找。完美适用于"查找数对/分组/匹配"问题。</strong></p>
<hr>
<h1 id="下一步是什么">下一步是什么？</h1>
<p>在<strong>第二部分（双指针技巧）</strong>中，我们将探索： -
<strong>对撞指针</strong>：从两端挤压（盛最多水的容器） -
<strong>快慢指针</strong>：检测环（Floyd 算法） -
<strong>滑动窗口</strong>：动态窗口大小调整（最长子串） - 何时使用哈希表
vs 双指针</p>
<p><strong>预览问题</strong>：如何在不使用 <span class="math inline">\(O(n^2)\)</span>
空间的情况下解决三数之和？第二部分见！</p>
<hr>
<h2 id="qa哈希表常见问题">❓ Q&amp;A：哈希表常见问题</h2>
<h3 id="q1什么时候应该使用哈希表而不是数组进行查找">Q1：什么时候应该使用哈希表而不是数组进行查找？</h3>
<p><strong>答案</strong>：当需要<strong>非顺序键访问</strong>或键是<strong>稀疏的</strong>（不是从
0 开始的连续整数）时，使用哈希表。</p>
<p><strong>数组优势</strong>： - 直接索引：<code>arr[i]</code> 保证
<span class="math inline">\(O(1)\)</span> - 更好的缓存局部性（连续内存）
- 更低的内存开销（无哈希函数，无碰撞处理） -
可预测的性能（无最坏情况退化）</p>
<p><strong>哈希表优势</strong>： - 灵活的键（字符串、元组、自定义对象）
- 稀疏键不浪费内存 - 动态调整大小无需重新索引</p>
<p><strong>对比表</strong>：</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 23%">
<col style="width: 30%">
<col style="width: 23%">
</colgroup>
<thead>
<tr>
<th>场景</th>
<th>数组</th>
<th>哈希表</th>
<th>胜者</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>连续整数键 [0..n-1]</strong></td>
<td><span class="math inline">\(O(1)\)</span> 直接访问</td>
<td><span class="math inline">\(O(1)\)</span> 平均</td>
<td><strong>数组</strong>（更简单，更快）</td>
</tr>
<tr>
<td><strong>稀疏整数键 [1, 100, 1000]</strong></td>
<td><span class="math inline">\(O(1)\)</span> 但浪费内存</td>
<td><span class="math inline">\(O(1)\)</span> 平均</td>
<td><strong>哈希表</strong>（空间高效）</td>
</tr>
<tr>
<td><strong>字符串键</strong></td>
<td>不可能</td>
<td><span class="math inline">\(O(1)\)</span> 平均</td>
<td><strong>哈希表</strong>（唯一选择）</td>
</tr>
<tr>
<td><strong>固定大小，已知范围</strong></td>
<td><span class="math inline">\(O(1)\)</span> 保证</td>
<td><span class="math inline">\(O(1)\)</span> 平均</td>
<td><strong>数组</strong>（可预测）</td>
</tr>
<tr>
<td><strong>未知/动态键</strong></td>
<td>不实用</td>
<td><span class="math inline">\(O(1)\)</span> 平均</td>
<td><strong>哈希表</strong>（灵活）</td>
</tr>
</tbody>
</table>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组：完美适用于连续索引</span></span><br><span class="line">scores = [<span class="number">85</span>, <span class="number">90</span>, <span class="number">78</span>, <span class="number">92</span>]  <span class="comment"># 学生 0, 1, 2, 3</span></span><br><span class="line"><span class="built_in">print</span>(scores[<span class="number">2</span>])  <span class="comment"># O(1)，直接访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈希表：完美适用于稀疏/非整数键</span></span><br><span class="line">student_scores = &#123;<span class="string">&quot;Alice&quot;</span>: <span class="number">85</span>, <span class="string">&quot;Bob&quot;</span>: <span class="number">90</span>, <span class="string">&quot;Charlie&quot;</span>: <span class="number">78</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(student_scores[<span class="string">&quot;Bob&quot;</span>])  <span class="comment"># O(1) 平均，灵活键</span></span><br></pre></td></tr></table></figure>
<p><strong>面试提示</strong>：如果问题提到"索引"或"位置"，首先考虑数组。如果提到"值"或"标识符"，哈希表可能更好。</p>
<hr>
<h3 id="q2不同的碰撞处理策略有哪些什么时候应该使用每种">Q2：不同的碰撞处理策略有哪些，什么时候应该使用每种？</h3>
<p><strong>答案</strong>：主要有两种方法：<strong>链式法</strong>和<strong>开放寻址</strong>。每种都有权衡。</p>
<p><strong>链式法（Separate Chaining）</strong>： -
每个桶存储一个链表（或树，如果太长）来存储碰撞的条目 - 使用于：Java
<code>HashMap</code>、C++ <code>std::unordered_map</code>（默认） -
<strong>优点</strong>：简单，能很好地处理高负载因子，无聚集 -
<strong>缺点</strong>：指针的额外内存，链表的缓存未命中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 概念表示</span></span><br><span class="line">buckets = [</span><br><span class="line">    [(<span class="string">&quot;key1&quot;</span>, value1), (<span class="string">&quot;key2&quot;</span>, value2)],  <span class="comment"># 桶 0：碰撞链</span></span><br><span class="line">    [(<span class="string">&quot;key3&quot;</span>, value3)],                    <span class="comment"># 桶 1：单个条目</span></span><br><span class="line">    [],                                     <span class="comment"># 桶 2：空</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>开放寻址</strong>： - 当发生碰撞时，探测下一个可用槽位 -
使用于：Python <code>dict</code>、Go <code>map</code> -
<strong>探测方法</strong>： -
<strong>线性探测</strong>：<code>(hash(key) + i) % size</code>，其中
<span class="math inline">\(i = 0, 1, 2, \dots\)</span> -
<strong>二次探测</strong>：<code>(hash(key) + i^2) % size</code> -
<strong>双重哈希</strong>：<code>(hash1(key) + i * hash2(key)) % size</code>
- <strong>优点</strong>：更好的缓存局部性，无额外指针 -
<strong>缺点</strong>：高负载因子时性能退化，聚集问题</p>
<p><strong>对比</strong>：</p>
<table>
<thead>
<tr>
<th>方面</th>
<th>链式法</th>
<th>开放寻址</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>负载因子容忍度</strong></td>
<td>高（0.8-1.0）</td>
<td>较低（0.5-0.7）</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>更高（指针）</td>
<td>更低（无指针）</td>
</tr>
<tr>
<td><strong>缓存性能</strong></td>
<td>更差（分散）</td>
<td>更好（连续）</td>
</tr>
<tr>
<td><strong>删除复杂度</strong></td>
<td>简单</td>
<td>复杂（墓碑）</td>
</tr>
<tr>
<td><strong>最坏情况保证</strong></td>
<td><span class="math inline">\(O(n)\)</span> 每次操作</td>
<td><span class="math inline">\(O(n)\)</span> 每次操作</td>
</tr>
</tbody>
</table>
<p><strong>何时使用</strong>： -
<strong>链式法</strong>：预期高负载因子，许多删除操作，简单实现 -
<strong>开放寻址</strong>：内存受限，缓存性能关键，很少删除</p>
<p><strong>面试注意</strong>：你很少自己实现碰撞处理。理解权衡有助于解释为什么哈希表性能可能退化以及何时考虑替代方案。</p>
<hr>
<h3 id="q3在-python-中什么时候应该使用-dict-vs-set">Q3：在 Python
中什么时候应该使用 <code>dict</code> vs <code>set</code>？</h3>
<p><strong>答案</strong>：当需要<strong>键值对</strong>时使用
<code>dict</code>，当只需要<strong>成员测试</strong>时使用
<code>set</code>。</p>
<p><strong><code>dict</code>（字典）</strong>： -
存储键值映射：<code>&#123;key: value&#125;</code> -
用例：统计频率、存储元数据、映射关系</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计频率</span></span><br><span class="line">freq = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]:</span><br><span class="line">    freq[num] = freq.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment"># 结果：&#123;1: 1, 2: 2, 3: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储索引</span></span><br><span class="line">index_map = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]):</span><br><span class="line">    index_map[val] = i</span><br><span class="line"><span class="comment"># 结果：&#123;10: 0, 20: 1, 30: 2&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong><code>set</code>（哈希集合）</strong>： -
仅存储唯一键：<code>&#123;key1, key2, key3&#125;</code> -
用例：去重、成员测试、集合操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去重</span></span><br><span class="line">unique_nums = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># 结果：&#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速成员测试</span></span><br><span class="line">seen = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">if</span> num <span class="keyword">in</span> seen:  <span class="comment"># O(1) 平均</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;重复！&quot;</span>)</span><br><span class="line">    seen.add(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合操作</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">intersection = set1 &amp; set2  <span class="comment"># &#123;2, 3&#125;</span></span><br><span class="line">union = set1 | set2         <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>决策树</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">需要存储带键的值吗？</span><br><span class="line">├─ 是 → 使用 dict</span><br><span class="line">│  └─ 示例：频率统计、索引映射、缓存</span><br><span class="line">│</span><br><span class="line">└─ 否 → 使用 set</span><br><span class="line">   └─ 示例：去重、成员测试、集合操作</span><br></pre></td></tr></table></figure>
<p><strong>性能对比</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th><code>dict</code></th>
<th><code>set</code></th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>插入</strong></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>相似性能</td>
</tr>
<tr>
<td><strong>查找</strong></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>相似性能</td>
</tr>
<tr>
<td><strong>内存</strong></td>
<td>更高（存储值）</td>
<td>更低（仅键）</td>
<td><code>set</code> 节省约 30-40% 内存</td>
</tr>
<tr>
<td><strong>用例</strong></td>
<td>键值映射</td>
<td>成员测试</td>
<td>不同目的</td>
</tr>
</tbody>
</table>
<p><strong>常见错误</strong>：当只需要 <code>set</code> 时使用
<code>dict</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 低效：存储虚拟值</span></span><br><span class="line">seen = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">        seen[num] = <span class="literal">True</span>  <span class="comment"># 浪费！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 高效：使用 set</span></span><br><span class="line">seen = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">        seen.add(num)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="q4什么是好的哈希函数常见的陷阱是什么">Q4：什么是好的哈希函数，常见的陷阱是什么？</h3>
<p><strong>答案</strong>：好的哈希函数应该是<strong>确定性的</strong>、<strong>均匀的</strong>和<strong>快速的</strong>。差的哈希函数会导致碰撞并降低性能。</p>
<p><strong>好的哈希函数的属性</strong>：</p>
<ol type="1">
<li><strong>确定性</strong>：相同输入 → 相同输出（总是）</li>
<li><strong>均匀分布</strong>：键应该均匀映射到各个桶</li>
<li><strong>快速计算</strong>：应该是 <span class="math inline">\(O(1)\)</span> 或 <span class="math inline">\(O(k)\)</span>，其中 <span class="math inline">\(k\)</span> 是键大小</li>
<li><strong>雪崩效应</strong>：小的输入变化 → 大的哈希变化</li>
</ol>
<p><strong>示例：字符串哈希</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 差：简单求和（许多碰撞）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bad_hash</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> s) % <span class="number">1000</span></span><br><span class="line"><span class="comment"># 问题：&quot;abc&quot; 和 &quot;cba&quot; 哈希到相同值！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 好：多项式滚动哈希</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">good_hash</span>(<span class="params">s</span>):</span><br><span class="line">    hash_val = <span class="number">0</span></span><br><span class="line">    prime = <span class="number">31</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        hash_val = (hash_val * prime + <span class="built_in">ord</span>(c)) % (<span class="number">2</span>**<span class="number">31</span>)</span><br><span class="line">    <span class="keyword">return</span> hash_val</span><br><span class="line"><span class="comment"># 更好的分布，更少的碰撞</span></span><br></pre></td></tr></table></figure>
<p><strong>常见陷阱</strong>：</p>
<p><strong>陷阱一：非均匀分布</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 差：所有键哈希到同一桶</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">terrible_hash</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 所有都碰撞！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 好：使用内置 hash() 或适当算法</span></span><br><span class="line">hash_val = <span class="built_in">hash</span>(key)</span><br></pre></td></tr></table></figure></p>
<p><strong>陷阱二：忽略键特征</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于整数：恒等哈希很好</span></span><br><span class="line"><span class="built_in">hash</span>(<span class="number">42</span>) == <span class="number">42</span>  <span class="comment"># 工作良好</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于字符串：需要考虑所有字符</span></span><br><span class="line"><span class="comment"># Python 的 hash() 使用 SipHash（密码学质量）</span></span><br></pre></td></tr></table></figure></p>
<p><strong>陷阱三：哈希函数太慢</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 差：每次哈希都进行昂贵计算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slow_hash</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">import</span> hashlib</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(hashlib.sha256(s.encode()).hexdigest(), <span class="number">16</span>)</span><br><span class="line"><span class="comment"># 对于频繁查找太慢！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 好：快速多项式哈希</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fast_hash</span>(<span class="params">s</span>):</span><br><span class="line">    h = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        h = h * <span class="number">31</span> + <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure></p>
<p><strong>哈希函数质量指标</strong>：</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>好</th>
<th>差</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>碰撞率</strong></td>
<td>低（随机键 &lt; 5%）</td>
<td>高（&gt; 20%）</td>
</tr>
<tr>
<td><strong>分布</strong></td>
<td>均匀分布到各桶</td>
<td>聚集</td>
</tr>
<tr>
<td><strong>速度</strong></td>
<td><span class="math inline">\(O(k)\)</span>，其中 <span class="math inline">\(k\)</span> 是键大小</td>
<td>慢于 <span class="math inline">\(O(k)\)</span></td>
</tr>
<tr>
<td><strong>雪崩</strong></td>
<td>小输入变化 → 大哈希变化</td>
<td>小变化 → 小哈希变化</td>
</tr>
</tbody>
</table>
<p><strong>面试提示</strong>：你很少实现哈希函数。Python 的
<code>hash()</code> 处理大多数情况。对于自定义对象，重写
<code>__hash__()</code> 和 <code>__eq__()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>((self.x, self.y))  <span class="comment"># 使用元组哈希</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.x == other.x <span class="keyword">and</span> self.y == other.y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在 Point 可以用作 dict 键</span></span><br><span class="line">points = &#123;Point(<span class="number">1</span>, <span class="number">2</span>): <span class="string">&quot;A&quot;</span>, Point(<span class="number">3</span>, <span class="number">4</span>): <span class="string">&quot;B&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="q5哈希表相比数组的内存开销是什么">Q5：哈希表相比数组的内存开销是什么？</h3>
<p><strong>答案</strong>：哈希表由于以下原因具有<strong>显著的内存开销</strong>：
1. 哈希表结构（桶、元数据） 2. 碰撞处理（链式指针或额外槽位） 3.
负载因子（通常 50-70% 满以维持性能） 4. 哈希函数存储（某些实现）</p>
<p><strong>内存分解</strong>：</p>
<p><strong>数组</strong>： - 仅存储数据：<span class="math inline">\(n
\times \text{sizeof(element)}\)</span> -
示例：<code>[1, 2, 3, 4, 5]</code> → 5 个整数 = 20 字节（假设 4
字节整数）</p>
<p><strong>哈希表（Python <code>dict</code>）</strong>： -
每个条目开销：约 24-48 字节（键、值、哈希、指针） - 负载因子：约
50-66%（表是条目的 1.5-2 倍大） -
示例：<code>&#123;1: "a", 2: "b", 3: "c"&#125;</code> → 约 200-300 字节（vs 数组的
12 字节）</p>
<p><strong>对比表</strong>：</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th><span class="math inline">\(n\)</span> 个整数的内存</th>
<th>开销因子</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数组</strong></td>
<td><span class="math inline">\(4n\)</span> 字节</td>
<td>1x（基准）</td>
</tr>
<tr>
<td><strong>哈希集合</strong></td>
<td>约 <span class="math inline">\(24n\)</span> 到 <span class="math inline">\(48n\)</span> 字节</td>
<td>6-12x</td>
</tr>
<tr>
<td><strong>哈希映射</strong></td>
<td>约 <span class="math inline">\(32n\)</span> 到 <span class="math inline">\(64n\)</span> 字节</td>
<td>8-16x</td>
</tr>
</tbody>
</table>
<p><strong>示例计算</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组：最小开销</span></span><br><span class="line">arr = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(arr))  <span class="comment"># ~8040 字节（1000 个整数 + 小开销）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合：显著开销</span></span><br><span class="line">s = <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">1000</span>))</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(s))    <span class="comment"># ~32968 字节（约 4 倍多！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典：甚至更多开销</span></span><br><span class="line">d = &#123;i: i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(d))    <span class="comment"># ~36968 字节（约 4.5 倍多！）</span></span><br></pre></td></tr></table></figure>
<p><strong>内存重要时</strong>：</p>
<p><strong>使用数组当</strong>： - 键是连续整数 [0..n-1] - 内存极度受限
- 需要可预测的内存使用</p>
<p><strong>使用哈希表当</strong>： - 键是稀疏的或非整数 - 内存开销可接受
- 快速查找关键</p>
<p><strong>空间优化技术</strong>：</p>
<ol type="1">
<li><p><strong>尽可能使用 <code>set</code> 而不是
<code>dict</code></strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 浪费</span></span><br><span class="line">seen = &#123;num: <span class="literal">True</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 高效</span></span><br><span class="line">seen = <span class="built_in">set</span>(nums)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>如果已知大小，预分配</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python dict 自动调整大小，但你可以提示</span></span><br><span class="line">d = <span class="built_in">dict</span>.fromkeys(<span class="built_in">range</span>(<span class="number">1000</span>))  <span class="comment"># 预分配大小</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>对于密集整数键，考虑基于数组的解决方案</strong>：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于键 [0..999]，数组更好</span></span><br><span class="line">arr = [<span class="number">0</span>] * <span class="number">1000</span>  <span class="comment"># 4000 字节</span></span><br><span class="line">d = &#123;i: <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)&#125;  <span class="comment"># ~37000 字节</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><strong>面试提示</strong>：总是提及时空权衡。哈希表用内存换取速度。如果内存受限，考虑使用排序数组
+ 二分查找（<span class="math inline">\(O(\log n)\)</span>
查找）或其他替代方案。</p>
<hr>
<h3 id="q6python-中-ordereddict-和普通-dict-的区别是什么">Q6：Python 中
<code>OrderedDict</code> 和普通 <code>dict</code> 的区别是什么？</h3>
<p><strong>答案</strong>：<code>OrderedDict</code>（Python
3.7+）维护<strong>插入顺序</strong>，而较旧的 <code>dict</code>
实现不保证顺序。在 Python 3.7+ 中，普通 <code>dict</code>
也维护插入顺序，但 <code>OrderedDict</code> 提供额外功能。</p>
<p><strong>历史背景</strong>：</p>
<ul>
<li><strong>Python &lt; 3.7</strong>：<code>dict</code>
具有<strong>任意顺序</strong>（实现细节）</li>
<li><strong>Python 3.7+</strong>：<code>dict</code>
维护<strong>插入顺序</strong>（语言保证）</li>
<li><strong><code>OrderedDict</code></strong>：即使在较旧的 Python
版本中也始终维护顺序</li>
</ul>
<p><strong>当前行为（Python 3.7+）</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通 dict：维护插入顺序</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line">d[<span class="string">&#x27;first&#x27;</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">&#x27;second&#x27;</span>] = <span class="number">2</span></span><br><span class="line">d[<span class="string">&#x27;third&#x27;</span>] = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(d.keys()))  <span class="comment"># [&#x27;first&#x27;, &#x27;second&#x27;, &#x27;third&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OrderedDict：也维护插入顺序</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line">od = OrderedDict()</span><br><span class="line">od[<span class="string">&#x27;first&#x27;</span>] = <span class="number">1</span></span><br><span class="line">od[<span class="string">&#x27;second&#x27;</span>] = <span class="number">2</span></span><br><span class="line">od[<span class="string">&#x27;third&#x27;</span>] = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(od.keys()))  <span class="comment"># [&#x27;first&#x27;, &#x27;second&#x27;, &#x27;third&#x27;]</span></span><br></pre></td></tr></table></figure>
<p><strong>何时使用 <code>OrderedDict</code></strong>：</p>
<p><strong>当你需要时使用 <code>OrderedDict</code></strong>：</p>
<ol type="1">
<li><p><strong>重新排序操作</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">od = OrderedDict([(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移到末尾</span></span><br><span class="line">od.move_to_end(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(od.keys()))  <span class="comment"># [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移到开头</span></span><br><span class="line">od.move_to_end(<span class="string">&#x27;a&#x27;</span>, last=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(od.keys()))  <span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>从特定端弹出</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 弹出最后一项（LIFO）</span></span><br><span class="line">last = od.popitem(last=<span class="literal">True</span>)  <span class="comment"># (&#x27;c&#x27;, 3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出第一项（FIFO）</span></span><br><span class="line">first = od.popitem(last=<span class="literal">False</span>)  <span class="comment"># (&#x27;a&#x27;, 1)</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>基于顺序的相等性</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OrderedDict 在相等性中考虑顺序</span></span><br><span class="line">od1 = OrderedDict([(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)])</span><br><span class="line">od2 = OrderedDict([(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>)])</span><br><span class="line"><span class="built_in">print</span>(od1 == od2)  <span class="comment"># False（不同顺序）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通 dict 不关心顺序（Python 3.7+）</span></span><br><span class="line">d1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">d2 = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d1 == d2)  <span class="comment"># True（相同项）</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><strong>性能对比</strong>：</p>
<table>
<colgroup>
<col style="width: 17%">
<col style="width: 22%">
<col style="width: 42%">
<col style="width: 17%">
</colgroup>
<thead>
<tr>
<th>操作</th>
<th><code>dict</code></th>
<th><code>OrderedDict</code></th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>插入</strong></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>相似</td>
</tr>
<tr>
<td><strong>查找</strong></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>相似</td>
</tr>
<tr>
<td><strong>内存</strong></td>
<td>更低</td>
<td>更高（约多 20%）</td>
<td><code>OrderedDict</code> 存储额外指针</td>
</tr>
<tr>
<td><strong>重新排序</strong></td>
<td>不支持</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><code>move_to_end()</code> 仅在 <code>OrderedDict</code> 中</td>
</tr>
</tbody>
</table>
<p><strong>常见用例</strong>：</p>
<ol type="1">
<li><p><strong>LRU 缓存</strong>（最近最少使用）：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity</span>):</span><br><span class="line">        self.cache = OrderedDict()</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 移到末尾（最近使用）</span></span><br><span class="line">        self.cache.move_to_end(key)</span><br><span class="line">        <span class="keyword">return</span> self.cache[key]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            self.cache.move_to_end(key)</span><br><span class="line">        self.cache[key] = value</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) &gt; self.capacity:</span><br><span class="line">            <span class="comment"># 删除最近最少使用（第一项）</span></span><br><span class="line">            self.cache.popitem(last=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>维护插入顺序</strong>（虽然 <code>dict</code>
现在也这样做）： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两者都有效，但 OrderedDict 更明确</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_items</span>(<span class="params">items</span>):</span><br><span class="line">    result = OrderedDict()  <span class="comment"># 明确意图：顺序重要</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        result[item.<span class="built_in">id</span>] = item.process()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><strong>面试提示</strong>：在 Python 3.7+ 中，普通 <code>dict</code>
通常足够。仅在需要 <code>move_to_end()</code> 或
<code>popitem(last=False)</code> 时使用
<code>OrderedDict</code>，或需要支持保证顺序的较旧 Python
版本时使用。</p>
<hr>
<h3 id="q7哈希表在多线程环境中的行为如何">Q7：哈希表在多线程环境中的行为如何？</h3>
<p><strong>答案</strong>：大多数哈希表实现默认<strong>不是线程安全的</strong>。并发修改可能导致数据损坏、无限循环或崩溃。使用同步原语或线程安全的替代方案。</p>
<p><strong>问题</strong>：</p>
<p><strong>竞态条件示例</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享哈希表</span></span><br><span class="line">counter = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> counter:</span><br><span class="line">        counter[key] = <span class="number">0</span></span><br><span class="line">    counter[key] += <span class="number">1</span>  <span class="comment"># 不是原子的！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个线程同时修改</span></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=increment, args=(<span class="string">&#x27;count&#x27;</span>,))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(counter[<span class="string">&#x27;count&#x27;</span>])  <span class="comment"># 可能不是 10！可能是 5, 7 等</span></span><br></pre></td></tr></table></figure></p>
<p><strong>可能出错的情况</strong>：</p>
<ol type="1">
<li><strong>丢失更新</strong>：两个线程读取，都递增，都写入 →
一个更新丢失</li>
<li><strong>不一致状态</strong>：并发访问期间哈希表调整大小 → 损坏</li>
<li><strong>无限循环</strong>：迭代时另一个线程修改 → 未定义行为</li>
</ol>
<p><strong>解决方案</strong>：</p>
<p><strong>选项一：锁（同步）</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">counter = &#123;&#125;</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="keyword">with</span> lock:  <span class="comment"># 获取锁</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> counter:</span><br><span class="line">            counter[key] = <span class="number">0</span></span><br><span class="line">        counter[key] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 自动释放锁</span></span><br></pre></td></tr></table></figure></p>
<p><strong>选项二：线程安全数据结构</strong>：</p>
<p><strong>Python</strong>：使用 <code>collections.Queue</code>
或外部库： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于简单情况，使用队列</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line">q = Queue()  <span class="comment"># 线程安全</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于类似 dict 的结构，使用线程安全包装器</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeDict</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._<span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">        self._lock = Lock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">with</span> self._lock:</span><br><span class="line">            <span class="keyword">return</span> self._<span class="built_in">dict</span>[key]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="keyword">with</span> self._lock:</span><br><span class="line">            self._<span class="built_in">dict</span>[key] = value</span><br></pre></td></tr></table></figure></p>
<p><strong>Java</strong>：使用 <code>ConcurrentHashMap</code>：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line">ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 线程安全操作</span></span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.get(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>C++</strong>：使用 <code>std::shared_mutex</code> 或外部库：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line">std::shared_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读锁（允许多个读者）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="type">int</span> value = map[<span class="string">&quot;key&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写锁（独占）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    map[<span class="string">&quot;key&quot;</span>] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>性能权衡</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>线程安全</th>
<th>性能</th>
<th>复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无同步</strong></td>
<td>❌ 不安全</td>
<td>⚡ 最快</td>
<td>✅ 简单</td>
</tr>
<tr>
<td><strong>粗粒度锁</strong></td>
<td>✅ 安全</td>
<td>🐌 慢（串行化）</td>
<td>✅ 简单</td>
</tr>
<tr>
<td><strong>细粒度锁</strong></td>
<td>✅ 安全</td>
<td>⚡ 更快（并行读取）</td>
<td>❌ 复杂</td>
</tr>
<tr>
<td><strong>无锁结构</strong></td>
<td>✅ 安全</td>
<td>⚡⚡ 最快</td>
<td>❌❌ 非常复杂</td>
</tr>
</tbody>
</table>
<p><strong>最佳实践</strong>：</p>
<ol type="1">
<li><p><strong>尽可能避免共享可变状态</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ✅ 好：每个线程有自己的 dict</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_chunk</span>(<span class="params">chunk</span>):</span><br><span class="line">    local_dict = &#123;&#125;  <span class="comment"># 线程本地</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> chunk:</span><br><span class="line">        local_dict[item] = process(item)</span><br><span class="line">    <span class="keyword">return</span> local_dict</span><br><span class="line"></span><br><span class="line"><span class="comment"># ❌ 差：共享 dict</span></span><br><span class="line">shared_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_chunk</span>(<span class="params">chunk</span>):</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> chunk:</span><br><span class="line">        shared_dict[item] = process(item)  <span class="comment"># 竞态条件！</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>使用不可变数据结构</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不修改共享 dict，而是返回新 dict</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_results</span>(<span class="params">results</span>):</span><br><span class="line">    <span class="comment"># 合并线程结果（无并发修改）</span></span><br><span class="line">    final = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        final.update(result)</span><br><span class="line">    <span class="keyword">return</span> final</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>只读访问通常是安全的</strong>（但验证实现）：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多个线程读取通常是安全的</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lookup</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="keyword">return</span> shared_dict.get(key)  <span class="comment"># 只读，通常安全</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><strong>面试提示</strong>：提及哈希表默认不是线程安全的。如果被问及并发访问，讨论锁、线程安全替代方案或架构解决方案（避免共享状态）。</p>
<hr>
<h3 id="q8解决哈希表问题后常见的面试后续问题有哪些">Q8：解决哈希表问题后常见的面试后续问题有哪些？</h3>
<p><strong>答案</strong>：面试官经常深入探讨你的理解。以下是常见的后续问题和处理方法：</p>
<p><strong>后续问题一："你能优化空间复杂度吗？"</strong></p>
<p><strong>示例</strong>：用 <span class="math inline">\(O(n)\)</span>
空间解决两数之和后： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始：O(n) 空间</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">nums, target</span>):</span><br><span class="line">    seen = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        complement = target - num</span><br><span class="line">        <span class="keyword">if</span> complement <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> [seen[complement], i]</span><br><span class="line">        seen[num] = i</span><br></pre></td></tr></table></figure></p>
<p><strong>优化</strong>：如果数组已排序，使用双指针（<span class="math inline">\(O(1)\)</span> 空间）： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化：O(1) 空间（但需要排序数组）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">twoSum_sorted</span>(<span class="params">nums, target</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        total = nums[left] + nums[right]</span><br><span class="line">        <span class="keyword">if</span> total == target:</span><br><span class="line">            <span class="keyword">return</span> [left, right]</span><br><span class="line">        <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>后续问题二："如果我们需要返回所有数对，而不是只有一个呢？"</strong></p>
<p><strong>示例</strong>：返回所有和为目标值的数对： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">twoSum_all_pairs</span>(<span class="params">nums, target</span>):</span><br><span class="line">    seen = &#123;&#125;</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        complement = target - num</span><br><span class="line">        <span class="keyword">if</span> complement <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="comment"># 添加所有之前的索引</span></span><br><span class="line">            <span class="keyword">for</span> prev_idx <span class="keyword">in</span> seen[complement]:</span><br><span class="line">                result.append([prev_idx, i])</span><br><span class="line">        <span class="comment"># 存储当前索引</span></span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen[num] = []</span><br><span class="line">        seen[num].append(i)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<p><strong>后续问题三："如果数组可以有重复值怎么办？"</strong></p>
<p><strong>答案</strong>：哈希表解法正确处理重复值（如两数之和问题所示）。解释你在插入<strong>之前</strong>检查以避免自配对。</p>
<p><strong>后续问题四："如何处理无法放入内存的非常大的数据集？"</strong></p>
<p><strong>答案</strong>：使用<strong>外部哈希</strong>或<strong>流式算法</strong>：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 流式方法：分块处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">twoSum_streaming</span>(<span class="params">stream, target</span>):</span><br><span class="line">    seen = &#123;&#125;</span><br><span class="line">    chunk_size = <span class="number">10000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> read_in_chunks(stream, chunk_size):</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(chunk):</span><br><span class="line">            complement = target - num</span><br><span class="line">            <span class="keyword">if</span> complement <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> [seen[complement], current_index]</span><br><span class="line">            seen[num] = current_index</span><br><span class="line">            current_index += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 可选：如果内存受限，驱逐旧条目</span></span><br></pre></td></tr></table></figure></p>
<p><strong>后续问题五："最坏情况时间复杂度是什么？"</strong></p>
<p><strong>答案</strong>：哈希表操作是 <span class="math inline">\(O(1)\)</span>
<strong>平均情况</strong>，但由于以下原因，最坏情况是 <span class="math inline">\(O(n)\)</span>： - 所有键哈希到同一桶（恶意输入） -
哈希表调整大小（摊销 <span class="math inline">\(O(1)\)</span>）</p>
<p><strong>后续问题六："你能在不使用额外空间的情况下解决这个问题吗？"</strong></p>
<p><strong>答案</strong>：有时可以（如果数组已排序或有约束）： -
<strong>排序数组</strong>：双指针（<span class="math inline">\(O(1)\)</span> 空间） -
<strong>有约束的数组</strong>：使用数组本身作为哈希表（缺失的第一个正数模式）
- <strong>否则</strong>：通常需要 <span class="math inline">\(O(n)\)</span> 空间来实现 <span class="math inline">\(O(n)\)</span> 时间</p>
<p><strong>后续问题七："你会如何测试这个解决方案？"</strong></p>
<p><strong>答案</strong>：覆盖这些情况： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test_cases = [</span><br><span class="line">    ([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], <span class="number">9</span>, [<span class="number">0</span>, <span class="number">1</span>]),           <span class="comment"># 正常情况</span></span><br><span class="line">    ([<span class="number">3</span>, <span class="number">3</span>], <span class="number">6</span>, [<span class="number">0</span>, <span class="number">1</span>]),                    <span class="comment"># 重复</span></span><br><span class="line">    ([<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>], <span class="number">6</span>, [<span class="number">1</span>, <span class="number">2</span>]),                 <span class="comment"># 不在开头</span></span><br><span class="line">    ([-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>], -<span class="number">8</span>, [<span class="number">2</span>, <span class="number">4</span>]),    <span class="comment"># 负数</span></span><br><span class="line">    ([<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, [<span class="number">0</span>, <span class="number">1</span>]),                    <span class="comment"># 边界：两个元素</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p><strong>后续问题八："如果我们需要找到三个数之和为目标值怎么办？"</strong></p>
<p><strong>答案</strong>：扩展模式： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">nums, target</span>):</span><br><span class="line">    nums.sort()  <span class="comment"># O(n log n)</span></span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span>  <span class="comment"># 跳过重复</span></span><br><span class="line">        </span><br><span class="line">        left, right = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            total = nums[i] + nums[left] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> total == target:</span><br><span class="line">                result.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                <span class="comment"># 跳过重复</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right-<span class="number">1</span>]:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<p><strong>面试策略</strong>： 1.
<strong>承认权衡</strong>："哈希表解法使用 <span class="math inline">\(O(n)\)</span> 空间换取 <span class="math inline">\(O(n)\)</span> 时间。如果空间受限..." 2.
<strong>展示替代方案</strong>："我们可以使用排序 + 双指针实现 <span class="math inline">\(O(1)\)</span> 空间但 <span class="math inline">\(O(n \log n)\)</span> 时间。" 3.
<strong>询问澄清问题</strong>："我们优化时间还是空间？数组是否已排序？"</p>
<hr>
<h3 id="q9哈希表时间复杂度分析中的边界情况有哪些">Q9：哈希表时间复杂度分析中的边界情况有哪些？</h3>
<p><strong>答案</strong>：哈希表操作是<strong>摊销 <span class="math inline">\(O(1)\)</span></strong>，但有几个因素可能影响实际性能：</p>
<p><strong>边界情况一：哈希碰撞（最坏情况 <span class="math inline">\(O(n)\)</span>）</strong></p>
<p><strong>场景</strong>：所有键哈希到同一桶： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恶意输入：所有键碰撞</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BadHash</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>  <span class="comment"># 总是相同哈希！</span></span><br><span class="line"></span><br><span class="line">bad_keys = [BadHash() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line">d = &#123;key: i <span class="keyword">for</span> i, key <span class="keyword">in</span> <span class="built_in">enumerate</span>(bad_keys)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找变为 O(n) - 通过链线性搜索</span></span><br><span class="line">value = d[bad_keys[<span class="number">500</span>]]  <span class="comment"># O(n) 最坏情况！</span></span><br></pre></td></tr></table></figure></p>
<p><strong>缓解</strong>：好的哈希函数 + 负载因子管理</p>
<p><strong>边界情况二：哈希表调整大小（摊销分析）</strong></p>
<p><strong>场景</strong>：当负载因子超过阈值时，表大小加倍：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入 n 个元素</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">    d[i] = i  <span class="comment"># 在 ~66k, ~133k, ~266k 等触发调整大小</span></span><br></pre></td></tr></table></figure></p>
<p><strong>成本分析</strong>： - <strong>单个插入</strong>：通常是 <span class="math inline">\(O(1)\)</span>，但调整大小时是 <span class="math inline">\(O(n)\)</span> -
<strong>摊销成本</strong>：每次插入 <span class="math inline">\(O(1)\)</span>（调整大小很少发生）</p>
<p><strong>证明概要</strong>：如果表在满时加倍，<span class="math inline">\(n\)</span> 次插入的总成本： - 插入：<span class="math inline">\(n\)</span> 次操作 - 调整大小：<span class="math inline">\(\log n\)</span> 次，每次成本 <span class="math inline">\(O(n)\)</span> - 总计：<span class="math inline">\(O(n + n \log n) = O(n \log n)\)</span> -
摊销：<span class="math inline">\(O(n \log n) / n = O(\log
n)\)</span>... 等等，这不对！</p>
<p><strong>正确分析</strong>： - 在大小 <span class="math inline">\(m,
2m, 4m, 8m, \dots\)</span> 时调整大小 - 在大小 <span class="math inline">\(k\)</span> 时调整大小的成本：<span class="math inline">\(O(k)\)</span>（重新哈希所有条目） -
总调整大小成本：<span class="math inline">\(m + 2m + 4m + \dots + n =
O(n)\)</span> - 摊销：<span class="math inline">\(O(n) / n =
O(1)\)</span> ✅</p>
<p><strong>边界情况三：迭代复杂度</strong></p>
<p><strong>场景</strong>：遍历哈希表： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;i: i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代：O(n) 时间，O(n) 空间用于键/项</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:  <span class="comment"># O(n)</span></span><br><span class="line">    <span class="built_in">print</span>(key, d[key])</span><br></pre></td></tr></table></figure></p>
<p><strong>复杂度</strong>：<span class="math inline">\(O(n)\)</span>
时间，<span class="math inline">\(O(n)\)</span> 空间（存储迭代状态）</p>
<p><strong>边界情况四：字符串键（哈希计算成本）</strong></p>
<p><strong>场景</strong>：长字符串作为键： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哈希计算：O(k)，其中 k 是字符串长度</span></span><br><span class="line">long_strings = [<span class="string">&quot;a&quot;</span> * <span class="number">10000</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line">d = &#123;s: i <span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(long_strings)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找：O(1) + O(k) = O(k)，其中 k 是键长度</span></span><br><span class="line">value = d[long_strings[<span class="number">500</span>]]  <span class="comment"># O(10000) 计算哈希！</span></span><br></pre></td></tr></table></figure></p>
<p><strong>复杂度</strong>：<span class="math inline">\(O(k)\)</span>，其中 <span class="math inline">\(k\)</span> 是键长度（如果键很大，不是 <span class="math inline">\(O(1)\)</span>）</p>
<p><strong>边界情况五：自定义哈希函数</strong></p>
<p><strong>场景</strong>：昂贵的哈希计算： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">expensive_hash</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="comment"># 密码学哈希：慢！</span></span><br><span class="line">    <span class="keyword">import</span> hashlib</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(hashlib.sha256(<span class="built_in">str</span>(obj).encode()).hexdigest(), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpensiveKey</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> expensive_hash(self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次查找都计算昂贵哈希</span></span><br><span class="line">d = &#123;ExpensiveKey(): i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)&#125;</span><br><span class="line">value = d[key]  <span class="comment"># 由于哈希计算而慢</span></span><br></pre></td></tr></table></figure></p>
<p><strong>缓解</strong>：缓存哈希值或使用更快的哈希函数</p>
<p><strong>复杂度总结表</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>平均</th>
<th>最坏情况</th>
<th>摊销</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>插入</strong></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>最坏：所有碰撞</td>
</tr>
<tr>
<td><strong>查找</strong></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>N/A</td>
<td>最坏：所有碰撞</td>
</tr>
<tr>
<td><strong>删除</strong></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>N/A</td>
<td>最坏：所有碰撞</td>
</tr>
<tr>
<td><strong>迭代</strong></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>N/A</td>
<td>总是线性</td>
</tr>
<tr>
<td><strong>调整大小</strong></td>
<td>N/A</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span> 每次插入</td>
<td>摊销分析</td>
</tr>
</tbody>
</table>
<p><strong>面试提示</strong>：总是提及"平均情况 <span class="math inline">\(O(1)\)</span>"并承认最坏情况 <span class="math inline">\(O(n)\)</span>。解释最坏情况在使用好的哈希函数和适当的负载因子管理时很少发生。</p>
<hr>
<h3 id="q10哈希表问题的空间优化技术有哪些">Q10：哈希表问题的空间优化技术有哪些？</h3>
<p><strong>答案</strong>：几种技术可以在保持性能的同时减少内存使用：</p>
<p><strong>技术一：使用数组作为哈希表（当键是密集整数时）</strong></p>
<p><strong>场景</strong>：键是已知范围内的整数 [0..n-1]：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 浪费：O(n) 额外空间用于哈希表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_duplicate_dict</span>(<span class="params">nums</span>):</span><br><span class="line">    seen = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        seen[num] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 高效：使用数组作为哈希表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_duplicate_array</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 数组索引充当哈希键</span></span><br><span class="line">    seen = [<span class="literal">False</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> seen[num]:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        seen[num] = <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<p><strong>空间节省</strong>：数组使用 <span class="math inline">\(O(n)\)</span> vs 哈希表的 <span class="math inline">\(O(n)\)</span>，但常数因子更低（约 4
倍更少内存）</p>
<p><strong>技术二：布尔标志的位操作</strong></p>
<p><strong>场景</strong>：跟踪存在/不存在（布尔值）： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 浪费：dict 存储完整整数</span></span><br><span class="line">seen = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    seen[num] = <span class="literal">True</span>  <span class="comment"># 存储键 + 值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 高效：使用 set（仅键）</span></span><br><span class="line">seen = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">if</span> num <span class="keyword">in</span> seen:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    seen.add(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅✅ 最高效：位向量（如果范围小）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">has_duplicate_bitvector</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 假设 nums 在范围 [1..32] 内</span></span><br><span class="line">    bits = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        bit = <span class="number">1</span> &lt;&lt; num</span><br><span class="line">        <span class="keyword">if</span> bits &amp; bit:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        bits |= bit</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p><strong>空间对比</strong>： - <code>dict</code>：约每条目 48 字节 -
<code>set</code>：约每条目 24 字节 - <code>位向量</code>：每条目 1
位（32 条目 = 4 字节！）</p>
<p><strong>技术三：原地修改（使用输入数组作为哈希表）</strong></p>
<p><strong>场景</strong>：缺失的第一个正数（LeetCode 41）：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 问题：找到最小的缺失正整数</span></span><br><span class="line"><span class="comment"># 约束：O(1) 额外空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">firstMissingPositive</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤 1：将负数/零替换为 n+1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= <span class="number">0</span>:</span><br><span class="line">            nums[i] = n + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤 2：使用数组索引作为哈希键</span></span><br><span class="line">    <span class="comment"># 通过使值为负来标记存在</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        num = <span class="built_in">abs</span>(nums[i])</span><br><span class="line">        <span class="keyword">if</span> num &lt;= n:</span><br><span class="line">            nums[num - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[num - <span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤 3：找到第一个正索引</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>关键洞察</strong>：使用数组索引 [0..n-1] 表示数字
[1..n]。通过使值为负来标记存在。</p>
<p><strong>技术四：单次遍历的滑动窗口</strong></p>
<p><strong>场景</strong>：无重复字符的最长子串： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 浪费：存储所有已见字符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring_bad</span>(<span class="params">s</span>):</span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        seen = <span class="built_in">set</span>()  <span class="comment"># 每个起始位置的新集合</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[j] <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            seen.add(s[j])</span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, <span class="built_in">len</span>(seen))</span><br><span class="line">    <span class="keyword">return</span> max_len</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 高效：滑动窗口，重用哈希表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring_good</span>(<span class="params">s</span>):</span><br><span class="line">    char_index = &#123;&#125;  <span class="comment"># 跨窗口重用</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[right] <span class="keyword">in</span> char_index:</span><br><span class="line">            <span class="comment"># 将左指针移到上次出现之后</span></span><br><span class="line">            left = <span class="built_in">max</span>(left, char_index[s[right]] + <span class="number">1</span>)</span><br><span class="line">        char_index[s[right]] = right</span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure></p>
<p><strong>空间节省</strong>：<span class="math inline">\(O(n)\)</span>
空间重用 vs <span class="math inline">\(O(n^2)\)</span> 总空间</p>
<p><strong>技术五：使用数组而不是 dict 进行频率统计</strong></p>
<p><strong>场景</strong>：统计字符（有限字母表）： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 通用但对小字母表浪费</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">freq = Counter(s)  <span class="comment"># Dict 开销</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 对小写英文字母（26 个字母）高效</span></span><br><span class="line">freq = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">    freq[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>空间对比</strong>： - <code>Counter</code>（dict）：约 26 ×
48 字节 = 约 1248 字节 - 数组：26 × 4 字节 = 104 字节（约 12
倍更少！）</p>
<p><strong>技术六：两次遍历而不是存储所有数据</strong></p>
<p><strong>场景</strong>：找到第一个唯一字符： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 存储所有索引</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">firstUniqChar_bad</span>(<span class="params">s</span>):</span><br><span class="line">    char_indices = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> char_indices:</span><br><span class="line">            char_indices[c] = []</span><br><span class="line">        char_indices[c].append(i)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> c, indices <span class="keyword">in</span> char_indices.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(indices) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> indices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 两次遍历：先计数，然后查找</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">firstUniqChar_good</span>(<span class="params">s</span>):</span><br><span class="line">    freq = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        freq[c] = freq.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> freq[c] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>空间节省</strong>：存储计数（整数）而不是索引列表</p>
<p><strong>总结表</strong>：</p>
<table>
<thead>
<tr>
<th>技术</th>
<th>何时使用</th>
<th>空间节省</th>
<th>权衡</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数组作为哈希</strong></td>
<td>密集整数键 [0..n-1]</td>
<td>4-8 倍更少</td>
<td>需要已知范围</td>
</tr>
<tr>
<td><strong>位向量</strong></td>
<td>布尔标志，小范围</td>
<td>8-32 倍更少</td>
<td>限于小范围</td>
</tr>
<tr>
<td><strong>原地修改</strong></td>
<td>可以修改输入数组</td>
<td><span class="math inline">\(O(1)\)</span> 额外空间</td>
<td>破坏输入</td>
</tr>
<tr>
<td><strong>滑动窗口</strong></td>
<td>子串/子数组问题</td>
<td>重用 vs 重新创建</td>
<td>更复杂的逻辑</td>
</tr>
<tr>
<td><strong>数组 vs dict</strong></td>
<td>小、固定字母表</td>
<td>10-20 倍更少</td>
<td>灵活性较低</td>
</tr>
<tr>
<td><strong>两次遍历</strong></td>
<td>可以避免存储索引</td>
<td>存储计数 vs 列表</td>
<td>额外遍历</td>
</tr>
</tbody>
</table>
<p><strong>面试提示</strong>：总是考虑是否可以使用输入数组本身作为哈希表，特别是当问题要求
<span class="math inline">\(O(1)\)</span> 额外空间时。这是 LeetCode
"困难"问题中的常见模式。</p>
<hr>
<p>哈希表不是魔法——它们是<strong>战略性的内存分配</strong>。掌握模式，你将解锁数十个
<span class="math inline">\(O(n)\)</span> 解决方案！</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>本文标题：LeetCode（一）—— 哈希表</li>
        <li>本文作者：Chen Kai</li>
        <li>创建时间：2022-05-20 00:00:00</li>
        <li>
            本文链接：https://www.chenk.top/LeetCode%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E5%93%88%E5%B8%8C%E8%A1%A8/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/LAMP-%E4%B8%8E%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LAMP 与阿里云服务器详解</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/HCGR-%E2%80%94%E2%80%94-Hyperbolic-Contrastive-Graph-Representation-Learning-for-Session-based-Recommendation/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">HCGR —— Hyperbolic Contrastive Graph Representation Learning for Session-based Recommendation</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情赞美帅气伟大的ck吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- 由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E5%88%97%E5%AF%BC%E8%88%AA"><span class="nav-number">1.</span> <span class="nav-text">系列导航</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE"><span class="nav-number">2.</span> <span class="nav-text">哈希表基础回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">什么是哈希表？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.</span> <span class="nav-text">不同语言中的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">3.</span> <span class="nav-text">问题一：两数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95%E7%94%A8%E4%BA%8E%E5%AF%B9%E6%AF%94"><span class="nav-number">3.2.</span> <span class="nav-text">暴力解法（用于对比）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E8%A7%A3%E6%B3%95%E4%BA%92%E8%A1%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">哈希表解法：互补模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#python-%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.1.</span> <span class="nav-text">Python 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.2.</span> <span class="nav-text">Java 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%A0%B7%E5%8F%AF%E8%A1%8C"><span class="nav-number">3.3.3.</span> <span class="nav-text">为什么这样可行？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">3.4.</span> <span class="nav-text">复杂度分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%E4%B8%8E%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5"><span class="nav-number">3.5.</span> <span class="nav-text">常见陷阱与边界情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%B8%80%E9%87%8D%E5%A4%8D%E5%80%BC%E5%A4%84%E7%90%86"><span class="nav-number">3.5.1.</span> <span class="nav-text">陷阱一：重复值处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%BA%8C%E5%AF%B9%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E5%85%83%E7%B4%A0%E4%B8%A4%E6%AC%A1%E7%9A%84%E8%AF%AF%E8%A7%A3"><span class="nav-number">3.5.2.</span> <span class="nav-text">陷阱二：对&quot;不能使用同一元素两次&quot;的误解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%B8%89%E4%B8%8D%E8%A6%81%E6%8E%92%E5%BA%8F"><span class="nav-number">3.5.3.</span> <span class="nav-text">陷阱三：不要排序！</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E5%9B%9B%E8%BF%94%E5%9B%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%B7%AE%E4%B8%80%E9%94%99%E8%AF%AF"><span class="nav-number">3.5.4.</span> <span class="nav-text">陷阱四：返回顺序的差一错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%B1%BB%E6%AF%94"><span class="nav-number">3.6.</span> <span class="nav-text">实际应用类比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="nav-number">4.</span> <span class="nav-text">问题二：最长连续序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="nav-number">4.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">4.2.</span> <span class="nav-text">为什么不直接排序？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88%E8%A7%A3%E6%B3%95%E4%BB%8E%E5%BA%8F%E5%88%97%E8%B5%B7%E7%82%B9%E5%BC%80%E5%A7%8B"><span class="nav-number">4.3.</span> <span class="nav-text">哈希集合解法：从序列起点开始</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.3.1.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python-%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">Python 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%98%AF-on"><span class="nav-number">4.3.3.</span> <span class="nav-text">为什么这是 \(O(n)\)？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="nav-number">4.4.</span> <span class="nav-text">复杂度分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E9%80%90%E6%AD%A5%E8%A7%A3%E6%9E%90"><span class="nav-number">4.5.</span> <span class="nav-text">示例逐步解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5"><span class="nav-number">4.6.</span> <span class="nav-text">常见边界情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5%E4%B8%80%E7%A9%BA%E6%95%B0%E7%BB%84"><span class="nav-number">4.6.1.</span> <span class="nav-text">边界情况一：空数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5%E4%BA%8C%E5%85%A8%E9%83%A8%E9%87%8D%E5%A4%8D"><span class="nav-number">4.6.2.</span> <span class="nav-text">边界情况二：全部重复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5%E4%B8%89%E6%97%A0%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97"><span class="nav-number">4.6.3.</span> <span class="nav-text">边界情况三：无连续数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5%E5%9B%9B%E6%95%B4%E4%B8%AA%E6%95%B0%E7%BB%84%E8%BF%9E%E7%BB%AD"><span class="nav-number">4.6.4.</span> <span class="nav-text">边界情况四：整个数组连续</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5%E4%BA%94%E8%B4%9F%E6%95%B0"><span class="nav-number">4.6.5.</span> <span class="nav-text">边界情况五：负数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-number">4.7.</span> <span class="nav-text">实际应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">问题三：字母异位词分组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2"><span class="nav-number">5.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%B4%9E%E5%AF%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E7%9A%84%E5%93%88%E5%B8%8C%E9%94%AE"><span class="nav-number">5.2.</span> <span class="nav-text">关键洞察：什么是好的哈希键？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%8E%92%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E9%94%AE"><span class="nav-number">5.2.1.</span> <span class="nav-text">方法一：排序字符串作为键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%AD%97%E7%AC%A6%E8%AE%A1%E6%95%B0%E4%BD%9C%E4%B8%BA%E9%94%AE%E6%9B%B4%E5%BF%AB"><span class="nav-number">5.2.2.</span> <span class="nav-text">方法二：字符计数作为键（更快！）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E9%94%AE%E5%B0%8F%E5%86%99%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E6%9C%80%E4%BD%B3"><span class="nav-number">5.2.3.</span> <span class="nav-text">方法三：固定大小数组作为键（小写英文字母最佳）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94"><span class="nav-number">5.3.</span> <span class="nav-text">复杂度对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E9%80%90%E6%AD%A5%E8%A7%A3%E6%9E%90-1"><span class="nav-number">5.4.</span> <span class="nav-text">示例逐步解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5"><span class="nav-number">5.5.</span> <span class="nav-text">边界情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5%E4%B8%80%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.5.1.</span> <span class="nav-text">边界情况一：空字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5%E4%BA%8C%E5%8D%95%E5%AD%97%E7%AC%A6"><span class="nav-number">5.5.2.</span> <span class="nav-text">边界情况二：单字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5%E4%B8%89%E6%97%A0%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">5.5.3.</span> <span class="nav-text">边界情况三：无字母异位词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5%E5%9B%9B%E5%85%A8%E9%83%A8%E6%98%AF%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">5.5.4.</span> <span class="nav-text">边界情况四：全部是字母异位词</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-1"><span class="nav-number">5.6.</span> <span class="nav-text">实际应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%93%88%E5%B8%8C%E8%A1%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">高级哈希表模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%80%E4%BA%92%E8%A1%A5%E6%90%9C%E7%B4%A2%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E5%8F%98%E4%BD%93"><span class="nav-number">6.1.</span> <span class="nav-text">模式一：互补搜索（两数之和变体）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E4%BA%8C%E9%A2%91%E7%8E%87%E7%BB%9F%E8%AE%A1"><span class="nav-number">6.2.</span> <span class="nav-text">模式二：频率统计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%89%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84"><span class="nav-number">6.3.</span> <span class="nav-text">模式三：滑动窗口 + 哈希映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%9B%9B%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84"><span class="nav-number">6.4.</span> <span class="nav-text">模式四：前缀和与哈希映射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86"><span class="nav-number">7.</span> <span class="nav-text">哈希表内部机制（进阶知识）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#python-dict-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">7.1.</span> <span class="nav-text">Python dict 的工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A2%B0%E6%92%9E%E8%A7%A3%E5%86%B3"><span class="nav-number">7.2.</span> <span class="nav-text">碰撞解决</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80python"><span class="nav-number">7.2.1.</span> <span class="nav-text">开放寻址（Python）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E6%B3%95java-hashmap"><span class="nav-number">7.2.2.</span> <span class="nav-text">链式法（Java HashMap）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E8%B4%A8%E9%87%8F"><span class="nav-number">7.3.</span> <span class="nav-text">哈希函数质量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95%E6%B8%85%E5%8D%95"><span class="nav-number">8.</span> <span class="nav-text">常见错误与调试清单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%80%E6%8F%92%E5%85%A5%E5%89%8D%E5%BF%98%E8%AE%B0%E6%A3%80%E6%9F%A5"><span class="nav-number">8.1.</span> <span class="nav-text">错误一：插入前忘记检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BA%8C%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%8F%AF%E5%93%88%E5%B8%8C%E7%9A%84%E9%94%AE"><span class="nav-number">8.2.</span> <span class="nav-text">错误二：使用不可哈希的键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%89%E4%BF%AE%E6%94%B9%E5%93%88%E5%B8%8C%E9%94%AE"><span class="nav-number">8.3.</span> <span class="nav-text">错误三：修改哈希键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%9B%9B%E7%B4%A2%E5%BC%95%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%B7%AE%E4%B8%80%E9%94%99%E8%AF%AF"><span class="nav-number">8.4.</span> <span class="nav-text">错误四：索引计算中的差一错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E6%B8%85%E5%8D%95"><span class="nav-number">8.5.</span> <span class="nav-text">调试清单</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">9.</span> <span class="nav-text">面试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7%E4%B8%80%E8%A1%A8%E8%BE%BE%E4%BD%A0%E7%9A%84%E6%80%9D%E8%80%83%E8%BF%87%E7%A8%8B"><span class="nav-number">9.1.</span> <span class="nav-text">技巧一：表达你的思考过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7%E4%BA%8C%E4%BB%8E%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95%E5%BC%80%E5%A7%8B"><span class="nav-number">9.2.</span> <span class="nav-text">技巧二：从暴力解法开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7%E4%B8%89%E6%BE%84%E6%B8%85%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"><span class="nav-number">9.3.</span> <span class="nav-text">技巧三：澄清约束条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7%E5%9B%9B%E5%88%86%E6%9E%90%E6%9D%83%E8%A1%A1"><span class="nav-number">9.4.</span> <span class="nav-text">技巧四：分析权衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7%E4%BA%94%E5%A4%A7%E5%A3%B0%E5%A4%84%E7%90%86%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5"><span class="nav-number">9.5.</span> <span class="nav-text">技巧五：大声处理边界情况</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E8%8A%82%E7%9C%81%E6%8A%80%E5%B7%A7"><span class="nav-number">10.</span> <span class="nav-text">时间节省技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7%E4%B8%80%E4%BD%BF%E7%94%A8-collections.counter"><span class="nav-number">10.1.</span> <span class="nav-text">技巧一：使用
collections.Counter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7%E4%BA%8C%E4%BD%BF%E7%94%A8-collections.defaultdict"><span class="nav-number">10.2.</span> <span class="nav-text">技巧二：使用
collections.defaultdict</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7%E4%B8%89%E4%BD%BF%E7%94%A8-enumerate-%E8%8E%B7%E5%8F%96%E7%B4%A2%E5%BC%95%E5%80%BC"><span class="nav-number">10.3.</span> <span class="nav-text">技巧三：使用
enumerate 获取索引+值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E5%93%88%E5%B8%8C%E8%A1%A8-vs-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-number">11.</span> <span class="nav-text">性能对比：哈希表 vs 替代方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98%E7%9B%AE10-%E9%81%93%E6%8E%A8%E8%8D%90"><span class="nav-number">12.</span> <span class="nav-text">练习题目（10 道推荐）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95"><span class="nav-number">12.1.</span> <span class="nav-text">简单</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E7%AD%89"><span class="nav-number">12.2.</span> <span class="nav-text">中等</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%B0%E9%9A%BE"><span class="nav-number">12.3.</span> <span class="nav-text">困难</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E9%A1%B5%E7%BA%B8%E6%8E%8C%E6%8F%A1%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">13.</span> <span class="nav-text">总结：一页纸掌握哈希表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E6%AD%A5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">14.</span> <span class="nav-text">下一步是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#qa%E5%93%88%E5%B8%8C%E8%A1%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">14.1.</span> <span class="nav-text">❓ Q&amp;A：哈希表常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#q1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E8%80%8C%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E6%9F%A5%E6%89%BE"><span class="nav-number">14.1.1.</span> <span class="nav-text">Q1：什么时候应该使用哈希表而不是数组进行查找？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q2%E4%B8%8D%E5%90%8C%E7%9A%84%E7%A2%B0%E6%92%9E%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%AF%8F%E7%A7%8D"><span class="nav-number">14.1.2.</span> <span class="nav-text">Q2：不同的碰撞处理策略有哪些，什么时候应该使用每种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q3%E5%9C%A8-python-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8-dict-vs-set"><span class="nav-number">14.1.3.</span> <span class="nav-text">Q3：在 Python
中什么时候应该使用 dict vs set？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q4%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%B7%E9%98%B1%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">14.1.4.</span> <span class="nav-text">Q4：什么是好的哈希函数，常见的陷阱是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q5%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9B%B8%E6%AF%94%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%80%E9%94%80%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">14.1.5.</span> <span class="nav-text">Q5：哈希表相比数组的内存开销是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q6python-%E4%B8%AD-ordereddict-%E5%92%8C%E6%99%AE%E9%80%9A-dict-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">14.1.6.</span> <span class="nav-text">Q6：Python 中
OrderedDict 和普通 dict 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q7%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%A6%82%E4%BD%95"><span class="nav-number">14.1.7.</span> <span class="nav-text">Q7：哈希表在多线程环境中的行为如何？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q8%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E8%A1%A8%E9%97%AE%E9%A2%98%E5%90%8E%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E5%90%8E%E7%BB%AD%E9%97%AE%E9%A2%98%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">14.1.8.</span> <span class="nav-text">Q8：解决哈希表问题后常见的面试后续问题有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q9%E5%93%88%E5%B8%8C%E8%A1%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E4%B8%AD%E7%9A%84%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">14.1.9.</span> <span class="nav-text">Q9：哈希表时间复杂度分析中的边界情况有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q10%E5%93%88%E5%B8%8C%E8%A1%A8%E9%97%AE%E9%A2%98%E7%9A%84%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">14.1.10.</span> <span class="nav-text">Q10：哈希表问题的空间优化技术有哪些？</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
