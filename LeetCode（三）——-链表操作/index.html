<!DOCTYPE html>



<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode（三）—— 链表操作 |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"zh-CN","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode（三）—— 链表操作</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-05-20 00:00:00</span>
        <span class="mobile">2022-05-20 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>8.1k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>32 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>链表是技术面试的基石，测试你操作指针、处理边界情况和优化空间使用的能力。与数组不同，链表提供
<span class="math inline">\(O(1)\)</span> 的插入和删除，但需要 <span class="math inline">\(O(n)\)</span>
进行访问。它们自然支持动态增长，但缺乏随机访问能力。本综合指南通过五个经典问题——<strong>反转链表</strong>（迭代和递归）、<strong>合并两个有序链表</strong>、<strong>检测环入口点</strong>、<strong>找到相交节点</strong>和<strong>删除倒数第
n
个节点</strong>——构建完整的链表掌握工具包。我们将深入探讨迭代与递归之间的权衡、虚拟节点的威力，以及如何在
<span class="math inline">\(O(1)\)</span> 空间中解决复杂操作。</p>
<span id="more"></span>
<h1 id="系列导航">系列导航</h1>
<p>📚 <strong>LeetCode 算法精讲系列</strong>（共 10 篇）： 1.
哈希表完全指南 2. 双指针技巧 3. <strong>→
链表操作</strong>（反转、环检测、合并、相交、删除）← <em>当前文章</em>
4. 二叉树遍历与递归 5. 动态规划基础 6. 回溯算法 7. 二分查找进阶 8.
栈与队列 9. 图算法 10. 贪心与位运算</p>
<hr>
<h1 id="链表基础回顾">链表基础回顾</h1>
<h2 id="链表-vs-数组">链表 vs 数组</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>访问</strong></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr>
<td><strong>插入/删除（已知位置）</strong></td>
<td><span class="math inline">\(O(n)\)</span>（需要移位）</td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr>
<td><strong>内存</strong></td>
<td>连续</td>
<td>非连续</td>
</tr>
<tr>
<td><strong>缓存局部性</strong></td>
<td>✅ 高</td>
<td>❌ 低</td>
</tr>
<tr>
<td><strong>动态增长</strong></td>
<td>⚠️ 需要重新分配</td>
<td>✅ 自然支持</td>
</tr>
</tbody>
</table>
<h2 id="链表节点定义">链表节点定义</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h2 id="链表的思维模型">链表的思维模型</h2>
<p>将链表想象成一列<strong>火车</strong>： -
<strong>节点</strong>：每节车厢 -
<strong>指针</strong>：连接车厢的耦合器 - <strong>头节点</strong>：机车
- <strong>尾节点</strong>：最后一节车厢（<code>next = None</code>）</p>
<p><strong>操作直觉</strong>： - <strong>反转</strong>：让火车倒着运行 -
<strong>合并</strong>：按顺序合并两列火车 -
<strong>检测环</strong>：检查火车是否形成环路 -
<strong>删除节点</strong>：移除一节车厢并重新连接其余部分</p>
<hr>
<h1 id="问题一反转链表">问题一：反转链表</h1>
<h2 id="问题描述">问题描述</h2>
<p>给你单链表的头节点
<code>head</code>，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例</strong>： - 输入：<code>head = [1,2,3,4,5]</code> -
输出：<code>[5,4,3,2,1]</code></p>
<p><strong>约束条件</strong>： - 链表中节点的数目范围是 <span class="math inline">\([0, 5000]\)</span> - <span class="math inline">\(-5000 \leq \texttt{Node.val} \leq
5000\)</span></p>
<p><strong>进阶</strong>：你可以用迭代或递归两种方法解决这个问题吗？</p>
<h2 id="方法一迭代三指针技术">方法一：迭代（三指针技术）</h2>
<h3 id="核心思想">核心思想</h3>
<p>维护三个指针： - <code>prev</code>：前一个节点 -
<code>curr</code>：当前节点 -
<code>next_node</code>：下一个节点（临时存储）</p>
<p><strong>步骤</strong>： 1. 初始化
<code>prev = None</code>，<code>curr = head</code> 2.
遍历链表，每次迭代： - 将 <code>curr.next</code> 保存到
<code>next_node</code> - 反转指针：<code>curr.next = prev</code> -
移动指针：<code>prev = curr</code>，<code>curr = next_node</code> 3.
返回 <code>prev</code>（新头节点）</p>
<h3 id="python-实现">Python 实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用三指针迭代反转链表。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    时间复杂度：O(n) - 单次遍历链表</span></span><br><span class="line"><span class="string">    空间复杂度：O(1) - 仅使用常数额外空间</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    prev = <span class="literal">None</span></span><br><span class="line">    curr = head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        <span class="comment"># 在丢失引用之前保存下一个节点</span></span><br><span class="line">        next_node = curr.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 反转指针：将当前节点指向前一个</span></span><br><span class="line">        curr.<span class="built_in">next</span> = prev</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 向前移动两个指针</span></span><br><span class="line">        prev = curr</span><br><span class="line">        curr = next_node</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># prev 现在指向新头节点（原本是尾节点）</span></span><br><span class="line">    <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，单次遍历</li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span>，仅使用常数额外指针</li>
</ul>
<h3 id="逐步解析">逐步解析</h3>
<p><strong>输入</strong>：<code>1 → 2 → 3 → None</code></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th><code>prev</code></th>
<th><code>curr</code></th>
<th><code>next_node</code></th>
<th>操作</th>
<th>链表状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td><code>None</code></td>
<td><code>1</code></td>
<td>-</td>
<td>-</td>
<td><code>1 → 2 → 3 → None</code></td>
</tr>
<tr>
<td>1</td>
<td><code>None</code></td>
<td><code>1</code></td>
<td><code>2</code></td>
<td>保存 <code>2</code></td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td><code>None</code></td>
<td><code>1</code></td>
<td><code>2</code></td>
<td><code>1.next = None</code></td>
<td><code>None ← 1</code> <code>2 → 3 → None</code></td>
</tr>
<tr>
<td>1</td>
<td><code>1</code></td>
<td><code>2</code></td>
<td><code>2</code></td>
<td>移动指针</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td><code>1</code></td>
<td><code>2</code></td>
<td><code>3</code></td>
<td>保存 <code>3</code></td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td><code>1</code></td>
<td><code>2</code></td>
<td><code>3</code></td>
<td><code>2.next = 1</code></td>
<td><code>None ← 1 ← 2</code> <code>3 → None</code></td>
</tr>
<tr>
<td>2</td>
<td><code>2</code></td>
<td><code>3</code></td>
<td><code>3</code></td>
<td>移动指针</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td><code>2</code></td>
<td><code>3</code></td>
<td><code>None</code></td>
<td>保存 <code>None</code></td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td><code>2</code></td>
<td><code>3</code></td>
<td><code>None</code></td>
<td><code>3.next = 2</code></td>
<td><code>None ← 1 ← 2 ← 3</code></td>
</tr>
<tr>
<td>3</td>
<td><code>3</code></td>
<td><code>None</code></td>
<td>-</td>
<td>循环结束</td>
<td>-</td>
</tr>
<tr>
<td>返回</td>
<td><code>3</code></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><code>3 → 2 → 1 → None</code></td>
</tr>
</tbody>
</table>
<h3 id="常见错误与边界情况">常见错误与边界情况</h3>
<p><strong>错误一：丢失下一个引用</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：我们丢失了对 curr.next 的引用</span></span><br><span class="line">curr.<span class="built_in">next</span> = prev</span><br><span class="line">prev = curr</span><br><span class="line">curr = curr.<span class="built_in">next</span>  <span class="comment"># 这现在是 prev，不是原始的下一个！</span></span><br></pre></td></tr></table></figure></p>
<p><strong>错误二：不处理空链表</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：如果 head 是 None，我们错误地返回 None</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">head</span>):</span><br><span class="line">    prev = <span class="literal">None</span></span><br><span class="line">    curr = head</span><br><span class="line">    <span class="keyword">while</span> curr:  <span class="comment"># 这正确处理 None，但要明确</span></span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p>
<p><strong>边界情况</strong>： -
空链表（<code>head = None</code>）：返回 <code>None</code> ✅ -
单节点（<code>head = [1]</code>）：返回 <code>[1]</code> ✅ -
两节点（<code>head = [1,2]</code>）：返回 <code>[2,1]</code> ✅</p>
<h3 id="面试技巧">面试技巧</h3>
<p><strong>面试官看重的</strong>： 1.
<strong>指针操作</strong>：你能安全地移动指针而不丢失引用吗？ 2.
<strong>边界情况处理</strong>：你检查空/单节点链表吗？ 3.
<strong>空间优化</strong>：你能用 <span class="math inline">\(O(1)\)</span> 空间完成吗？</p>
<p><strong>后续问题</strong>： - "你能递归地反转吗？" -
"如果链表有环怎么办？" - "你能只反转链表的一部分吗？"</p>
<hr>
<h2 id="方法二递归">方法二：递归</h2>
<h3 id="核心思想-1">核心思想</h3>
<p><strong>递归定义</strong>：反转链表 = 反转剩余部分 +
调整当前节点的指针</p>
<p><strong>基本情况</strong>：空链表或单节点，原样返回</p>
<p><strong>递归步骤</strong>： 1. 递归反转 <code>head.next</code>
并得到新头节点 <code>new_head</code> 2. 使 <code>head.next.next</code>
指向 <code>head</code>（反转指针） 3. 断开
<code>head.next</code>（防止环） 4. 返回 <code>new_head</code></p>
<h3 id="python-实现-1">Python 实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseList_recursive</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    递归反转链表。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    关键洞察：先反转剩余部分，</span></span><br><span class="line"><span class="string">    然后调整当前节点的指针。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    时间复杂度：O(n) - 每个节点访问一次</span></span><br><span class="line"><span class="string">    空间复杂度：O(n) - 递归栈深度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 基本情况：空链表或单节点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归反转剩余链表</span></span><br><span class="line">    <span class="comment"># new_head 将是原始尾节点，现在是新头节点</span></span><br><span class="line">    new_head = reverseList_recursive(head.<span class="built_in">next</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 此时，head.next 是反转子链表的最后一个节点</span></span><br><span class="line">    <span class="comment"># 我们需要让它指回 head</span></span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 断开原始链接以防止环</span></span><br><span class="line">    head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，每个节点访问一次</li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，递归栈深度</li>
</ul>
<h3 id="递归过程可视化">递归过程可视化</h3>
<p><strong>输入</strong>：<code>1 → 2 → 3 → None</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reverseList(1)</span><br><span class="line">    reverseList(2)</span><br><span class="line">        reverseList(3)</span><br><span class="line">            reverseList(None)  # 基本情况，返回 None</span><br><span class="line">        # 现在在节点 3：</span><br><span class="line">        # 3.next = None，所以我们返回 3</span><br><span class="line">        # 执行：2.next.next = 2 → 3.next = 2</span><br><span class="line">        # 断开：2.next = None</span><br><span class="line">        # 返回 3（new_head）</span><br><span class="line">    # 现在在节点 2：</span><br><span class="line">    # 执行：1.next.next = 1 → 2.next = 1</span><br><span class="line">    # 断开：1.next = None</span><br><span class="line">    # 返回 3（new_head）</span><br><span class="line"># 最终：3 → 2 → 1 → None</span><br></pre></td></tr></table></figure>
<p><strong>最终结果</strong>：<code>3 → 2 → 1 → None</code></p>
<h3 id="理解递归的魔法">理解递归的魔法</h3>
<p>递归方法向后工作： 1. 它首先到达尾节点 2.
然后，随着递归展开，它逐个反转指针 3. 递归的每一层处理一个节点的反转</p>
<p><strong>为什么 <code>head.next.next = head</code>？</strong> - 反转从
<code>head.next</code> 开始的子链表后，原本在 <code>head.next</code>
的节点现在是反转子链表的尾节点 - 我们希望这个尾节点指回
<code>head</code> - <code>head.next.next</code> 访问原本在
<code>head.next</code> 的节点，我们让它指向 <code>head</code></p>
<hr>
<h2 id="迭代-vs-递归对比">迭代 vs 递归对比</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间</th>
<th>空间</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>迭代</strong></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>空间最优，更容易理解</td>
<td>代码稍长</td>
</tr>
<tr>
<td><strong>递归</strong></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>简洁，优雅</td>
<td>栈空间开销，潜在栈溢出</td>
</tr>
</tbody>
</table>
<p><strong>面试策略</strong>：从迭代开始（更实用），然后提及递归作为替代方法。</p>
<hr>
<h1 id="问题二合并两个有序链表">问题二：合并两个有序链表</h1>
<h2 id="问题描述-1">问题描述</h2>
<p>将两个升序链表合并为一个新的<strong>升序</strong>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例</strong>： - 输入：<code>l1 = [1,2,4]</code>,
<code>l2 = [1,3,4]</code> - 输出：<code>[1,1,2,3,4,4]</code></p>
<p><strong>约束条件</strong>： - 两个链表的节点数目范围是 <span class="math inline">\([0, 50]\)</span> - <span class="math inline">\(-100 \leq \texttt{Node.val} \leq 100\)</span> -
两个链表均为<strong>非递减</strong>顺序</p>
<h2 id="方法一迭代虚拟节点技术">方法一：迭代（虚拟节点技术）</h2>
<h3 id="核心思想-2">核心思想</h3>
<p>使用<strong>虚拟节点</strong>（哨兵节点）简化边界处理： 1. 创建一个
<code>dummy</code> 节点作为结果链表的前驱 2. 使用 <code>current</code>
指针跟踪当前构建位置 3. 比较 <code>l1</code> 和 <code>l2</code>
的值，将较小的附加到 <code>current</code> 4. 处理剩余节点 5. 返回
<code>dummy.next</code>（跳过哨兵）</p>
<h3 id="python-实现-2">Python 实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">l1, l2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用虚拟节点迭代合并两个有序链表。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    虚拟节点消除了从头开始构建结果链表时的特殊情况。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    时间复杂度：O(m + n)，其中 m, n 是 l1, l2 的长度</span></span><br><span class="line"><span class="string">    空间复杂度：O(1) - 仅使用常数额外空间</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 虚拟节点简化边界处理</span></span><br><span class="line">    <span class="comment"># 我们将在 dummy 之后构建结果链表</span></span><br><span class="line">    dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">    current = dummy</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 比较并合并，当两个链表都有节点时</span></span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">            <span class="comment"># 将 l1 的当前节点附加到结果</span></span><br><span class="line">            current.<span class="built_in">next</span> = l1</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将 l2 的当前节点附加到结果</span></span><br><span class="line">            current.<span class="built_in">next</span> = l2</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 将 current 指针向前移动</span></span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 附加剩余节点（一个链表可能已耗尽）</span></span><br><span class="line">    <span class="comment"># 如果 l1 是 None，l2 有剩余节点（或 None）</span></span><br><span class="line">    <span class="comment"># 如果 l2 是 None，l1 有剩余节点（或 None）</span></span><br><span class="line">    current.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span>  <span class="comment"># 跳过虚拟节点</span></span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-2">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(m +
n)\)</span>，其中 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(n\)</span> 是两个链表的长度</li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span>，仅使用常数额外指针</li>
</ul>
<h3 id="虚拟节点的威力">虚拟节点的威力</h3>
<p><strong>为什么需要虚拟节点？</strong></p>
<p><strong>不使用虚拟节点</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 需要特殊处理第一个节点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeTwoLists_no_dummy</span>(<span class="params">l1, l2</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l2:</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确定头节点</span></span><br><span class="line">    <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">        head = l1</span><br><span class="line">        l1 = l1.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        head = l2</span><br><span class="line">        l2 = l2.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    current = head</span><br><span class="line">    <span class="comment"># 现在合并其余部分...</span></span><br><span class="line">    <span class="comment"># 需要更复杂的逻辑</span></span><br></pre></td></tr></table></figure></p>
<p><strong>使用虚拟节点</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ✅ 统一处理，无特殊情况</span></span><br><span class="line">dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">current = dummy</span><br><span class="line"><span class="comment"># 所有节点的统一循环逻辑</span></span><br></pre></td></tr></table></figure></p>
<p><strong>现实类比</strong>：虚拟节点就像"施工标记"——完成后移除，但在施工过程中提供固定参考点。</p>
<h3 id="逐步解析-1">逐步解析</h3>
<p><strong>输入</strong>：<code>l1 = [1,2,4]</code>,
<code>l2 = [1,3,4]</code></p>
<table>
<colgroup>
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 25%">
<col style="width: 13%">
<col style="width: 20%">
</colgroup>
<thead>
<tr>
<th>步骤</th>
<th><code>l1</code></th>
<th><code>l2</code></th>
<th><code>current</code></th>
<th>操作</th>
<th>当前结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>dummy</code></td>
<td>-</td>
<td><code>dummy → ...</code></td>
</tr>
<tr>
<td>1</td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>dummy</code></td>
<td>比较：<code>1 &lt;= 1</code>，附加 <code>l1</code></td>
<td><code>dummy → 1</code></td>
</tr>
<tr>
<td>1</td>
<td><code>2</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td>移动 <code>l1</code> 向前</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td><code>2</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td>比较：<code>1 &lt; 2</code>，附加 <code>l2</code></td>
<td><code>dummy → 1 → 1</code></td>
</tr>
<tr>
<td>2</td>
<td><code>2</code></td>
<td><code>3</code></td>
<td><code>1</code></td>
<td>移动 <code>l2</code> 向前</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td><code>2</code></td>
<td><code>3</code></td>
<td><code>1</code></td>
<td>比较：<code>2 &lt; 3</code>，附加 <code>l1</code></td>
<td><code>dummy → 1 → 1 → 2</code></td>
</tr>
<tr>
<td>3</td>
<td><code>4</code></td>
<td><code>3</code></td>
<td><code>2</code></td>
<td>移动 <code>l1</code> 向前</td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td><code>4</code></td>
<td><code>3</code></td>
<td><code>2</code></td>
<td>比较：<code>3 &lt; 4</code>，附加 <code>l2</code></td>
<td><code>dummy → 1 → 1 → 2 → 3</code></td>
</tr>
<tr>
<td>4</td>
<td><code>4</code></td>
<td><code>4</code></td>
<td><code>3</code></td>
<td>移动 <code>l2</code> 向前</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td><code>4</code></td>
<td><code>4</code></td>
<td><code>3</code></td>
<td>比较：<code>4 &lt;= 4</code>，附加 <code>l1</code></td>
<td><code>dummy → 1 → 1 → 2 → 3 → 4</code></td>
</tr>
<tr>
<td>5</td>
<td><code>None</code></td>
<td><code>4</code></td>
<td><code>4</code></td>
<td><code>l1</code> 耗尽，附加 <code>l2</code> 的剩余部分</td>
<td><code>dummy → 1 → 1 → 2 → 3 → 4 → 4</code></td>
</tr>
<tr>
<td>返回</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>返回 <code>dummy.next</code></td>
<td><code>1 → 1 → 2 → 3 → 4 → 4</code></td>
</tr>
</tbody>
</table>
<h3 id="边界情况">边界情况</h3>
<ol type="1">
<li><strong>一个链表为空</strong>：<code>l1 = []</code>,
<code>l2 = [1,2]</code> → 返回 <code>[1,2]</code> ✅</li>
<li><strong>两个链表都为空</strong>：<code>l1 = []</code>,
<code>l2 = []</code> → 返回 <code>[]</code> ✅</li>
<li><strong>一个链表更长</strong>：<code>l1 = [1]</code>,
<code>l2 = [2,3,4]</code> → 返回 <code>[1,2,3,4]</code> ✅</li>
</ol>
<hr>
<h2 id="方法二递归-1">方法二：递归</h2>
<h3 id="核心思想-3">核心思想</h3>
<p><strong>递归定义</strong>： - 如果
<code>l1.val &lt;= l2.val</code>，结果是 <code>l1</code> +
merge(<code>l1.next</code>, <code>l2</code>) - 否则，结果是
<code>l2</code> + merge(<code>l1</code>, <code>l2.next</code>)</p>
<h3 id="python-实现-3">Python 实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeTwoLists_recursive</span>(<span class="params">l1, l2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    递归合并两个有序链表。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    递归方法优雅但使用 O(m+n) 栈空间。</span></span><br><span class="line"><span class="string">    生产环境选择迭代，面试中展示多种方法。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    时间复杂度：O(m + n)</span></span><br><span class="line"><span class="string">    空间复杂度：O(m + n) - 递归栈</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 基本情况：如果一个链表为空，返回另一个</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l2:</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归合并：选择较小的头节点，然后合并其余部分</span></span><br><span class="line">    <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">        <span class="comment"># l1 较小，所以它成为头节点</span></span><br><span class="line">        <span class="comment"># 递归合并其余部分</span></span><br><span class="line">        l1.<span class="built_in">next</span> = mergeTwoLists_recursive(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># l2 较小，所以它成为头节点</span></span><br><span class="line">        <span class="comment"># 递归合并其余部分</span></span><br><span class="line">        l2.<span class="built_in">next</span> = mergeTwoLists_recursive(l1, l2.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-3">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(m +
n)\)</span></li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(m +
n)\)</span>，递归栈</li>
</ul>
<h3 id="递归可视化">递归可视化</h3>
<p><strong>输入</strong>：<code>l1 = [1,2]</code>,
<code>l2 = [3,4]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mergeTwoLists([1,2], [3,4])</span><br><span class="line">    l1.val (1) &lt;= l2.val (3) → True</span><br><span class="line">    l1.next = mergeTwoLists([2], [3,4])</span><br><span class="line">        l1.val (2) &lt;= l2.val (3) → True</span><br><span class="line">        l1.next = mergeTwoLists([], [3,4])</span><br><span class="line">            l1 is None → return [3,4]</span><br><span class="line">        return [2,3,4]</span><br><span class="line">    return [1,2,3,4]</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="问题三环形链表-ii">问题三：环形链表 II</h1>
<h2 id="问题描述-2">问题描述</h2>
<p>给定一个链表的头节点
<code>head</code>，返回链表开始入环的第一个节点。如果链表无环，则返回
<code>null</code>。</p>
<p><strong>进阶</strong>：你能用 <span class="math inline">\(O(1)\)</span> 空间解决吗？</p>
<p><strong>示例</strong>： -
输入：<code>head = [3,2,0,-4]</code>，尾节点连接到索引 1 的节点 -
输出：索引 1 的节点</p>
<h2 id="核心思想floyd-环检测算法扩展">核心思想：Floyd
环检测算法（扩展）</h2>
<p><strong>阶段一</strong>：使用快慢指针检测是否存在环</p>
<p><strong>阶段二</strong>：找到环入口 1. 相遇后，将一个指针移回起点 2.
两个指针以<strong>相同速度</strong>移动（每次 1 步） 3.
相遇点就是环入口</p>
<h2 id="python-实现-4">Python 实现</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用 Floyd 算法找到环开始的节点。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    阶段一：使用快/慢指针检测环</span></span><br><span class="line"><span class="string">    阶段二：通过将一个指针移到起点找到入口</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    时间复杂度：O(n)</span></span><br><span class="line"><span class="string">    空间复杂度：O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 阶段一：检测环</span></span><br><span class="line">    slow = fast = head</span><br><span class="line">    has_cycle = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span>        <span class="comment"># 移动 1 步</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span>   <span class="comment"># 移动 2 步</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> slow == fast:</span><br><span class="line">            has_cycle = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> has_cycle:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 阶段二：找到入口</span></span><br><span class="line">    <span class="comment"># 将 slow 移回 head，保持 fast 在相遇点</span></span><br><span class="line">    <span class="comment"># 两者都移动 1 步</span></span><br><span class="line">    slow = head</span><br><span class="line">    <span class="keyword">while</span> slow != fast:</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow  <span class="comment"># 这是环入口</span></span><br></pre></td></tr></table></figure>
<h2 id="数学证明">数学证明</h2>
<p>设： - 从起点到环入口的距离：<span class="math inline">\(a\)</span> -
从环入口到相遇点的距离：<span class="math inline">\(b\)</span> -
从相遇点回到环入口的距离：<span class="math inline">\(c\)</span> -
环长度：<span class="math inline">\(L = b + c\)</span></p>
<p><strong>当它们相遇时</strong>： - 慢指针移动了：<span class="math inline">\(a + b\)</span> - 快指针移动了：<span class="math inline">\(a + b + kL\)</span>（其中 <span class="math inline">\(k\)</span> 是额外循环数）</p>
<p>因为快指针是慢指针的 2 倍： <span class="math display">\[2(a + b) = a
+ b + kL\]</span> <span class="math display">\[a + b = kL\]</span> <span class="math display">\[a = kL - b = (k-1)L + (L - b) = (k-1)L +
c\]</span></p>
<p><strong>关键洞察</strong>：从起点走 <span class="math inline">\(a\)</span> 步到达入口 = 从相遇点走 <span class="math inline">\(c + (k-1)L\)</span> 步到达入口。</p>
<p>因为 <span class="math inline">\((k-1)L\)</span>
是完整循环，<strong>从起点和相遇点以相同速度行走将在入口相遇</strong>！</p>
<h3 id="可视化解释">可视化解释</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">起点 → [a 步] → 入口 → [b 步] → 相遇点</span><br><span class="line">                                    ↓</span><br><span class="line">                              [c 步] ←</span><br><span class="line">                                    |</span><br><span class="line">                                    └─── 环（L = b + c）</span><br></pre></td></tr></table></figure>
<p>当慢指针和快指针相遇时： - 慢指针：移动了 <span class="math inline">\(a + b\)</span> - 快指针：移动了 <span class="math inline">\(a + b + kL\)</span>（其中 <span class="math inline">\(k \geq 1\)</span>）</p>
<p>从方程 <span class="math inline">\(a = (k-1)L + c\)</span>： -
如果我们将 slow 移回起点，两者都以 1 步移动 - Slow 将移动 <span class="math inline">\(a\)</span> 步到达入口 - Fast 将移动 <span class="math inline">\(c + (k-1)L\)</span> 步，这也到达入口（因为 <span class="math inline">\((k-1)L\)</span> 是完整循环）</p>
<h2 id="复杂度分析-4">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span></li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span></li>
</ul>
<h3 id="常见错误">常见错误</h3>
<p><strong>错误一：不检查环是否存在</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：假设环存在</span></span><br><span class="line">slow = fast = head</span><br><span class="line"><span class="keyword">while</span> slow != fast:  <span class="comment"># 如果没有环，这可能永远不会终止！</span></span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<p><strong>错误二：错误的指针重置</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：重置 fast 而不是 slow</span></span><br><span class="line">fast = head  <span class="comment"># 应该是 slow = head</span></span><br><span class="line"><span class="keyword">while</span> slow != fast:</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="问题四相交链表">问题四：相交链表</h1>
<h2 id="问题描述-3">问题描述</h2>
<p>给你两个单链表的头节点 <code>headA</code> 和
<code>headB</code>，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回
<code>null</code>。</p>
<p><strong>约束条件</strong>： - 链表无环 -
函数返回后，链表必须保持其原始结构 - <strong>进阶</strong>：<span class="math inline">\(O(m+n)\)</span> 时间，<span class="math inline">\(O(1)\)</span> 空间</p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A:     a1 → a2 ↘</span><br><span class="line">                c1 → c2 → c3</span><br><span class="line">B: b1 → b2 → b3 ↗</span><br></pre></td></tr></table></figure></p>
<p>相交点是 <code>c1</code>。</p>
<h2 id="方法一双指针路径对齐">方法一：双指针（路径对齐）</h2>
<h3 id="核心思想-4">核心思想</h3>
<p><strong>关键观察</strong>：如果两个链表相交，从交点到末尾的路径长度相同。</p>
<p><strong>巧妙技巧</strong>： 1. 指针 <code>pA</code> 遍历
A，到达末尾时跳到 B 的起点 2. 指针 <code>pB</code> 遍历
B，到达末尾时跳到 A 的起点 3. 两个指针将在交点相遇（或都到达
<code>None</code>）</p>
<p><strong>为什么这样可行？</strong></p>
<p>设： - A 的唯一部分长度：<span class="math inline">\(a\)</span> - B
的唯一部分长度：<span class="math inline">\(b\)</span> -
公共部分长度：<span class="math inline">\(c\)</span></p>
<ul>
<li><code>pA</code> 路径：<span class="math inline">\(a + c +
b\)</span></li>
<li><code>pB</code> 路径：<span class="math inline">\(b + c +
a\)</span></li>
</ul>
<p>它们相等！所以它们会同时到达交点（或 <code>None</code>）。</p>
<h3 id="python-实现-5">Python 实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">headA, headB</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用路径切换的双指针找到相交节点。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    关键洞察：如果链表相交，切换路径使</span></span><br><span class="line"><span class="string">    两个指针行进相同的总距离。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    时间复杂度：O(m + n)</span></span><br><span class="line"><span class="string">    空间复杂度：O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    pA, pB = headA, headB</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 两个指针遍历自己的链表 + 另一个链表</span></span><br><span class="line">    <span class="comment"># 它们会在交点相遇或都是 None</span></span><br><span class="line">    <span class="keyword">while</span> pA != pB:</span><br><span class="line">        <span class="comment"># 如果 pA 到达末尾，切换到 headB</span></span><br><span class="line">        <span class="comment"># 如果 pB 到达末尾，切换到 headA</span></span><br><span class="line">        pA = pA.<span class="built_in">next</span> <span class="keyword">if</span> pA <span class="keyword">else</span> headB</span><br><span class="line">        pB = pB.<span class="built_in">next</span> <span class="keyword">if</span> pB <span class="keyword">else</span> headA</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># pA 和 pB 要么都是 None（无交点）</span></span><br><span class="line">    <span class="comment"># 要么都指向交点节点</span></span><br><span class="line">    <span class="keyword">return</span> pA</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-5">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(m +
n)\)</span></li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span></li>
</ul>
<h3 id="逐步解析-2">逐步解析</h3>
<p><strong>输入</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 → 2 → 8 → 9</span><br><span class="line">B: 3 → 8 → 9</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th><code>pA</code></th>
<th><code>pB</code></th>
<th><code>pA == pB</code>?</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>1</code></td>
<td><code>3</code></td>
<td>❌</td>
</tr>
<tr>
<td>1</td>
<td><code>2</code></td>
<td><code>8</code></td>
<td>❌</td>
</tr>
<tr>
<td>2</td>
<td><code>8</code></td>
<td><code>9</code></td>
<td>❌</td>
</tr>
<tr>
<td>3</td>
<td><code>9</code></td>
<td><code>None</code></td>
<td>❌</td>
</tr>
<tr>
<td>4</td>
<td><code>None</code></td>
<td><code>1</code>（切换到 A）</td>
<td>❌</td>
</tr>
<tr>
<td>5</td>
<td><code>3</code>（切换到 B）</td>
<td><code>2</code></td>
<td>❌</td>
</tr>
<tr>
<td>6</td>
<td><code>8</code></td>
<td><code>8</code></td>
<td>✅ <strong>相遇！</strong></td>
</tr>
</tbody>
</table>
<h3 id="为什么这样可行数学证明">为什么这样可行：数学证明</h3>
<p>设： - 链表 A 长度：<span class="math inline">\(m = a + c\)</span> -
链表 B 长度：<span class="math inline">\(n = b + c\)</span> - 其中 <span class="math inline">\(a\)</span> = A 的唯一部分，<span class="math inline">\(b\)</span> = B 的唯一部分，<span class="math inline">\(c\)</span> = 公共部分</p>
<p>切换后： - <code>pA</code> 行进：<span class="math inline">\(a + c +
b = a + b + c\)</span> - <code>pB</code> 行进：<span class="math inline">\(b + c + a = a + b + c\)</span></p>
<p>两者行进相同距离！如果它们相交，它们在交点相遇。如果不相交，两者同时变为
<code>None</code>。</p>
<hr>
<h2 id="方法二哈希集合">方法二：哈希集合</h2>
<h3 id="python-实现-6">Python 实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getIntersectionNode_hash</span>(<span class="params">headA, headB</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用哈希集合找到交点（更简单但使用 O(m) 空间）。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    时间复杂度：O(m + n)</span></span><br><span class="line"><span class="string">    空间复杂度：O(m) 或 O(n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历 A 并存储所有节点</span></span><br><span class="line">    curr = headA</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        seen.add(curr)</span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历 B 并找到集合中的第一个节点</span></span><br><span class="line">    curr = headB</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        <span class="keyword">if</span> curr <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> curr</span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="复杂度">复杂度</h3>
<ul>
<li><strong>时间</strong>：<span class="math inline">\(O(m +
n)\)</span></li>
<li><strong>空间</strong>：<span class="math inline">\(O(m)\)</span> 或
<span class="math inline">\(O(n)\)</span></li>
</ul>
<p><strong>对比</strong>：双指针方法是空间最优的！</p>
<hr>
<h1 id="问题五删除链表的倒数第-n-个结点">问题五：删除链表的倒数第 N
个结点</h1>
<h2 id="问题描述-4">问题描述</h2>
<p>给你一个链表，删除链表的倒数第 <span class="math inline">\(n\)</span>
个结点，并且返回链表的头结点。</p>
<p><strong>进阶</strong>：你能尝试使用一趟扫描实现吗？</p>
<p><strong>示例</strong>： - 输入：<code>head = [1,2,3,4,5]</code>,
<code>n = 2</code> - 输出：<code>[1,2,3,5]</code>（删除倒数第 2
个节点，即 <code>4</code>）</p>
<p><strong>约束条件</strong>： - 链表中结点的数目为 <span class="math inline">\([1, 30]\)</span> - <span class="math inline">\(1
\leq n \leq \text{链表长度}\)</span></p>
<h2 id="核心思想双指针间隔-n">核心思想：双指针（间隔 n）</h2>
<p><strong>步骤</strong>： 1.
创建一个<strong>虚拟节点</strong>（处理删除头节点的情况） 2.
快指针向前移动 <span class="math inline">\(n+1\)</span> 步 3.
两个指针同步移动直到快指针到达末尾 4.
慢指针现在位于要删除节点的<strong>前一个</strong>节点 5.
删除：<code>slow.next = slow.next.next</code></p>
<h3 id="python-实现-7">Python 实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">head, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用双指针删除倒数第 n 个节点。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    关键洞察：在快指针和慢指针之间保持 n+1 的间隔。</span></span><br><span class="line"><span class="string">    当快指针到达末尾时，慢指针在目标节点之前。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    时间复杂度：O(L)，其中 L 是链表长度 - 一次遍历！</span></span><br><span class="line"><span class="string">    空间复杂度：O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 虚拟节点处理删除头节点的边缘情况</span></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">    dummy.<span class="built_in">next</span> = head</span><br><span class="line">    </span><br><span class="line">    fast = slow = dummy</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将快指针向前移动 n+1 步</span></span><br><span class="line">    <span class="comment"># 这确保 slow 将在目标节点之前</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 同步移动两个指针</span></span><br><span class="line">    <span class="keyword">while</span> fast:</span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 现在 slow 在目标节点之前</span></span><br><span class="line">    <span class="comment"># 删除目标节点</span></span><br><span class="line">    slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-6">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(L)\)</span>，其中 <span class="math inline">\(L\)</span>
是链表长度，<strong>一次遍历</strong></li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span></li>
</ul>
<h3 id="为什么快指针移动-n1-步">为什么快指针移动 n+1 步？</h3>
<p><strong>目标</strong>：使 <code>slow</code>
停在目标节点的<strong>前一个</strong>节点。</p>
<p><strong>示例</strong>：<code>head = [1,2,3,4,5]</code>,
<code>n = 2</code>（删除 <code>4</code>）</p>
<table>
<thead>
<tr>
<th>快指针位置</th>
<th>慢指针位置</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dummy → 1 → 2 → 3</code></td>
<td><code>dummy</code></td>
<td>快指针移动了 3 步（n+1）</td>
</tr>
<tr>
<td><code>3 → 4 → 5 → None</code></td>
<td><code>dummy → 1 → 2 → 3</code></td>
<td>同步移动</td>
</tr>
<tr>
<td><code>None</code></td>
<td><code>3</code></td>
<td><strong>Slow 在 <code>3</code>，可以删除
<code>4</code></strong></td>
</tr>
</tbody>
</table>
<h3 id="边界情况删除头节点">边界情况：删除头节点</h3>
<p><strong>输入</strong>：<code>head = [1,2]</code>,
<code>n = 2</code>（删除 <code>1</code>）</p>
<ul>
<li>快指针移动 3 步：<code>dummy → 1 → 2 → None</code></li>
<li>慢指针仍在 <code>dummy</code></li>
<li>删除：<code>dummy.next = 1.next = 2</code></li>
<li>返回：<code>dummy.next = 2</code> ✅</li>
</ul>
<p><strong>不使用虚拟节点</strong>：需要特殊处理头删除，代码变得复杂！</p>
<h3 id="常见错误-1">常见错误</h3>
<p><strong>错误一：错误的间隔大小</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：仅 n 步，slow 将在目标节点，而不是之前</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    fast = fast.<span class="built_in">next</span></span><br><span class="line"><span class="comment"># 现在 slow.next = slow.next.next 将删除错误的节点</span></span><br></pre></td></tr></table></figure></p>
<p><strong>错误二：不使用虚拟节点</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：需要头删除的特殊情况</span></span><br><span class="line"><span class="keyword">if</span> n == length:</span><br><span class="line">    <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line"><span class="comment"># 更复杂的代码...</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="问题六合并-k-个有序链表">问题六：合并 K 个有序链表</h1>
<h2 id="问题描述-5">问题描述</h2>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例</strong>： -
输入：<code>lists = [[1,4,5],[1,3,4],[2,6]]</code> -
输出：<code>[1,1,2,3,4,4,5,6]</code></p>
<p><strong>约束条件</strong>： - <span class="math inline">\(k ==
\texttt{lists.length}\)</span> - <span class="math inline">\(0 \leq k
\leq 10^4\)</span> - <span class="math inline">\(0 \leq
\texttt{lists[i].length} \leq 500\)</span></p>
<h2 id="方法一分治">方法一：分治</h2>
<h3 id="核心思想-5">核心思想</h3>
<p>递归地成对合并链表，类似于归并排序： 1. 分：将链表数组分成两半 2.
治：递归合并每一半 3. 合：合并两个合并后的半部分</p>
<h3 id="python-实现-8">Python 实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">lists</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用分治合并 k 个有序链表。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    时间复杂度：O(n log k)，其中 n 是总节点数，k 是链表数</span></span><br><span class="line"><span class="string">    空间复杂度：O(log k) 用于递归栈</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    mid = <span class="built_in">len</span>(lists) // <span class="number">2</span></span><br><span class="line">    left = mergeKLists(lists[:mid])</span><br><span class="line">    right = mergeKLists(lists[mid:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(left, right)  <span class="comment"># 使用我们之前的合并函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">l1, l2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;问题二的辅助函数&quot;&quot;&quot;</span></span><br><span class="line">    dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">    current = dummy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">            current.<span class="built_in">next</span> = l1</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current.<span class="built_in">next</span> = l2</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    current.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-7">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(n \log
k)\)</span>，其中 <span class="math inline">\(n\)</span>
是总节点数，<span class="math inline">\(k\)</span> 是链表数</li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(\log
k)\)</span>，递归栈深度</li>
</ul>
<h3 id="为什么分治">为什么分治？</h3>
<p><strong>朴素方法</strong>：逐个合并链表 - 时间：<span class="math inline">\(O(k \times n)\)</span>（每次合并是 <span class="math inline">\(O(n)\)</span>，执行 <span class="math inline">\(k\)</span> 次）</p>
<p><strong>分治</strong>：成对合并 - 时间：<span class="math inline">\(O(n \log k)\)</span>（合并树有 <span class="math inline">\(\log k\)</span> 层，每层处理 <span class="math inline">\(n\)</span> 个节点）</p>
<hr>
<h2 id="方法二优先队列堆">方法二：优先队列（堆）</h2>
<h3 id="python-实现-9">Python 实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeKLists_heap</span>(<span class="params">lists</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用最小堆合并 k 个有序链表。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    时间复杂度：O(n log k)</span></span><br><span class="line"><span class="string">    空间复杂度：O(k) 用于堆</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 最小堆总是获取最小元素</span></span><br><span class="line">    heap = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 用每个链表的第一个节点初始化堆</span></span><br><span class="line">    <span class="keyword">for</span> i, node <span class="keyword">in</span> <span class="built_in">enumerate</span>(lists):</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            heapq.heappush(heap, (node.val, i, node))</span><br><span class="line">    </span><br><span class="line">    dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">    current = dummy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> heap:</span><br><span class="line">        val, idx, node = heapq.heappop(heap)</span><br><span class="line">        current.<span class="built_in">next</span> = node</span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果同一链表有下一个节点，添加到堆</span></span><br><span class="line">        <span class="keyword">if</span> node.<span class="built_in">next</span>:</span><br><span class="line">            heapq.heappush(heap, (node.<span class="built_in">next</span>.val, idx, node.<span class="built_in">next</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="问题七复制带随机指针的链表">问题七：复制带随机指针的链表</h1>
<h2 id="问题描述-6">问题描述</h2>
<p>给你一个长度为 <span class="math inline">\(n\)</span>
的链表，每个节点包含一个额外增加的随机指针
<code>random</code>，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的<strong>深拷贝</strong>。</p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始：7 → 13 → 11 → 10 → 1 → None</span><br><span class="line">      ↓    ↓     ↓     ↓    ↓</span><br><span class="line">      -    7     1     11   7</span><br></pre></td></tr></table></figure></p>
<h2 id="方法两次遍历与哈希映射">方法：两次遍历与哈希映射</h2>
<h3 id="核心思想-6">核心思想</h3>
<ol type="1">
<li><strong>第一次遍历</strong>：创建所有新节点并建立旧 → 新映射</li>
<li><strong>第二次遍历</strong>：使用映射连接 <code>next</code> 和
<code>random</code> 指针</li>
</ol>
<h3 id="python-实现-10">Python 实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copyRandomList</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    深拷贝带随机指针的链表。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    两次遍历方法：</span></span><br><span class="line"><span class="string">    1. 创建所有节点并建立旧→新映射</span></span><br><span class="line"><span class="string">    2. 使用映射连接 next 和 random 指针</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    时间复杂度：O(n)</span></span><br><span class="line"><span class="string">    空间复杂度：O(n) 用于哈希映射</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 映射旧节点到新节点</span></span><br><span class="line">    node_map = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第一次遍历：创建所有节点</span></span><br><span class="line">    curr = head</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        node_map[curr] = Node(curr.val)</span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二次遍历：连接指针</span></span><br><span class="line">    curr = head</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        new_node = node_map[curr]</span><br><span class="line">        <span class="comment"># 连接 next 指针</span></span><br><span class="line">        <span class="keyword">if</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            new_node.<span class="built_in">next</span> = node_map[curr.<span class="built_in">next</span>]</span><br><span class="line">        <span class="comment"># 连接 random 指针</span></span><br><span class="line">        <span class="keyword">if</span> curr.random:</span><br><span class="line">            new_node.random = node_map[curr.random]</span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node_map[head]</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-8">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，两次遍历</li>
<li><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，哈希映射存储</li>
</ul>
<hr>
<h1 id="虚拟节点的威力-1">虚拟节点的威力</h1>
<h2 id="何时使用虚拟节点">何时使用虚拟节点？</h2>
<p><strong>信号</strong>： - 可能删除头节点 - 需要返回新头节点 -
构建新链表</p>
<p><strong>好处</strong>： - 统一处理头节点和其他节点 -
无空链表的特殊情况 - 代码更简洁</p>
<h2 id="对比示例删除节点">对比示例：删除节点</h2>
<p><strong>不使用虚拟节点</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">head, val</span>):</span><br><span class="line">    <span class="comment"># ❌ 头节点的特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> head.val == val:</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    curr = head</span><br><span class="line">    <span class="keyword">while</span> curr.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">if</span> curr.<span class="built_in">next</span>.val == val:</span><br><span class="line">            curr.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p>
<p><strong>使用虚拟节点</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deleteNode_dummy</span>(<span class="params">head, val</span>):</span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">    dummy.<span class="built_in">next</span> = head</span><br><span class="line">    curr = dummy</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ✅ 统一处理</span></span><br><span class="line">    <span class="keyword">while</span> curr.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">if</span> curr.<span class="built_in">next</span>.val == val:</span><br><span class="line">            curr.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="常见陷阱与调试技巧">常见陷阱与调试技巧</h1>
<h2 id="陷阱一空指针访问">陷阱一：空指针访问</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ curr 可能是 None</span></span><br><span class="line"><span class="keyword">while</span> curr:</span><br><span class="line">    <span class="keyword">if</span> curr.<span class="built_in">next</span>.val == target:  <span class="comment"># 💥 curr.next 可能是 None</span></span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p><strong>修复</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ✅ 检查 curr.next 是否存在</span></span><br><span class="line"><span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">    <span class="keyword">if</span> curr.<span class="built_in">next</span>.val == target:</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p>
<h2 id="陷阱二修改指针后丢失节点引用">陷阱二：修改指针后丢失节点引用</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误示例</span></span><br><span class="line">curr.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># 直接跳过，丢失对删除节点的引用</span></span><br></pre></td></tr></table></figure>
<p><strong>正确方法</strong>： - 如果需要访问删除的节点，先保存：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">to_delete = curr.<span class="built_in">next</span></span><br><span class="line">curr.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"><span class="comment"># 仍可使用 to_delete</span></span><br></pre></td></tr></table></figure></p>
<h2 id="陷阱三忘记移动指针">陷阱三：忘记移动指针</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 无限循环</span></span><br><span class="line"><span class="keyword">while</span> curr:</span><br><span class="line">    <span class="comment"># 处理逻辑</span></span><br><span class="line">    <span class="comment"># 忘记：curr = curr.next</span></span><br></pre></td></tr></table></figure>
<h2 id="调试技巧">调试技巧</h2>
<h3 id="技巧一打印链表">技巧一：打印链表</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_list</span>(<span class="params">head</span>):</span><br><span class="line">    vals = []</span><br><span class="line">    curr = head</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        vals.append(<span class="built_in">str</span>(curr.val))</span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; → &quot;</span>.join(vals) + <span class="string">&quot; → None&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="技巧二画图">技巧二：画图</h3>
<p>在每一步绘制链表状态，特别是在修改指针时。</p>
<h3 id="技巧三逐步调试">技巧三：逐步调试</h3>
<p>对于复杂操作（如反转、合并），逐步执行并检查每一步后的指针状态。</p>
<hr>
<h1 id="链表面试沟通模板">链表面试沟通模板</h1>
<h2 id="模板一识别链表特征">模板一：识别链表特征</h2>
<blockquote>
<p>"这个问题涉及链表操作。链表具有<strong><span class="math inline">\(O(1)\)</span> 插入/删除但 <span class="math inline">\(O(n)\)</span>
访问</strong>。我将使用<strong>[迭代/递归]</strong>方法，采用<strong>[双指针/虚拟节点]</strong>技术来<strong>[反转/合并/检测]</strong>链表。"</p>
</blockquote>
<h2 id="模板二选择迭代-vs-递归">模板二：选择迭代 vs 递归</h2>
<blockquote>
<p>"我可以用<strong>迭代</strong>实现，空间复杂度 <span class="math inline">\(O(1)\)</span>，或者用<strong>递归</strong>实现，代码更简洁但空间复杂度
<span class="math inline">\(O(n)\)</span>。对于生产环境，我倾向于迭代以避免栈溢出；对于面试，我先展示迭代，然后提及递归作为替代。"</p>
</blockquote>
<h2 id="模板三解释虚拟节点">模板三：解释虚拟节点</h2>
<blockquote>
<p>"我将使用<strong>虚拟节点</strong>作为哨兵来<strong>统一处理头节点</strong>特殊情况，避免复杂的边界检查。最后，返回
<code>dummy.next</code>。"</p>
</blockquote>
<h2 id="模板四快慢指针">模板四：快慢指针</h2>
<blockquote>
<p>"我将使用<strong>快慢指针</strong>：快指针移动 2 步，慢指针移动 1
步。这以<strong>一次遍历</strong>解决，时间复杂度 <span class="math inline">\(O(n)\)</span>，空间复杂度 <span class="math inline">\(O(1)\)</span>。"</p>
</blockquote>
<hr>
<h2 id="qa链表面试技巧">❓ Q&amp;A：链表面试技巧</h2>
<h3 id="q1什么时候应该对链表使用递归-vs-迭代">Q1：什么时候应该对链表使用递归
vs 迭代？</h3>
<p><strong>答案</strong>：当以下情况使用<strong>迭代</strong>： -
空间优化重要（<span class="math inline">\(O(1)\)</span> vs <span class="math inline">\(O(n)\)</span>） - 生产代码（避免栈溢出风险） -
长链表（递归深度担忧）</p>
<p>当以下情况使用<strong>递归</strong>： - 代码清晰度优先 -
在面试中展示多种方法 - 自然递归结构（例如，类似树的问题）</p>
<p><strong>面试提示</strong>：总是提及两种方法，但先实现迭代。</p>
<hr>
<h3 id="q2如何系统地处理边界情况">Q2：如何系统地处理边界情况？</h3>
<p><strong>答案</strong>：系统地检查这些： 1.
<strong>空链表</strong>：<code>head == None</code> 2.
<strong>单节点</strong>：<code>head.next == None</code> 3.
<strong>两节点</strong>：操作的特殊情况 4.
<strong>头节点修改</strong>：使用虚拟节点 5.
<strong>环检测</strong>：访问前检查 <code>fast</code> 和
<code>fast.next</code></p>
<p><strong>模式</strong>：访问 <code>node.next</code> 前总是检查
<code>node</code>。</p>
<hr>
<h3 id="q3找链表中间的最佳方法是什么">Q3：找链表中间的最佳方法是什么？</h3>
<p><strong>答案</strong>：使用<strong>快慢指针</strong>：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findMiddle</span>(<span class="params">head</span>):</span><br><span class="line">    slow = fast = head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure></p>
<p>当快指针到达末尾时，慢指针在中点（或偶数长度时的第二个中点）。</p>
<hr>
<h3 id="q4如何在不使用额外空间的情况下检测环">Q4：如何在不使用额外空间的情况下检测环？</h3>
<p><strong>答案</strong>：使用<strong>Floyd 算法</strong>（快慢指针）：
- 快指针移动 2 步，慢指针移动 1 步 - 如果它们相遇，存在环 -
找入口：将一个指针移到起点，两者都移动 1 步</p>
<p>时间：<span class="math inline">\(O(n)\)</span>，空间：<span class="math inline">\(O(1)\)</span></p>
<hr>
<h3 id="q5当你只能访问该节点时删除节点的技巧是什么">Q5：当你只能访问该节点时，删除节点的技巧是什么？</h3>
<p><strong>答案</strong>：<strong>复制下一个节点的数据，然后删除下一个节点</strong>：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="comment"># 如果是最后一个节点，无法删除</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 复制下一个节点的值</span></span><br><span class="line">    node.val = node.<span class="built_in">next</span>.val</span><br><span class="line">    <span class="comment"># 删除下一个节点</span></span><br><span class="line">    node.<span class="built_in">next</span> = node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：这对最后一个节点不起作用（需要
<code>None</code>）。</p>
<hr>
<h3 id="q6如何按-k-组反转链表">Q6：如何按 k 组反转链表？</h3>
<p><strong>答案</strong>：使用递归： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">head, k</span>):</span><br><span class="line">    <span class="comment"># 检查是否有 k 个节点</span></span><br><span class="line">    curr = head</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> curr <span class="keyword">and</span> count &lt; k:</span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> count == k:</span><br><span class="line">        <span class="comment"># 反转前 k 个节点</span></span><br><span class="line">        curr = reverseKGroup(curr, k)  <span class="comment"># 递归处理剩余部分</span></span><br><span class="line">        <span class="keyword">while</span> count &gt; <span class="number">0</span>:</span><br><span class="line">            next_node = head.<span class="built_in">next</span></span><br><span class="line">            head.<span class="built_in">next</span> = curr</span><br><span class="line">            curr = head</span><br><span class="line">            head = next_node</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">        head = curr</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="q7链表问题中最常见的错误是什么">Q7：链表问题中最常见的错误是什么？</h3>
<p><strong>答案</strong>：<strong>当 <code>node</code> 可能是
<code>None</code> 时访问 <code>node.next</code></strong>。</p>
<p>总是检查： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> node <span class="keyword">and</span> node.<span class="built_in">next</span>:</span><br><span class="line">    <span class="comment"># 安全访问 node.next</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="q8如何高效合并-k-个有序链表">Q8：如何高效合并 k
个有序链表？</h3>
<p><strong>答案</strong>：两种主要方法：</p>
<ol type="1">
<li><strong>分治</strong>：<span class="math inline">\(O(n \log
k)\)</span> 时间，<span class="math inline">\(O(\log k)\)</span> 空间
<ul>
<li>递归成对合并</li>
</ul></li>
<li><strong>优先队列</strong>：<span class="math inline">\(O(n \log
k)\)</span> 时间，<span class="math inline">\(O(k)\)</span> 空间
<ul>
<li>使用最小堆总是获取最小元素</li>
</ul></li>
</ol>
<p>两者都是最优的。根据空间约束选择。</p>
<hr>
<h3 id="q9能否在不使用额外空间的情况下原地修改链表">Q9：能否在不使用额外空间的情况下原地修改链表？</h3>
<p><strong>答案</strong>：可以！大多数操作可以在 <span class="math inline">\(O(1)\)</span> 空间中完成： - 反转：三指针 -
环检测：快慢指针 - 合并：虚拟节点 + 指针 - 删除：双指针</p>
<p><strong>关键</strong>：巧妙地使用指针，避免额外数据结构。</p>
<hr>
<h3 id="q10被问及时间空间复杂度时应该说什么">Q10：被问及时间/空间复杂度时应该说什么？</h3>
<p><strong>答案</strong>：要具体： -
<strong>时间</strong>：计算操作（遍历、比较） -
<strong>空间</strong>：计算额外变量（指针 = <span class="math inline">\(O(1)\)</span>，递归栈 = <span class="math inline">\(O(n)\)</span>，哈希映射 = <span class="math inline">\(O(n)\)</span>）</p>
<p><strong>示例</strong>："这使用两个指针，所以空间是 <span class="math inline">\(O(1)\)</span>。我们遍历一次，所以时间是 <span class="math inline">\(O(n)\)</span>。"</p>
<hr>
<h1 id="练习题目10-道推荐">练习题目（10 道推荐）</h1>
<h2 id="基本操作">基本操作</h2>
<ol type="1">
<li><strong>反转链表</strong>（LeetCode 206）← 本文已覆盖 简单</li>
<li><strong>合并两个有序链表</strong>（LeetCode 21）← 本文已覆盖
简单</li>
<li><strong>删除链表的倒数第 N 个结点</strong>（LeetCode 19）←
本文已覆盖 中等</li>
</ol>
<h2 id="环检测与相交">环检测与相交</h2>
<ol start="4" type="1">
<li><strong>环形链表</strong>（LeetCode 141）简单</li>
<li><strong>环形链表 II</strong>（LeetCode 142）← 本文已覆盖 中等</li>
<li><strong>相交链表</strong>（LeetCode 160）← 本文已覆盖 简单</li>
</ol>
<h2 id="高级操作">高级操作</h2>
<ol start="7" type="1">
<li><strong>回文链表</strong>（LeetCode 234）简单</li>
<li><strong>排序链表</strong>（LeetCode 148）中等</li>
<li><strong>重排链表</strong>（LeetCode 143）中等</li>
<li><strong>复制带随机指针的链表</strong>（LeetCode 138）← 本文已覆盖
中等</li>
</ol>
<hr>
<h1 id="总结链表操作速查表">总结：链表操作速查表</h1>
<h2 id="核心技术快速参考">核心技术快速参考</h2>
<table>
<colgroup>
<col style="width: 28%">
<col style="width: 28%">
<col style="width: 42%">
</colgroup>
<thead>
<tr>
<th>技术</th>
<th>用例</th>
<th>示例问题</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>双指针</strong></td>
<td>找中点、环检测、倒数第 n 个</td>
<td>环检测、删除倒数第 n 个节点</td>
</tr>
<tr>
<td><strong>虚拟节点</strong></td>
<td>删除头节点、构建新链表</td>
<td>合并链表、删除节点</td>
</tr>
<tr>
<td><strong>递归</strong></td>
<td>反转、合并（代码简洁）</td>
<td>反转链表、合并链表</td>
</tr>
<tr>
<td><strong>迭代</strong></td>
<td>所有操作（空间最优）</td>
<td>反转链表、检测环</td>
</tr>
</tbody>
</table>
<h2 id="何时使用什么">何时使用什么？</h2>
<p><strong>双指针</strong>： - 需要同时跟踪多个位置 - 环检测（快慢） -
找中点、倒数第 n 个</p>
<p><strong>虚拟节点</strong>： - 可能修改头节点 - 构建新链表 -
简化边界条件</p>
<p><strong>递归 vs 迭代</strong>： - 递归：代码简洁，适合展示算法思维 -
迭代：空间最优，更适合生产环境</p>
<h2 id="常见陷阱">常见陷阱</h2>
<ol type="1">
<li><strong>空指针</strong>：访问 <code>node.next</code> 前检查
<code>node</code></li>
<li><strong>丢失引用</strong>：修改指针前保存必要引用</li>
<li><strong>忘记移动指针</strong>：每个循环分支必须移动指针</li>
<li><strong>边界情况</strong>：空链表、单节点、头节点操作</li>
</ol>
<h2 id="面试黄金短语">面试黄金短语</h2>
<blockquote>
<p>"链表的核心是<strong>指针操作</strong>。我将使用<strong>[双指针/虚拟/递归]</strong>技术，确保<strong>边界安全</strong>，实现<strong><span class="math inline">\(O(n)\)</span> 时间，<span class="math inline">\(O(1)\)</span> 空间</strong>（或解释递归的 <span class="math inline">\(O(n)\)</span> 栈空间）。"</p>
</blockquote>
<h2 id="记忆口诀">记忆口诀</h2>
<blockquote>
<p><strong>双指针找环和中点，虚拟简化边界，迭代节省空间递归优雅，指针操作避免空指针和陷阱！</strong></p>
</blockquote>
<hr>
<h1 id="下一篇文章预览">下一篇文章预览</h1>
<p>在<strong>LeetCode（四）：二叉树遍历与递归</strong>中，我们将探索： -
<strong>四种遍历方法</strong>：前序、中序、后序、层序 -
<strong>递归模式</strong>：子树问题分解 - <strong>Morris
遍历</strong>：<span class="math inline">\(O(1)\)</span> 空间遍历 -
<strong>经典问题</strong>：最近公共祖先、路径和、树序列化</p>
<p><strong>思考题</strong>：如何在不使用递归或栈的情况下执行中序遍历？下一篇文章见答案！</p>
<hr>
<p>链表不是数据结构的"困难部分"——它们是<strong>指针思维的试金石</strong>。掌握它们，你将轻松处理树、图和更复杂的结构！</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>本文标题：LeetCode（三）—— 链表操作</li>
        <li>本文作者：Chen Kai</li>
        <li>创建时间：2022-05-20 00:00:00</li>
        <li>
            本文链接：https://www.chenk.top/LeetCode%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/LeetCode%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode（五）—— 二分查找</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/LeetCode%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode（七）—— 回溯算法</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情赞美帅气伟大的ck吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- 由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E5%88%97%E5%AF%BC%E8%88%AA"><span class="nav-number">1.</span> <span class="nav-text">系列导航</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE"><span class="nav-number">2.</span> <span class="nav-text">链表基础回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8-vs-%E6%95%B0%E7%BB%84"><span class="nav-number">2.1.</span> <span class="nav-text">链表 vs 数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.</span> <span class="nav-text">链表节点定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.3.</span> <span class="nav-text">链表的思维模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">问题一：反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E8%BF%AD%E4%BB%A3%E4%B8%89%E6%8C%87%E9%92%88%E6%8A%80%E6%9C%AF"><span class="nav-number">3.2.</span> <span class="nav-text">方法一：迭代（三指针技术）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">3.2.1.</span> <span class="nav-text">核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python-%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.2.2.</span> <span class="nav-text">Python 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">3.2.3.</span> <span class="nav-text">复杂度分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%90%E6%AD%A5%E8%A7%A3%E6%9E%90"><span class="nav-number">3.2.4.</span> <span class="nav-text">逐步解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8E%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5"><span class="nav-number">3.2.5.</span> <span class="nav-text">常见错误与边界情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">3.2.6.</span> <span class="nav-text">面试技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E9%80%92%E5%BD%92"><span class="nav-number">3.3.</span> <span class="nav-text">方法二：递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python-%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">3.3.2.</span> <span class="nav-text">Python 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="nav-number">3.3.3.</span> <span class="nav-text">复杂度分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="nav-number">3.3.4.</span> <span class="nav-text">递归过程可视化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%E7%9A%84%E9%AD%94%E6%B3%95"><span class="nav-number">3.3.5.</span> <span class="nav-text">理解递归的魔法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3-vs-%E9%80%92%E5%BD%92%E5%AF%B9%E6%AF%94"><span class="nav-number">3.4.</span> <span class="nav-text">迭代 vs 递归对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">4.</span> <span class="nav-text">问题二：合并两个有序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="nav-number">4.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E8%BF%AD%E4%BB%A3%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9%E6%8A%80%E6%9C%AF"><span class="nav-number">4.2.</span> <span class="nav-text">方法一：迭代（虚拟节点技术）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-2"><span class="nav-number">4.2.1.</span> <span class="nav-text">核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python-%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">4.2.2.</span> <span class="nav-text">Python 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="nav-number">4.2.3.</span> <span class="nav-text">复杂度分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9%E7%9A%84%E5%A8%81%E5%8A%9B"><span class="nav-number">4.2.4.</span> <span class="nav-text">虚拟节点的威力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%90%E6%AD%A5%E8%A7%A3%E6%9E%90-1"><span class="nav-number">4.2.5.</span> <span class="nav-text">逐步解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5"><span class="nav-number">4.2.6.</span> <span class="nav-text">边界情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E9%80%92%E5%BD%92-1"><span class="nav-number">4.3.</span> <span class="nav-text">方法二：递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-3"><span class="nav-number">4.3.1.</span> <span class="nav-text">核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python-%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">4.3.2.</span> <span class="nav-text">Python 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="nav-number">4.3.3.</span> <span class="nav-text">复杂度分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="nav-number">4.3.4.</span> <span class="nav-text">递归可视化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%89%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii"><span class="nav-number">5.</span> <span class="nav-text">问题三：环形链表 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2"><span class="nav-number">5.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3floyd-%E7%8E%AF%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E6%89%A9%E5%B1%95"><span class="nav-number">5.2.</span> <span class="nav-text">核心思想：Floyd
环检测算法（扩展）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python-%E5%AE%9E%E7%8E%B0-4"><span class="nav-number">5.3.</span> <span class="nav-text">Python 实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E"><span class="nav-number">5.4.</span> <span class="nav-text">数学证明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E8%A7%A3%E9%87%8A"><span class="nav-number">5.4.1.</span> <span class="nav-text">可视化解释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-4"><span class="nav-number">5.5.</span> <span class="nav-text">复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="nav-number">5.5.1.</span> <span class="nav-text">常见错误</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%9B%9B%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">6.</span> <span class="nav-text">问题四：相交链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-3"><span class="nav-number">6.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%8F%8C%E6%8C%87%E9%92%88%E8%B7%AF%E5%BE%84%E5%AF%B9%E9%BD%90"><span class="nav-number">6.2.</span> <span class="nav-text">方法一：双指针（路径对齐）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-4"><span class="nav-number">6.2.1.</span> <span class="nav-text">核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python-%E5%AE%9E%E7%8E%B0-5"><span class="nav-number">6.2.2.</span> <span class="nav-text">Python 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-5"><span class="nav-number">6.2.3.</span> <span class="nav-text">复杂度分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%90%E6%AD%A5%E8%A7%A3%E6%9E%90-2"><span class="nav-number">6.2.4.</span> <span class="nav-text">逐步解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%A0%B7%E5%8F%AF%E8%A1%8C%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E"><span class="nav-number">6.2.5.</span> <span class="nav-text">为什么这样可行：数学证明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88"><span class="nav-number">6.3.</span> <span class="nav-text">方法二：哈希集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#python-%E5%AE%9E%E7%8E%B0-6"><span class="nav-number">6.3.1.</span> <span class="nav-text">Python 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">6.3.2.</span> <span class="nav-text">复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%BA%94%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">7.</span> <span class="nav-text">问题五：删除链表的倒数第 N
个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-4"><span class="nav-number">7.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%B4%E9%9A%94-n"><span class="nav-number">7.2.</span> <span class="nav-text">核心思想：双指针（间隔 n）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#python-%E5%AE%9E%E7%8E%B0-7"><span class="nav-number">7.2.1.</span> <span class="nav-text">Python 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-6"><span class="nav-number">7.2.2.</span> <span class="nav-text">复杂度分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%E6%8C%87%E9%92%88%E7%A7%BB%E5%8A%A8-n1-%E6%AD%A5"><span class="nav-number">7.2.3.</span> <span class="nav-text">为什么快指针移动 n+1 步？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5%E5%88%A0%E9%99%A4%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="nav-number">7.2.4.</span> <span class="nav-text">边界情况：删除头节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF-1"><span class="nav-number">7.2.5.</span> <span class="nav-text">常见错误</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%85%AD%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">8.</span> <span class="nav-text">问题六：合并 K 个有序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-5"><span class="nav-number">8.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%88%86%E6%B2%BB"><span class="nav-number">8.2.</span> <span class="nav-text">方法一：分治</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-5"><span class="nav-number">8.2.1.</span> <span class="nav-text">核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python-%E5%AE%9E%E7%8E%B0-8"><span class="nav-number">8.2.2.</span> <span class="nav-text">Python 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-7"><span class="nav-number">8.2.3.</span> <span class="nav-text">复杂度分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E6%B2%BB"><span class="nav-number">8.2.4.</span> <span class="nav-text">为什么分治？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86"><span class="nav-number">8.3.</span> <span class="nav-text">方法二：优先队列（堆）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#python-%E5%AE%9E%E7%8E%B0-9"><span class="nav-number">8.3.1.</span> <span class="nav-text">Python 实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%83%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">9.</span> <span class="nav-text">问题七：复制带随机指针的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-6"><span class="nav-number">9.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86%E4%B8%8E%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84"><span class="nav-number">9.2.</span> <span class="nav-text">方法：两次遍历与哈希映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-6"><span class="nav-number">9.2.1.</span> <span class="nav-text">核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python-%E5%AE%9E%E7%8E%B0-10"><span class="nav-number">9.2.2.</span> <span class="nav-text">Python 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-8"><span class="nav-number">9.2.3.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9%E7%9A%84%E5%A8%81%E5%8A%9B-1"><span class="nav-number">10.</span> <span class="nav-text">虚拟节点的威力</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9"><span class="nav-number">10.1.</span> <span class="nav-text">何时使用虚拟节点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E7%A4%BA%E4%BE%8B%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="nav-number">10.2.</span> <span class="nav-text">对比示例：删除节点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%E4%B8%8E%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">11.</span> <span class="nav-text">常见陷阱与调试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%B8%80%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE"><span class="nav-number">11.1.</span> <span class="nav-text">陷阱一：空指针访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%BA%8C%E4%BF%AE%E6%94%B9%E6%8C%87%E9%92%88%E5%90%8E%E4%B8%A2%E5%A4%B1%E8%8A%82%E7%82%B9%E5%BC%95%E7%94%A8"><span class="nav-number">11.2.</span> <span class="nav-text">陷阱二：修改指针后丢失节点引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%B8%89%E5%BF%98%E8%AE%B0%E7%A7%BB%E5%8A%A8%E6%8C%87%E9%92%88"><span class="nav-number">11.3.</span> <span class="nav-text">陷阱三：忘记移动指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">11.4.</span> <span class="nav-text">调试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7%E4%B8%80%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">11.4.1.</span> <span class="nav-text">技巧一：打印链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7%E4%BA%8C%E7%94%BB%E5%9B%BE"><span class="nav-number">11.4.2.</span> <span class="nav-text">技巧二：画图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7%E4%B8%89%E9%80%90%E6%AD%A5%E8%B0%83%E8%AF%95"><span class="nav-number">11.4.3.</span> <span class="nav-text">技巧三：逐步调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E6%B2%9F%E9%80%9A%E6%A8%A1%E6%9D%BF"><span class="nav-number">12.</span> <span class="nav-text">链表面试沟通模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%80%E8%AF%86%E5%88%AB%E9%93%BE%E8%A1%A8%E7%89%B9%E5%BE%81"><span class="nav-number">12.1.</span> <span class="nav-text">模板一：识别链表特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%BA%8C%E9%80%89%E6%8B%A9%E8%BF%AD%E4%BB%A3-vs-%E9%80%92%E5%BD%92"><span class="nav-number">12.2.</span> <span class="nav-text">模板二：选择迭代 vs 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%89%E8%A7%A3%E9%87%8A%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9"><span class="nav-number">12.3.</span> <span class="nav-text">模板三：解释虚拟节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%9B%9B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">12.4.</span> <span class="nav-text">模板四：快慢指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qa%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">12.5.</span> <span class="nav-text">❓ Q&amp;A：链表面试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#q1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E5%AF%B9%E9%93%BE%E8%A1%A8%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92-vs-%E8%BF%AD%E4%BB%A3"><span class="nav-number">12.5.1.</span> <span class="nav-text">Q1：什么时候应该对链表使用递归
vs 迭代？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q2%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%A4%84%E7%90%86%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5"><span class="nav-number">12.5.2.</span> <span class="nav-text">Q2：如何系统地处理边界情况？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q3%E6%89%BE%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E7%9A%84%E6%9C%80%E4%BD%B3%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">12.5.3.</span> <span class="nav-text">Q3：找链表中间的最佳方法是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q4%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%A3%80%E6%B5%8B%E7%8E%AF"><span class="nav-number">12.5.4.</span> <span class="nav-text">Q4：如何在不使用额外空间的情况下检测环？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q5%E5%BD%93%E4%BD%A0%E5%8F%AA%E8%83%BD%E8%AE%BF%E9%97%AE%E8%AF%A5%E8%8A%82%E7%82%B9%E6%97%B6%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E7%9A%84%E6%8A%80%E5%B7%A7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">12.5.5.</span> <span class="nav-text">Q5：当你只能访问该节点时，删除节点的技巧是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q6%E5%A6%82%E4%BD%95%E6%8C%89-k-%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">12.5.6.</span> <span class="nav-text">Q6：如何按 k 组反转链表？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q7%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%E4%B8%AD%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">12.5.7.</span> <span class="nav-text">Q7：链表问题中最常见的错误是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q8%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">12.5.8.</span> <span class="nav-text">Q8：如何高效合并 k
个有序链表？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q9%E8%83%BD%E5%90%A6%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9%E9%93%BE%E8%A1%A8"><span class="nav-number">12.5.9.</span> <span class="nav-text">Q9：能否在不使用额外空间的情况下原地修改链表？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q10%E8%A2%AB%E9%97%AE%E5%8F%8A%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%97%B6%E5%BA%94%E8%AF%A5%E8%AF%B4%E4%BB%80%E4%B9%88"><span class="nav-number">12.5.10.</span> <span class="nav-text">Q10：被问及时间&#x2F;空间复杂度时应该说什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98%E7%9B%AE10-%E9%81%93%E6%8E%A8%E8%8D%90"><span class="nav-number">13.</span> <span class="nav-text">练习题目（10 道推荐）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">13.1.</span> <span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%9B%B8%E4%BA%A4"><span class="nav-number">13.2.</span> <span class="nav-text">环检测与相交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">13.3.</span> <span class="nav-text">高级操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="nav-number">14.</span> <span class="nav-text">总结：链表操作速查表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%BF%AB%E9%80%9F%E5%8F%82%E8%80%83"><span class="nav-number">14.1.</span> <span class="nav-text">核心技术快速参考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88"><span class="nav-number">14.2.</span> <span class="nav-text">何时使用什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1"><span class="nav-number">14.3.</span> <span class="nav-text">常见陷阱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%BB%84%E9%87%91%E7%9F%AD%E8%AF%AD"><span class="nav-number">14.4.</span> <span class="nav-text">面试黄金短语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BF%86%E5%8F%A3%E8%AF%80"><span class="nav-number">14.5.</span> <span class="nav-text">记忆口诀</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%A2%84%E8%A7%88"><span class="nav-number">15.</span> <span class="nav-text">下一篇文章预览</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
