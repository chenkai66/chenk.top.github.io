<!DOCTYPE html>



<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode（四）—— 滑动窗口技巧 |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"zh-CN","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode（四）—— 滑动窗口技巧</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-03-02 00:00:00</span>
        <span class="mobile">2023-03-02 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>9.2k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>38 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>滑动窗口是解决数组和字符串问题的一把利器。当你遇到&quot;子数组&quot;、“子串”、&quot;连续&quot;这些关键词时，滑动窗口往往能提供 $O(n)$ 时间复杂度的优雅解法。这篇文章会从基础概念开始，逐步深入到固定窗口和可变窗口两种模式，并通过多道 LeetCode 经典题目帮你彻底掌握这个技巧。</p>
<span id="more"></span>
<h2 id="什么是滑动窗口"><a class="header-anchor" href="#什么是滑动窗口">¶</a>什么是滑动窗口</h2>
<p>滑动窗口（Sliding Window）是一种双指针技巧的变体，主要用于解决数组或字符串中的连续子区间问题。它的核心思想是维护一个窗口，通过移动窗口的左右边界来遍历所有可能的子区间，同时利用窗口内的信息避免重复计算。</p>
<p>想象一下，你在一列火车上，透过一个固定大小的窗户看外面的风景。随着火车前进，窗户会&quot;滑动&quot;到新的位置，但窗户的大小保持不变。这就是固定窗口大小的情况。另一种情况是，窗户的大小可以变化——你可以拉大或缩小窗户，直到看到最合适的风景。这就是可变窗口大小的情况。</p>
<p>在算法中，滑动窗口通常涉及两个指针（left 和 right）：</p>
<ul>
<li><strong>左指针（left）</strong>：窗口的左边界</li>
<li><strong>右指针（right）</strong>：窗口的右边界</li>
<li><strong>窗口</strong>：left 和 right 之间的区间</li>
</ul>
<p>通过移动这两个指针，我们可以：</p>
<ol>
<li>扩大窗口：移动 right 指针</li>
<li>缩小窗口：移动 left 指针</li>
<li>保持窗口大小：同时移动 left 和 right</li>
</ol>
<h2 id="滑动窗口的核心思想"><a class="header-anchor" href="#滑动窗口的核心思想">¶</a>滑动窗口的核心思想</h2>
<p>滑动窗口之所以高效，是因为它利用了问题的两个关键特性：</p>
<h3 id="重复子问题"><a class="header-anchor" href="#重复子问题">¶</a>重复子问题</h3>
<p>当我们计算窗口 <code>[left, right]</code> 的信息时，窗口 <code>[left+1, right+1]</code> 的信息可以通过增量更新的方式得到，而不需要重新计算整个窗口。例如，如果我们要计算窗口内元素的和，当窗口向右滑动一位时，新窗口的和 = 旧窗口的和 - 移除的元素 + 新加入的元素。</p>
<h3 id="单调性"><a class="header-anchor" href="#单调性">¶</a>单调性</h3>
<p>在很多问题中，窗口的某些性质（如和、最大值、字符种类数等）会随着窗口的扩大或缩小呈现单调性。例如：</p>
<ul>
<li>窗口越大，和越大（非负数组）</li>
<li>窗口越大，包含的字符种类越多</li>
<li>窗口越大，最大值不会变小（非严格单调）</li>
</ul>
<p>利用这些特性，我们可以用 $O(n)$ 的时间复杂度解决原本需要 $O(n^2)$ 或更高复杂度的问题。</p>
<h2 id="固定窗口大小问题"><a class="header-anchor" href="#固定窗口大小问题">¶</a>固定窗口大小问题</h2>
<p>固定窗口大小的问题相对简单，因为窗口的大小是预先确定的。我们只需要维护一个固定大小的窗口，在数组上滑动，并记录每个窗口的某些属性（如和、最大值、平均值等）。</p>
<h3 id="模板代码"><a class="header-anchor" href="#模板代码">¶</a>模板代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fixed_window</span>(<span class="params">nums, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    固定窗口大小为 k 的模板</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt; k:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 初始化窗口 [0, k-1]</span></span><br><span class="line">    window_sum = <span class="built_in">sum</span>(nums[:k])</span><br><span class="line">    result = [window_sum]</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">        <span class="comment"># 移除左边界元素，加入右边界元素</span></span><br><span class="line">        window_sum = window_sum - nums[i - k] + nums[i]</span><br><span class="line">        result.append(window_sum)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="例题：子数组最大平均值"><a class="header-anchor" href="#例题：子数组最大平均值">¶</a>例题：子数组最大平均值</h3>
<p><strong>LeetCode 643. 子数组最大平均值</strong></p>
<p>给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code>，找出长度为 <code>k</code> 的连续子数组的最大平均值。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,12,-5,-6,50,3], k = 4</span><br><span class="line">输出: 12.75</span><br><span class="line">解释: 最大平均值 (12-5-6+50)/4 = 51/4 = 12.75</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong>：</p>
<ol>
<li>维护一个大小为 <code>k</code> 的窗口</li>
<li>计算每个窗口的平均值</li>
<li>返回最大值</li>
</ol>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findMaxAverage</span>(<span class="params">nums, k</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 计算第一个窗口的和</span></span><br><span class="line">    window_sum = <span class="built_in">sum</span>(nums[:k])</span><br><span class="line">    max_sum = window_sum</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">        window_sum = window_sum - nums[i - k] + nums[i]</span><br><span class="line">        max_sum = <span class="built_in">max</span>(max_sum, window_sum)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max_sum / k</span><br></pre></td></tr></table></figure>
<p><strong>Java 实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMaxAverage</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">windowSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计算第一个窗口的和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        windowSum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> windowSum;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; n; i++) &#123;</span><br><span class="line">        windowSum = windowSum - nums[i - k] + nums[i];</span><br><span class="line">        maxSum = Math.max(maxSum, windowSum);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>) maxSum / k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：$O(n)$，每个元素最多被访问两次（一次加入窗口，一次移出窗口）<br>
<strong>空间复杂度</strong>：$O(1)$，只使用了常数额外空间</p>
<h3 id="例题：大小为-K-且平均值大于等于阈值的子数组数目"><a class="header-anchor" href="#例题：大小为-K-且平均值大于等于阈值的子数组数目">¶</a>例题：大小为 K 且平均值大于等于阈值的子数组数目</h3>
<p><strong>LeetCode 1343. 大小为 K 且平均值大于等于阈值的子数组数目</strong></p>
<p>给你一个整数数组 <code>arr</code> 和两个整数 <code>k</code> 和 <code>threshold</code>，返回长度为 <code>k</code> 且平均值大于等于 <code>threshold</code> 的子数组数目。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4</span><br><span class="line">输出: 3</span><br><span class="line">解释: 子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4, 5 和 6。</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong>：</p>
<ol>
<li>维护大小为 <code>k</code> 的窗口</li>
<li>计算每个窗口的和</li>
<li>如果窗口和 &gt;= <code>threshold * k</code>，计数加一</li>
</ol>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numOfSubarrays</span>(<span class="params">arr, k, threshold</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    window_sum = <span class="built_in">sum</span>(arr[:k])</span><br><span class="line">    count = <span class="number">1</span> <span class="keyword">if</span> window_sum &gt;= k * threshold <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">        window_sum = window_sum - arr[i - k] + arr[i]</span><br><span class="line">        <span class="keyword">if</span> window_sum &gt;= k * threshold:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h2 id="可变窗口大小问题"><a class="header-anchor" href="#可变窗口大小问题">¶</a>可变窗口大小问题</h2>
<p>可变窗口大小的问题更加灵活，窗口的大小会根据问题的约束条件动态调整。这类问题通常需要找到满足某种条件的最长或最短子数组/子串。</p>
<h3 id="两种常见模式"><a class="header-anchor" href="#两种常见模式">¶</a>两种常见模式</h3>
<h4 id="模式一：寻找最长子串-子数组"><a class="header-anchor" href="#模式一：寻找最长子串-子数组">¶</a>模式一：寻找最长子串/子数组</h4>
<p>这类问题的目标是找到满足条件的最长子串。通常的做法是：</p>
<ol>
<li>不断扩大窗口（移动 right）</li>
<li>当窗口不满足条件时，缩小窗口（移动 left）</li>
<li>在窗口满足条件时，更新答案</li>
</ol>
<h4 id="模式二：寻找最短子串-子数组"><a class="header-anchor" href="#模式二：寻找最短子串-子数组">¶</a>模式二：寻找最短子串/子数组</h4>
<p>这类问题的目标是找到满足条件的最短子串。通常的做法是：</p>
<ol>
<li>不断扩大窗口（移动 right），直到满足条件</li>
<li>一旦满足条件，尝试缩小窗口（移动 left），寻找更短的解</li>
<li>更新答案</li>
</ol>
<h3 id="模板代码-v2"><a class="header-anchor" href="#模板代码-v2">¶</a>模板代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_window_template</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    可变窗口大小的通用模板</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    result = <span class="number">0</span>  <span class="comment"># 或 result = []</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 用于记录窗口状态的变量</span></span><br><span class="line">    window = &#123;&#125;  <span class="comment"># 或 window = []</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># 扩大窗口：加入 s[right]</span></span><br><span class="line">        window[s[right]] = window.get(s[right], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 判断窗口是否需要收缩</span></span><br><span class="line">        <span class="keyword">while</span> window_needs_shrink(window):</span><br><span class="line">            <span class="comment"># 缩小窗口：移除 s[left]</span></span><br><span class="line">            window[s[left]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> window[s[left]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> window[s[left]]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 更新答案</span></span><br><span class="line">        result = update_result(result, left, right)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="经典题目详解"><a class="header-anchor" href="#经典题目详解">¶</a>经典题目详解</h2>
<h3 id="题目一：无重复字符的最长子串"><a class="header-anchor" href="#题目一：无重复字符的最长子串">¶</a>题目一：无重复字符的最长子串</h3>
<p><strong>LeetCode 3. 无重复字符的最长子串</strong></p>
<p>给定一个字符串 <code>s</code>，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p><strong>思路分析</strong>：</p>
<p>这是一个典型的&quot;寻找最长子串&quot;问题。我们需要：</p>
<ol>
<li>维护一个窗口，窗口内的字符都不重复</li>
<li>用哈希表记录窗口中每个字符的出现次数</li>
<li>当窗口中出现重复字符时，缩小窗口（移动 left），直到没有重复字符</li>
<li>在窗口没有重复字符时，更新最长长度</li>
</ol>
<p><strong>详细步骤</strong>：</p>
<p>以 <code>s = &quot;abcabcbb&quot;</code> 为例：</p>
<ol>
<li>
<p><strong>初始化</strong>：<code>left = 0</code>，<code>right = 0</code>，<code>max_len = 0</code>，<code>char_count = &#123;&#125;</code></p>
</li>
<li>
<p><strong>right = 0</strong>：加入 <code>'a'</code></p>
<ul>
<li><code>char_count = &#123;'a': 1&#125;</code></li>
<li>窗口 <code>[0, 0]</code>：<code>&quot;a&quot;</code>，无重复，<code>max_len = 1</code></li>
</ul>
</li>
<li>
<p><strong>right = 1</strong>：加入 <code>'b'</code></p>
<ul>
<li><code>char_count = &#123;'a': 1, 'b': 1&#125;</code></li>
<li>窗口 <code>[0, 1]</code>：<code>&quot;ab&quot;</code>，无重复，<code>max_len = 2</code></li>
</ul>
</li>
<li>
<p><strong>right = 2</strong>：加入 <code>'c'</code></p>
<ul>
<li><code>char_count = &#123;'a': 1, 'b': 1, 'c': 1&#125;</code></li>
<li>窗口 <code>[0, 2]</code>：<code>&quot;abc&quot;</code>，无重复，<code>max_len = 3</code></li>
</ul>
</li>
<li>
<p><strong>right = 3</strong>：加入 <code>'a'</code></p>
<ul>
<li><code>char_count = &#123;'a': 2, 'b': 1, 'c': 1&#125;</code>（出现重复！）</li>
<li>缩小窗口：移动 left，直到 <code>'a'</code> 只出现一次</li>
<li><code>left = 1</code>：移除 <code>s[0] = 'a'</code>，<code>char_count = &#123;'a': 1, 'b': 1, 'c': 1&#125;</code></li>
<li>窗口 <code>[1, 3]</code>：<code>&quot;bca&quot;</code>，无重复，<code>max_len = 3</code></li>
</ul>
</li>
<li>
<p><strong>right = 4</strong>：加入 <code>'b'</code></p>
<ul>
<li><code>char_count = &#123;'a': 1, 'b': 2, 'c': 1&#125;</code>（出现重复！）</li>
<li>缩小窗口：<code>left = 2</code>，移除 <code>s[1] = 'b'</code></li>
<li>窗口 <code>[2, 4]</code>：<code>&quot;cab&quot;</code>，无重复，<code>max_len = 3</code></li>
</ul>
</li>
<li>
<p>继续这个过程…</p>
</li>
</ol>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    char_count = &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># 加入右边界字符</span></span><br><span class="line">        char_count[s[right]] = char_count.get(s[right], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 如果出现重复字符，缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span> char_count[s[right]] &gt; <span class="number">1</span>:</span><br><span class="line">            char_count[s[left]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> char_count[s[left]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> char_count[s[left]]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 更新最长长度</span></span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<p><strong>Java 实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character, Integer&gt; charCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        charCount.put(c, charCount.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果出现重复字符，缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span> (charCount.get(c) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">leftChar</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            charCount.put(leftChar, charCount.get(leftChar) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (charCount.get(leftChar) == <span class="number">0</span>) &#123;</span><br><span class="line">                charCount.remove(leftChar);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        maxLen = Math.max(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：$O(n)$，每个字符最多被访问两次（一次加入窗口，一次移出窗口）<br>
<strong>空间复杂度</strong>：$O(min(n, m))$，其中 $m$ 是字符集的大小</p>
<h3 id="题目二：最小覆盖子串"><a class="header-anchor" href="#题目二：最小覆盖子串">¶</a>题目二：最小覆盖子串</h3>
<p><strong>LeetCode 76. 最小覆盖子串</strong></p>
<p>给你一个字符串 <code>s</code>、一个字符串 <code>t</code>。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出: &quot;BANC&quot;</span><br><span class="line">解释: 最小覆盖子串 &quot;BANC&quot; 包含 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br></pre></td></tr></table></figure>
<p><strong>思路分析</strong>：</p>
<p>这是一个&quot;寻找最短子串&quot;问题。我们需要：</p>
<ol>
<li>用哈希表记录 <code>t</code> 中每个字符需要的数量</li>
<li>维护一个窗口，不断扩大窗口直到包含 <code>t</code> 的所有字符</li>
<li>一旦窗口满足条件，尝试缩小窗口，寻找更短的解</li>
<li>记录满足条件的最短窗口</li>
</ol>
<p><strong>详细步骤</strong>：</p>
<p>以 <code>s = &quot;ADOBECODEBANC&quot;</code>，<code>t = &quot;ABC&quot;</code> 为例：</p>
<ol>
<li>
<p><strong>初始化</strong>：</p>
<ul>
<li><code>need = &#123;'A': 1, 'B': 1, 'C': 1&#125;</code>（<code>t</code> 中每个字符需要的数量）</li>
<li><code>window = &#123;&#125;</code>（窗口中每个字符的数量）</li>
<li><code>valid = 0</code>（窗口中满足 <code>need</code> 条件的字符种类数）</li>
<li><code>left = 0</code>，<code>right = 0</code></li>
<li><code>start = 0</code>，<code>min_len = float('inf')</code></li>
</ul>
</li>
<li>
<p><strong>扩大窗口</strong>：</p>
<ul>
<li><code>right = 0</code>：加入 <code>'A'</code>，<code>window = &#123;'A': 1&#125;</code>，<code>valid = 1</code>（<code>'A'</code> 满足条件）</li>
<li><code>right = 1</code>：加入 <code>'D'</code>，<code>window = &#123;'A': 1, 'D': 1&#125;</code>，<code>valid = 1</code></li>
<li><code>right = 2</code>：加入 <code>'O'</code>，<code>window = &#123;'A': 1, 'D': 1, 'O': 1&#125;</code>，<code>valid = 1</code></li>
<li><code>right = 3</code>：加入 <code>'B'</code>，<code>window = &#123;'A': 1, 'B': 1, 'D': 1, 'O': 1&#125;</code>，<code>valid = 2</code>（<code>'B'</code> 满足条件）</li>
<li><code>right = 4</code>：加入 <code>'E'</code>，<code>window = &#123;'A': 1, 'B': 1, 'D': 1, 'E': 1, 'O': 1&#125;</code>，<code>valid = 2</code></li>
<li><code>right = 5</code>：加入 <code>'C'</code>，<code>window = &#123;'A': 1, 'B': 1, 'C': 1, 'D': 1, 'E': 1, 'O': 1&#125;</code>，<code>valid = 3</code>（所有字符都满足条件！）</li>
</ul>
</li>
<li>
<p><strong>缩小窗口</strong>（<code>valid == len(need)</code>）：</p>
<ul>
<li>当前窗口 <code>[0, 5]</code>：<code>&quot;ADOBEC&quot;</code>，长度为 6</li>
<li>尝试缩小：<code>left = 0</code>，移除 <code>'A'</code>，但 <code>'A'</code> 是必需的，不能移除</li>
<li>实际上，我们需要检查移除字符后是否还满足条件</li>
<li>正确的做法：当 <code>window[s[left]] &gt; need.get(s[left], 0)</code> 时，可以移除</li>
</ul>
</li>
<li>
<p><strong>继续扩大窗口</strong>：</p>
<ul>
<li><code>right = 6</code>：加入 <code>'O'</code>…</li>
<li>当窗口再次满足条件时，尝试缩小并更新答案</li>
</ul>
</li>
</ol>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">s, t</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> t:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 记录 t 中每个字符需要的数量</span></span><br><span class="line">    need = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">        need[c] = need.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 记录窗口中每个字符的数量</span></span><br><span class="line">    window = &#123;&#125;</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    valid = <span class="number">0</span>  <span class="comment"># 窗口中满足 need 条件的字符种类数</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        c = s[right]</span><br><span class="line">        <span class="comment"># 扩大窗口</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> need:</span><br><span class="line">            window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                valid += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 判断窗口是否需要收缩</span></span><br><span class="line">        <span class="keyword">while</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">            <span class="comment"># 更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> right - left + <span class="number">1</span> &lt; min_len:</span><br><span class="line">                start = left</span><br><span class="line">                min_len = right - left + <span class="number">1</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment"># 缩小窗口</span></span><br><span class="line">            d = s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                    valid -= <span class="number">1</span></span><br><span class="line">                window[d] -= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span> <span class="keyword">if</span> min_len == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> s[start:start + min_len]</span><br></pre></td></tr></table></figure>
<p><strong>Java 实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || t == <span class="literal">null</span> || s.length() == <span class="number">0</span> || t.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 记录 t 中每个字符需要的数量</span></span><br><span class="line">    Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 记录窗口中每个字符的数量</span></span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 窗口中满足 need 条件的字符种类数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="comment">// 扩大窗口</span></span><br><span class="line">        <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (window.get(c).equals(need.get(c))) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 判断窗口是否需要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.size()) &#123;</span><br><span class="line">            <span class="comment">// 更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; minLen) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                minLen = right - left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window.get(d).equals(need.get(d))) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + minLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：$O(|s| + |t|)$，其中 $|s|$ 和 $|t|$ 分别是字符串 <code>s</code> 和 <code>t</code> 的长度<br>
<strong>空间复杂度</strong>：$O(|s| + |t|)$，用于存储哈希表</p>
<h3 id="题目三：长度最小的子数组"><a class="header-anchor" href="#题目三：长度最小的子数组">¶</a>题目三：长度最小的子数组</h3>
<p><strong>LeetCode 209. 长度最小的子数组</strong></p>
<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code>，找出该数组中满足其和 <code>≥ target</code> 的长度最小的<strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>
<p><strong>思路分析</strong>：</p>
<p>这是一个&quot;寻找最短子数组&quot;问题。我们需要：</p>
<ol>
<li>维护一个窗口，不断扩大窗口直到窗口和 <code>≥ target</code></li>
<li>一旦满足条件，尝试缩小窗口，寻找更短的解</li>
<li>记录满足条件的最短长度</li>
</ol>
<p><strong>详细步骤</strong>：</p>
<p>以 <code>target = 7</code>，<code>nums = [2,3,1,2,4,3]</code> 为例：</p>
<ol>
<li>
<p><strong>初始化</strong>：<code>left = 0</code>，<code>right = 0</code>，<code>window_sum = 0</code>，<code>min_len = float('inf')</code></p>
</li>
<li>
<p><strong>扩大窗口</strong>：</p>
<ul>
<li><code>right = 0</code>：加入 <code>2</code>，<code>window_sum = 2</code>，窗口 <code>[0, 0]</code>：<code>[2]</code>，和 &lt; 7</li>
<li><code>right = 1</code>：加入 <code>3</code>，<code>window_sum = 5</code>，窗口 <code>[0, 1]</code>：<code>[2,3]</code>，和 &lt; 7</li>
<li><code>right = 2</code>：加入 <code>1</code>，<code>window_sum = 6</code>，窗口 <code>[0, 2]</code>：<code>[2,3,1]</code>，和 &lt; 7</li>
<li><code>right = 3</code>：加入 <code>2</code>，<code>window_sum = 8</code>，窗口 <code>[0, 3]</code>：<code>[2,3,1,2]</code>，和 ≥ 7！</li>
</ul>
</li>
<li>
<p><strong>缩小窗口</strong>：</p>
<ul>
<li>当前窗口 <code>[0, 3]</code> 长度为 4，<code>min_len = 4</code></li>
<li><code>left = 0</code>：移除 <code>2</code>，<code>window_sum = 6</code>，窗口 <code>[1, 3]</code>：<code>[3,1,2]</code>，和 &lt; 7，停止缩小</li>
<li>继续扩大窗口…</li>
</ul>
</li>
<li>
<p><strong>继续过程</strong>：</p>
<ul>
<li><code>right = 4</code>：加入 <code>4</code>，<code>window_sum = 10</code>，窗口 <code>[1, 4]</code>：<code>[3,1,2,4]</code>，和 ≥ 7</li>
<li>缩小：<code>left = 1</code>，移除 <code>3</code>，<code>window_sum = 7</code>，窗口 <code>[2, 4]</code>：<code>[1,2,4]</code>，和 ≥ 7</li>
<li>缩小：<code>left = 2</code>，移除 <code>1</code>，<code>window_sum = 6</code>，和 &lt; 7，停止</li>
<li><code>min_len = min(4, 3) = 3</code></li>
</ul>
</li>
<li>
<p><strong>最终</strong>：<code>right = 5</code>，加入 <code>3</code>，<code>window_sum = 9</code>，窗口 <code>[2, 5]</code>：<code>[2,4,3]</code>，和 ≥ 7</p>
<ul>
<li>缩小：<code>left = 2</code>，移除 <code>2</code>，<code>window_sum = 7</code>，窗口 <code>[3, 5]</code>：<code>[4,3]</code>，和 ≥ 7</li>
<li>缩小：<code>left = 3</code>，移除 <code>4</code>，<code>window_sum = 3</code>，和 &lt; 7，停止</li>
<li><code>min_len = min(3, 2) = 2</code></li>
</ul>
</li>
</ol>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">target, nums</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    window_sum = <span class="number">0</span></span><br><span class="line">    min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># 扩大窗口</span></span><br><span class="line">        window_sum += nums[right]</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 当窗口和满足条件时，尝试缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span> window_sum &gt;= target:</span><br><span class="line">            min_len = <span class="built_in">min</span>(min_len, right - left + <span class="number">1</span>)</span><br><span class="line">            window_sum -= nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> min_len == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> min_len</span><br></pre></td></tr></table></figure>
<p><strong>Java 实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">windowSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">        <span class="comment">// 扩大窗口</span></span><br><span class="line">        windowSum += nums[right];</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 当窗口和满足条件时，尝试缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span> (windowSum &gt;= target) &#123;</span><br><span class="line">            minLen = Math.min(minLen, right - left + <span class="number">1</span>);</span><br><span class="line">            windowSum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：$O(n)$，每个元素最多被访问两次<br>
<strong>空间复杂度</strong>：$O(1)$</p>
<h3 id="题目四：字符串的排列"><a class="header-anchor" href="#题目四：字符串的排列">¶</a>题目四：字符串的排列</h3>
<p><strong>LeetCode 567. 字符串的排列</strong></p>
<p>给你两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回 <code>true</code>；否则，返回 <code>false</code>。</p>
<p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的<strong>子串</strong>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure>
<p><strong>思路分析</strong>：</p>
<p>这个问题可以转化为：在 <code>s2</code> 中是否存在一个长度为 <code>len(s1)</code> 的子串，其字符频率与 <code>s1</code> 完全相同。</p>
<p>我们可以：</p>
<ol>
<li>用固定大小的窗口（大小为 <code>len(s1)</code>）在 <code>s2</code> 上滑动</li>
<li>对于每个窗口，检查窗口内字符的频率是否与 <code>s1</code> 相同</li>
<li>如果相同，返回 <code>true</code></li>
</ol>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s1) &gt; <span class="built_in">len</span>(s2):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 记录 s1 中每个字符需要的数量</span></span><br><span class="line">    need = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s1:</span><br><span class="line">        need[c] = need.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 记录窗口中每个字符的数量</span></span><br><span class="line">    window = &#123;&#125;</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 初始化窗口 [0, len(s1)-1]</span></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)):</span><br><span class="line">        c = s2[right]</span><br><span class="line">        window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 检查第一个窗口</span></span><br><span class="line">    <span class="keyword">if</span> window == need:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)):</span><br><span class="line">        <span class="comment"># 加入右边界字符</span></span><br><span class="line">        c = s2[right]</span><br><span class="line">        window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 移除左边界字符</span></span><br><span class="line">        d = s2[left]</span><br><span class="line">        window[d] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> window[d] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">del</span> window[d]</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 检查窗口</span></span><br><span class="line">        <span class="keyword">if</span> window == need:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>优化版本</strong>（使用 valid 计数，避免每次比较整个字典）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s1) &gt; <span class="built_in">len</span>(s2):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">    need = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s1:</span><br><span class="line">        need[c] = need.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    window = &#123;&#125;</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    valid = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2)):</span><br><span class="line">        c = s2[right]</span><br><span class="line">        <span class="comment"># 扩大窗口</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> need:</span><br><span class="line">            window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                valid += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 如果窗口大小超过 len(s1)，缩小窗口</span></span><br><span class="line">        <span class="keyword">if</span> right - left + <span class="number">1</span> &gt; <span class="built_in">len</span>(s1):</span><br><span class="line">            d = s2[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                    valid -= <span class="number">1</span></span><br><span class="line">                window[d] -= <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 检查是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>Java 实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() &gt; s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s1.toCharArray()) &#123;</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s2.length(); right++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s2.charAt(right);</span><br><span class="line">        <span class="comment">// 扩大窗口</span></span><br><span class="line">        <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (window.get(c).equals(need.get(c))) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果窗口大小超过 len(s1)，缩小窗口</span></span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; s1.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s2.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window.get(d).equals(need.get(d))) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 检查是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (valid == need.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：$O(|s1| + |s2|)$<br>
<strong>空间复杂度</strong>：$O(|s1|)$</p>
<h3 id="题目五：找到字符串中所有字母异位词"><a class="header-anchor" href="#题目五：找到字符串中所有字母异位词">¶</a>题目五：找到字符串中所有字母异位词</h3>
<p><strong>LeetCode 438. 找到字符串中所有字母异位词</strong></p>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的<strong>字母异位词</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>字母异位词指字母相同，但排列不同的字符串。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br></pre></td></tr></table></figure>
<p><strong>思路分析</strong>：</p>
<p>这个问题与上一题非常相似，区别在于：</p>
<ul>
<li>上一题只需要判断是否存在，这一题需要找到所有满足条件的起始索引</li>
<li>窗口大小固定为 <code>len(p)</code></li>
<li>对于每个满足条件的窗口，记录其起始索引</li>
</ul>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">s, p</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">  </span><br><span class="line">    need = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> p:</span><br><span class="line">        need[c] = need.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    window = &#123;&#125;</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    valid = <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        c = s[right]</span><br><span class="line">        <span class="comment"># 扩大窗口</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> need:</span><br><span class="line">            window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                valid += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 如果窗口大小超过 len(p)，缩小窗口</span></span><br><span class="line">        <span class="keyword">if</span> right - left + <span class="number">1</span> &gt; <span class="built_in">len</span>(p):</span><br><span class="line">            d = s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                    valid -= <span class="number">1</span></span><br><span class="line">                window[d] -= <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 检查是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> valid == <span class="built_in">len</span>(need) <span class="keyword">and</span> right - left + <span class="number">1</span> == <span class="built_in">len</span>(p):</span><br><span class="line">            result.append(left)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Java 实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (p.length() &gt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : p.toCharArray()) &#123;</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="comment">// 扩大窗口</span></span><br><span class="line">        <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (window.get(c).equals(need.get(c))) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果窗口大小超过 len(p)，缩小窗口</span></span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; p.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window.get(d).equals(need.get(d))) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 检查是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (valid == need.size() &amp;&amp; right - left + <span class="number">1</span> == p.length()) &#123;</span><br><span class="line">            result.add(left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：$O(|s| + |p|)$<br>
<strong>空间复杂度</strong>：$O(|p|)$</p>
<h2 id="时间复杂度分析-v3"><a class="header-anchor" href="#时间复杂度分析-v3">¶</a>时间复杂度分析</h2>
<p>滑动窗口算法的时间复杂度分析有一个通用的方法：</p>
<h3 id="基本分析"><a class="header-anchor" href="#基本分析">¶</a>基本分析</h3>
<p>对于滑动窗口算法：</p>
<ul>
<li><strong>外层循环</strong>：<code>right</code> 指针从 <code>0</code> 移动到 <code>n-1</code>，共 $n$ 次迭代</li>
<li><strong>内层循环</strong>：<code>left</code> 指针的移动</li>
</ul>
<p>关键在于：虽然有一个 <code>while</code> 循环，但 <code>left</code> 指针<strong>只会向前移动，不会后退</strong>。因此，在整个算法执行过程中：</p>
<ul>
<li><code>right</code> 指针移动了 $n$ 次</li>
<li><code>left</code> 指针最多移动 $n$ 次</li>
</ul>
<p>所以总的时间复杂度是 $O(n)$，而不是 $O(n^2)$。</p>
<h3 id="摊还分析（Amortized-Analysis）"><a class="header-anchor" href="#摊还分析（Amortized-Analysis）">¶</a>摊还分析（Amortized Analysis）</h3>
<p>我们可以用摊还分析来更严格地证明：</p>
<p>设 <code>right</code> 移动了 $n$ 次，<code>left</code> 移动了 $m$ 次。由于 <code>left</code> 不会超过 <code>right</code>，所以 $m \leq n$。</p>
<p>总操作数 = <code>right</code> 移动次数 + <code>left</code> 移动次数 = $n + m \leq 2n = O(n)$</p>
<p>因此，每个元素的摊还时间复杂度是 $O(1)$，总时间复杂度是 $O(n)$。</p>
<h3 id="不同情况的时间复杂度"><a class="header-anchor" href="#不同情况的时间复杂度">¶</a>不同情况的时间复杂度</h3>
<ol>
<li>
<p><strong>固定窗口大小</strong>：$O(n)$</p>
<ul>
<li>每个元素被访问两次（一次加入，一次移出）</li>
</ul>
</li>
<li>
<p><strong>可变窗口大小（最长子串）</strong>：$O(n)$</p>
<ul>
<li>每个元素最多被访问两次</li>
</ul>
</li>
<li>
<p><strong>可变窗口大小（最短子串）</strong>：$O(n)$</p>
<ul>
<li>每个元素最多被访问两次</li>
</ul>
</li>
<li>
<p><strong>需要排序或复杂操作</strong>：可能更高</p>
<ul>
<li>例如，如果窗口内需要维护有序结构，可能是 $O(n \log n)$</li>
</ul>
</li>
</ol>
<h2 id="常见陷阱与调试技巧"><a class="header-anchor" href="#常见陷阱与调试技巧">¶</a>常见陷阱与调试技巧</h2>
<h3 id="陷阱一：窗口边界处理错误"><a class="header-anchor" href="#陷阱一：窗口边界处理错误">¶</a>陷阱一：窗口边界处理错误</h3>
<p><strong>问题</strong>：窗口的左右边界 <code>[left, right]</code> 是闭区间还是左闭右开区间？</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>统一使用<strong>左闭右闭区间</strong> <code>[left, right]</code></li>
<li>窗口长度 = <code>right - left + 1</code></li>
<li>初始化时，<code>left = 0</code>，<code>right = -1</code>（空窗口）或 <code>left = 0</code>，<code>right = 0</code>（包含第一个元素）</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误：窗口长度计算错误</span></span><br><span class="line">window_len = right - left  <span class="comment"># 应该是 right - left + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确</span></span><br><span class="line">window_len = right - left + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="陷阱二：哈希表更新时机错误"><a class="header-anchor" href="#陷阱二：哈希表更新时机错误">¶</a>陷阱二：哈希表更新时机错误</h3>
<p><strong>问题</strong>：在缩小窗口时，忘记更新哈希表，或者在更新哈希表之前就检查条件。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>先更新窗口状态（加入/移除元素）</li>
<li>再检查窗口是否满足条件</li>
<li>最后更新答案</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误：先检查条件，再更新窗口</span></span><br><span class="line"><span class="keyword">if</span> window_satisfies_condition():</span><br><span class="line">    update_answer()</span><br><span class="line">    window.remove(s[left])  <span class="comment"># 错误：应该在检查之前更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：先更新窗口，再检查条件</span></span><br><span class="line">window.add(s[right])</span><br><span class="line"><span class="keyword">if</span> window_satisfies_condition():</span><br><span class="line">    update_answer()</span><br><span class="line">window.remove(s[left])</span><br></pre></td></tr></table></figure>
<h3 id="陷阱三：valid-计数更新错误"><a class="header-anchor" href="#陷阱三：valid-计数更新错误">¶</a>陷阱三：valid 计数更新错误</h3>
<p><strong>问题</strong>：在使用 <code>valid</code> 计数优化时，更新 <code>valid</code> 的时机不对。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>当 <code>window[c] == need[c]</code> 时，<code>valid++</code></li>
<li>当 <code>window[c]</code> 从 <code>need[c]</code> 变为 <code>need[c] - 1</code> 时，<code>valid--</code></li>
<li>注意：只有当 <code>window[c]</code> <strong>恰好等于</strong> <code>need[c]</code> 时，才计入 <code>valid</code></li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误：没有检查是否恰好相等</span></span><br><span class="line"><span class="keyword">if</span> window[c] &gt;= need[c]:  <span class="comment"># 错误：可能重复计数</span></span><br><span class="line">    valid += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：检查是否恰好相等</span></span><br><span class="line"><span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">    valid += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="陷阱四：空窗口或边界条件"><a class="header-anchor" href="#陷阱四：空窗口或边界条件">¶</a>陷阱四：空窗口或边界条件</h3>
<p><strong>问题</strong>：没有处理空字符串、空数组、窗口大小为 0 等边界情况。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>在函数开始处检查边界条件</li>
<li>确保窗口大小至少为 1（如果需要）</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_window</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:  <span class="comment"># 处理空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; k:  <span class="comment"># 处理窗口大小大于字符串长度的情况</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># ... 主逻辑</span></span><br></pre></td></tr></table></figure>
<h3 id="调试技巧-v4"><a class="header-anchor" href="#调试技巧-v4">¶</a>调试技巧</h3>
<ol>
<li><strong>打印窗口状态</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_window</span>(<span class="params">s</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># 打印当前窗口</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;窗口 [<span class="subst">&#123;left&#125;</span>, <span class="subst">&#123;right&#125;</span>]: <span class="subst">&#123;s[left:right+<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;窗口状态: <span class="subst">&#123;window&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># ... 其他逻辑</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>使用断言检查不变量</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查窗口大小</span></span><br><span class="line"><span class="keyword">assert</span> right - left + <span class="number">1</span> &gt;= <span class="number">0</span>, <span class="string">&quot;窗口大小不能为负&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 valid 计数</span></span><br><span class="line"><span class="keyword">assert</span> valid &lt;= <span class="built_in">len</span>(need), <span class="string">&quot;valid 不能超过 need 的大小&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p><strong>单步调试</strong>：</p>
<ul>
<li>使用调试器逐步执行</li>
<li>观察 <code>left</code>、<code>right</code>、<code>window</code>、<code>valid</code> 的变化</li>
<li>检查每个步骤是否符合预期</li>
</ul>
</li>
<li>
<p><strong>测试用例</strong>：</p>
<ul>
<li>空输入</li>
<li>单个元素</li>
<li>所有元素相同</li>
<li>无解的情况</li>
<li>多个解的情况</li>
</ul>
</li>
</ol>
<h2 id="❓-Q-A-滑动窗口常见问题"><a class="header-anchor" href="#❓-Q-A-滑动窗口常见问题">¶</a>❓ Q&amp;A: 滑动窗口常见问题</h2>
<h3 id="Q1-什么时候应该使用滑动窗口？"><a class="header-anchor" href="#Q1-什么时候应该使用滑动窗口？">¶</a>Q1: 什么时候应该使用滑动窗口？</h3>
<p><strong>A</strong>: 当你遇到以下关键词时，可以考虑滑动窗口：</p>
<ul>
<li><strong>连续子数组/子串</strong>：问题要求找到连续的区间</li>
<li><strong>最长/最短</strong>：需要找到满足条件的最长或最短区间</li>
<li><strong>固定大小</strong>：窗口大小固定（如长度为 k 的子数组）</li>
<li><strong>包含/不包含</strong>：窗口需要包含或不包含某些元素</li>
</ul>
<p>典型场景：</p>
<ul>
<li>字符串匹配、子串查找</li>
<li>数组中的连续子数组问题</li>
<li>需要维护窗口内某些统计信息的问题</li>
</ul>
<h3 id="Q2-滑动窗口和双指针有什么区别？"><a class="header-anchor" href="#Q2-滑动窗口和双指针有什么区别？">¶</a>Q2: 滑动窗口和双指针有什么区别？</h3>
<p><strong>A</strong>: 滑动窗口是双指针技巧的一种特殊应用：</p>
<ul>
<li><strong>双指针</strong>：两个指针可以以任意方式移动（同向、反向、快慢指针等）</li>
<li><strong>滑动窗口</strong>：两个指针（left 和 right）维护一个连续的区间，通常 right 先移动，left 后移动</li>
</ul>
<p>滑动窗口可以看作是一种<strong>约束更严格的双指针</strong>，专门用于解决连续区间问题。</p>
<h3 id="Q3-如何判断窗口应该扩大还是缩小？"><a class="header-anchor" href="#Q3-如何判断窗口应该扩大还是缩小？">¶</a>Q3: 如何判断窗口应该扩大还是缩小？</h3>
<p><strong>A</strong>: 这取决于问题的目标：</p>
<p><strong>寻找最长子串/子数组</strong>：</p>
<ul>
<li>先扩大窗口（移动 right），直到窗口不满足条件</li>
<li>然后缩小窗口（移动 left），直到窗口再次满足条件</li>
<li>在窗口满足条件时更新答案</li>
</ul>
<p><strong>寻找最短子串/子数组</strong>：</p>
<ul>
<li>先扩大窗口（移动 right），直到窗口满足条件</li>
<li>然后缩小窗口（移动 left），尝试找到更短的解</li>
<li>在窗口满足条件时更新答案</li>
</ul>
<p><strong>固定窗口大小</strong>：</p>
<ul>
<li>同时移动 left 和 right，保持窗口大小不变</li>
</ul>
<h3 id="Q4-为什么滑动窗口的时间复杂度是-O-n-而不是-O-n²-？"><a class="header-anchor" href="#Q4-为什么滑动窗口的时间复杂度是-O-n-而不是-O-n²-？">¶</a>Q4: 为什么滑动窗口的时间复杂度是 O(n) 而不是 O(n²)？</h3>
<p><strong>A</strong>: 关键在于 <code>left</code> 指针<strong>只会向前移动，不会后退</strong>。</p>
<p>虽然有一个 <code>while</code> 循环，但：</p>
<ul>
<li><code>right</code> 指针移动了 $n$ 次</li>
<li><code>left</code> 指针最多移动 $n$ 次（因为 <code>left &lt;= right</code>）</li>
</ul>
<p>总操作数 = $n + n = 2n = O(n)$</p>
<p>每个元素最多被访问两次（一次加入窗口，一次移出窗口），所以时间复杂度是 $O(n)$。</p>
<h3 id="Q5-如何处理窗口内有重复元素的情况？"><a class="header-anchor" href="#Q5-如何处理窗口内有重复元素的情况？">¶</a>Q5: 如何处理窗口内有重复元素的情况？</h3>
<p><strong>A</strong>: 这取决于问题的要求：</p>
<p><strong>不允许重复</strong>（如&quot;无重复字符的最长子串&quot;）：</p>
<ul>
<li>使用哈希表记录每个元素的出现次数</li>
<li>当某个元素出现次数 &gt; 1 时，缩小窗口直到该元素只出现一次</li>
</ul>
<p><strong>允许重复但有限制</strong>（如&quot;最多包含 k 个重复元素&quot;）：</p>
<ul>
<li>使用哈希表记录每个元素的出现次数</li>
<li>当某个元素出现次数 &gt; k 时，缩小窗口</li>
</ul>
<p><strong>完全允许重复</strong>：</p>
<ul>
<li>不需要特殊处理，按正常逻辑即可</li>
</ul>
<h3 id="Q6-valid-计数是什么？为什么要用它？"><a class="header-anchor" href="#Q6-valid-计数是什么？为什么要用它？">¶</a>Q6: valid 计数是什么？为什么要用它？</h3>
<p><strong>A</strong>: <code>valid</code> 计数用于优化窗口条件的检查。</p>
<p><strong>不使用 valid</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次都要比较整个字典，时间复杂度 O(m)，其中 m 是字符集大小</span></span><br><span class="line"><span class="keyword">if</span> window == need:</span><br><span class="line">    <span class="comment"># 满足条件</span></span><br></pre></td></tr></table></figure>
<p><strong>使用 valid</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只需要检查 valid == len(need)，时间复杂度 O(1)</span></span><br><span class="line"><span class="keyword">if</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">    <span class="comment"># 满足条件</span></span><br></pre></td></tr></table></figure>
<p><code>valid</code> 表示窗口中<strong>恰好满足 <code>need</code> 条件的字符种类数</strong>。当 <code>valid == len(need)</code> 时，说明窗口中所有需要的字符都满足条件了。</p>
<h3 id="Q7-滑动窗口可以解决哪些-LeetCode-题目？"><a class="header-anchor" href="#Q7-滑动窗口可以解决哪些-LeetCode-题目？">¶</a>Q7: 滑动窗口可以解决哪些 LeetCode 题目？</h3>
<p><strong>A</strong>: 以下是一些经典的滑动窗口题目：</p>
<p><strong>固定窗口大小</strong>：</p>
<ul>
<li>
<ol start="643">
<li>子数组最大平均值</li>
</ol>
</li>
<li>
<ol start="1343">
<li>大小为 K 且平均值大于等于阈值的子数组数目</li>
</ol>
</li>
<li>
<ol start="239">
<li>滑动窗口最大值（需要特殊数据结构）</li>
</ol>
</li>
</ul>
<p><strong>可变窗口大小（最长）</strong>：</p>
<ul>
<li>
<ol start="3">
<li>无重复字符的最长子串</li>
</ol>
</li>
<li>
<ol start="159">
<li>至多包含两个不同字符的最长子串</li>
</ol>
</li>
<li>
<ol start="340">
<li>至多包含 K 个不同字符的最长子串</li>
</ol>
</li>
</ul>
<p><strong>可变窗口大小（最短）</strong>：</p>
<ul>
<li>
<ol start="76">
<li>最小覆盖子串</li>
</ol>
</li>
<li>
<ol start="209">
<li>长度最小的子数组</li>
</ol>
</li>
<li>
<ol start="713">
<li>乘积小于K的子数组</li>
</ol>
</li>
</ul>
<p><strong>其他</strong>：</p>
<ul>
<li>
<ol start="567">
<li>字符串的排列</li>
</ol>
</li>
<li>
<ol start="438">
<li>找到字符串中所有字母异位词</li>
</ol>
</li>
<li>
<ol start="30">
<li>串联所有单词的子串</li>
</ol>
</li>
</ul>
<h3 id="Q8-滑动窗口在字符串和数组问题中有什么区别？"><a class="header-anchor" href="#Q8-滑动窗口在字符串和数组问题中有什么区别？">¶</a>Q8: 滑动窗口在字符串和数组问题中有什么区别？</h3>
<p><strong>A</strong>: 本质上没有区别，都是维护一个连续的区间。主要区别在于：</p>
<p><strong>字符串问题</strong>：</p>
<ul>
<li>通常需要处理字符频率、字符匹配等</li>
<li>可能需要使用哈希表记录字符出现次数</li>
<li>窗口大小可能固定（如找固定长度的子串）或可变</li>
</ul>
<p><strong>数组问题</strong>：</p>
<ul>
<li>通常需要处理数值和、最大值、最小值等</li>
<li>可能需要维护窗口内的统计信息（和、积等）</li>
<li>窗口大小可能固定或可变</li>
</ul>
<p>核心思路是一样的：维护窗口状态，通过移动边界来遍历所有可能的子区间。</p>
<h3 id="Q9-如何优化滑动窗口的空间复杂度？"><a class="header-anchor" href="#Q9-如何优化滑动窗口的空间复杂度？">¶</a>Q9: 如何优化滑动窗口的空间复杂度？</h3>
<p><strong>A</strong>: 几种优化方法：</p>
<ol>
<li><strong>使用数组代替哈希表</strong>（如果字符集/数值范围较小）：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果字符都是小写字母，可以用数组代替哈希表</span></span><br><span class="line">count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">count[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>原地更新</strong>（如果不需要保留原数组）：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接在原数组上操作，不创建新数组</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>只记录必要信息</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只记录窗口内需要的信息，而不是所有信息</span></span><br><span class="line"><span class="comment"># 例如，只需要记录字符频率，不需要记录字符位置</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>使用 valid 计数</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 避免每次比较整个字典，减少空间和时间开销</span></span><br></pre></td></tr></table></figure>
<h3 id="Q10-滑动窗口算法有哪些常见的变体？"><a class="header-anchor" href="#Q10-滑动窗口算法有哪些常见的变体？">¶</a>Q10: 滑动窗口算法有哪些常见的变体？</h3>
<p><strong>A</strong>: 常见的变体包括：</p>
<ol>
<li>
<p><strong>多指针滑动窗口</strong>：</p>
<ul>
<li>使用三个或更多指针维护多个窗口</li>
<li>例如：同时维护多个不同大小的窗口</li>
</ul>
</li>
<li>
<p><strong>滑动窗口 + 数据结构</strong>：</p>
<ul>
<li>窗口内需要维护有序结构（如堆、平衡树）</li>
<li>例如：239. 滑动窗口最大值（需要维护窗口内的最大值）</li>
</ul>
</li>
<li>
<p><strong>滑动窗口 + 前缀和</strong>：</p>
<ul>
<li>结合前缀和优化窗口和的计算</li>
<li>例如：560. 和为K的子数组</li>
</ul>
</li>
<li>
<p><strong>滑动窗口 + 动态规划</strong>：</p>
<ul>
<li>窗口状态需要动态规划来维护</li>
<li>例如：一些复杂的字符串匹配问题</li>
</ul>
</li>
<li>
<p><strong>滑动窗口 + 二分查找</strong>：</p>
<ul>
<li>窗口大小不确定，需要二分查找最优大小</li>
<li>例如：某些优化问题</li>
</ul>
</li>
</ol>
<h2 id="变体与扩展问题-v4"><a class="header-anchor" href="#变体与扩展问题-v4">¶</a>变体与扩展问题</h2>
<h3 id="变体一：多窗口问题"><a class="header-anchor" href="#变体一：多窗口问题">¶</a>变体一：多窗口问题</h3>
<p>有些问题需要同时维护多个窗口，或者在不同条件下使用不同的窗口策略。</p>
<p><strong>例题：至多包含两个不同字符的最长子串（LeetCode 159）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstringTwoDistinct</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">  </span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    char_count = &#123;&#125;</span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        char_count[s[right]] = char_count.get(s[right], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 当字符种类超过2时，缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(char_count) &gt; <span class="number">2</span>:</span><br><span class="line">            char_count[s[left]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> char_count[s[left]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> char_count[s[left]]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：使用 <code>len(char_count)</code> 来判断窗口内字符种类数，而不是用 <code>valid</code> 计数。</p>
<h3 id="变体二：滑动窗口-前缀和"><a class="header-anchor" href="#变体二：滑动窗口-前缀和">¶</a>变体二：滑动窗口 + 前缀和</h3>
<p>当需要快速计算窗口和时，可以结合前缀和优化。</p>
<p><strong>例题：和为 K 的子数组（LeetCode 560）</strong></p>
<p>虽然这道题通常用哈希表解决，但也可以用滑动窗口的思想理解：维护一个窗口，当窗口和等于 K 时计数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">nums, k</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    prefix_sum = <span class="number">0</span></span><br><span class="line">    sum_map = &#123;<span class="number">0</span>: <span class="number">1</span>&#125;  <span class="comment"># 前缀和为0出现1次</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        prefix_sum += num</span><br><span class="line">        <span class="comment"># 如果存在前缀和 prefix_sum - k，说明存在子数组和为 k</span></span><br><span class="line">        <span class="keyword">if</span> prefix_sum - k <span class="keyword">in</span> sum_map:</span><br><span class="line">            count += sum_map[prefix_sum - k]</span><br><span class="line">        sum_map[prefix_sum] = sum_map.get(prefix_sum, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h3 id="变体三：滑动窗口-双指针"><a class="header-anchor" href="#变体三：滑动窗口-双指针">¶</a>变体三：滑动窗口 + 双指针</h3>
<p>有些问题需要结合双指针技巧，在窗口内进行更复杂的操作。</p>
<p><strong>例题：最小区间（LeetCode 632）</strong></p>
<p>需要在多个有序数组中找到包含每个数组至少一个元素的最小区间。可以用滑动窗口的思想，配合双指针在多个数组间移动。</p>
<h3 id="扩展问题推荐"><a class="header-anchor" href="#扩展问题推荐">¶</a>扩展问题推荐</h3>
<ol>
<li>
<p><strong>困难级别</strong>：</p>
<ul>
<li>
<ol start="30">
<li>串联所有单词的子串：固定窗口大小，但需要处理单词匹配</li>
</ol>
</li>
<li>
<ol start="76">
<li>最小覆盖子串：可变窗口，需要维护字符频率</li>
</ol>
</li>
<li>
<ol start="239">
<li>滑动窗口最大值：固定窗口，需要维护最大值（用单调队列）</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>中等难度</strong>：</p>
<ul>
<li>
<ol start="159">
<li>至多包含两个不同字符的最长子串</li>
</ol>
</li>
<li>
<ol start="340">
<li>至多包含 K 个不同字符的最长子串</li>
</ol>
</li>
<li>
<ol start="424">
<li>替换后的最长重复字符</li>
</ol>
</li>
<li>
<ol start="713">
<li>乘积小于K的子数组</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>简单级别</strong>：</p>
<ul>
<li>
<ol start="643">
<li>子数组最大平均值</li>
</ol>
</li>
<li>
<ol start="1343">
<li>大小为 K 且平均值大于等于阈值的子数组数目</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="实战建议-v4"><a class="header-anchor" href="#实战建议-v4">¶</a>实战建议</h2>
<h3 id="如何快速识别滑动窗口问题"><a class="header-anchor" href="#如何快速识别滑动窗口问题">¶</a>如何快速识别滑动窗口问题</h3>
<p>看到以下关键词时，优先考虑滑动窗口：</p>
<ul>
<li><strong>连续子数组/子串</strong>：问题明确要求连续区间</li>
<li><strong>最长/最短</strong>：需要找到满足条件的最长或最短区间</li>
<li><strong>固定长度</strong>：窗口大小固定（如长度为 k）</li>
<li><strong>包含/不包含</strong>：窗口需要包含或不包含某些元素</li>
<li><strong>和/积/频率</strong>：需要维护窗口内的统计信息</li>
</ul>
<h3 id="解题步骤-v3"><a class="header-anchor" href="#解题步骤-v3">¶</a>解题步骤</h3>
<ol>
<li>
<p><strong>确定窗口类型</strong>：</p>
<ul>
<li>固定大小：窗口大小不变，同时移动左右边界</li>
<li>可变大小：先扩大窗口，满足条件后缩小</li>
</ul>
</li>
<li>
<p><strong>确定窗口状态</strong>：</p>
<ul>
<li>需要记录什么信息？（字符频率、和、最大值等）</li>
<li>用什么数据结构？（哈希表、数组、变量）</li>
</ul>
</li>
<li>
<p><strong>确定收缩条件</strong>：</p>
<ul>
<li>什么时候缩小窗口？</li>
<li>缩小到什么时候停止？</li>
</ul>
</li>
<li>
<p><strong>更新答案的时机</strong>：</p>
<ul>
<li>在扩大窗口时更新？</li>
<li>在缩小窗口时更新？</li>
<li>在满足条件时更新？</li>
</ul>
</li>
</ol>
<h3 id="常见陷阱与避免方法"><a class="header-anchor" href="#常见陷阱与避免方法">¶</a>常见陷阱与避免方法</h3>
<p><strong>陷阱一：窗口边界处理</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误：窗口长度计算错误</span></span><br><span class="line">window_len = right - left  <span class="comment"># 应该是 right - left + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确</span></span><br><span class="line">window_len = right - left + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>陷阱二：哈希表更新顺序</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误：先检查条件，再更新窗口</span></span><br><span class="line"><span class="keyword">if</span> window_satisfies_condition():</span><br><span class="line">    update_answer()</span><br><span class="line">    window.remove(s[left])  <span class="comment"># 应该在检查前更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：先更新窗口，再检查条件</span></span><br><span class="line">window.add(s[right])</span><br><span class="line"><span class="keyword">if</span> window_satisfies_condition():</span><br><span class="line">    update_answer()</span><br><span class="line">window.remove(s[left])</span><br></pre></td></tr></table></figure>
<p><strong>陷阱三：valid 计数错误</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误：没有检查是否恰好相等</span></span><br><span class="line"><span class="keyword">if</span> window[c] &gt;= need[c]:  <span class="comment"># 可能重复计数</span></span><br><span class="line">    valid += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：检查是否恰好相等</span></span><br><span class="line"><span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">    valid += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="调试技巧-v5"><a class="header-anchor" href="#调试技巧-v5">¶</a>调试技巧</h3>
<ol>
<li><strong>打印窗口状态</strong>：在关键位置打印 <code>left</code>、<code>right</code>、窗口内容、窗口状态</li>
<li><strong>单步调试</strong>：使用调试器逐步执行，观察变量变化</li>
<li><strong>测试边界情况</strong>：空输入、单个元素、所有元素相同、无解情况</li>
<li><strong>对比暴力解法</strong>：先用暴力法验证思路，再优化为滑动窗口</li>
</ol>
<h3 id="性能优化建议-v4"><a class="header-anchor" href="#性能优化建议-v4">¶</a>性能优化建议</h3>
<ol>
<li>
<p><strong>空间优化</strong>：</p>
<ul>
<li>如果字符集小（如只有小写字母），用数组代替哈希表</li>
<li>如果只需要计数，不需要具体字符，用变量代替哈希表</li>
</ul>
</li>
<li>
<p><strong>时间优化</strong>：</p>
<ul>
<li>使用 <code>valid</code> 计数避免每次比较整个字典</li>
<li>提前终止：如果已经找到最优解，可以提前结束</li>
</ul>
</li>
<li>
<p><strong>代码优化</strong>：</p>
<ul>
<li>合并相似逻辑，减少重复代码</li>
<li>使用更高效的数据结构（如 <code>collections.defaultdict</code>）</li>
</ul>
</li>
</ol>
<h2 id="总结-v8"><a class="header-anchor" href="#总结-v8">¶</a>总结</h2>
<p>滑动窗口是一种强大的算法技巧，特别适合解决连续子区间问题。掌握滑动窗口的关键在于：</p>
<ol>
<li><strong>理解核心思想</strong>：维护一个窗口，通过移动边界遍历所有可能的子区间</li>
<li><strong>识别问题模式</strong>：固定窗口大小 vs 可变窗口大小，最长 vs 最短</li>
<li><strong>掌握模板代码</strong>：理解扩大窗口、缩小窗口、更新答案的时机</li>
<li><strong>注意边界条件</strong>：空输入、窗口大小、边界处理</li>
<li><strong>优化技巧</strong>：使用 valid 计数、数组代替哈希表等</li>
</ol>
<p>通过大量练习，你会发现滑动窗口是解决 LeetCode 中很多问题的&quot;万能钥匙&quot;。记住，算法学习是一个循序渐进的过程，多思考、多练习，你一定能掌握这个技巧！</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>本文标题：LeetCode（四）—— 滑动窗口技巧</li>
        <li>本文作者：Chen Kai</li>
        <li>创建时间：2023-03-02 00:00:00</li>
        <li>
            本文链接：https://www.chenk.top/LeetCode%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/Linux-%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Linux 使用基础</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/paper2repo%EF%BC%9AGitHub-Repository-Recommendation-for-Academic-Papers/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">paper2repo：GitHub Repository Recommendation for Academic Papers</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情赞美帅气伟大的ck吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- 由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">1.</span> <span class="nav-text">什么是滑动窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">2.</span> <span class="nav-text">滑动窗口的核心思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E5%AD%90%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.</span> <span class="nav-text">重复子问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text">单调性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">固定窗口大小问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81"><span class="nav-number">3.1.</span> <span class="nav-text">模板代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9A%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="nav-number">3.2.</span> <span class="nav-text">例题：子数组最大平均值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9A%E5%A4%A7%E5%B0%8F%E4%B8%BA-K-%E4%B8%94%E5%B9%B3%E5%9D%87%E5%80%BC%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E9%98%88%E5%80%BC%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE"><span class="nav-number">3.3.</span> <span class="nav-text">例题：大小为 K 且平均值大于等于阈值的子数组数目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">可变窗口大小问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">两种常见模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%AF%BB%E6%89%BE%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">4.1.1.</span> <span class="nav-text">模式一：寻找最长子串&#x2F;子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%AF%BB%E6%89%BE%E6%9C%80%E7%9F%AD%E5%AD%90%E4%B8%B2-%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">4.1.2.</span> <span class="nav-text">模式二：寻找最短子串&#x2F;子数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81-v2"><span class="nav-number">4.2.</span> <span class="nav-text">模板代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.</span> <span class="nav-text">经典题目详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%80%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">5.1.</span> <span class="nav-text">题目一：无重复字符的最长子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%8C%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="nav-number">5.2.</span> <span class="nav-text">题目二：最小覆盖子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%89%EF%BC%9A%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">5.3.</span> <span class="nav-text">题目三：长度最小的子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%9B%9B%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">5.4.</span> <span class="nav-text">题目四：字符串的排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%94%EF%BC%9A%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">5.5.</span> <span class="nav-text">题目五：找到字符串中所有字母异位词</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-v3"><span class="nav-number">6.</span> <span class="nav-text">时间复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%9E%90"><span class="nav-number">6.1.</span> <span class="nav-text">基本分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%91%8A%E8%BF%98%E5%88%86%E6%9E%90%EF%BC%88Amortized-Analysis%EF%BC%89"><span class="nav-number">6.2.</span> <span class="nav-text">摊还分析（Amortized Analysis）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E6%83%85%E5%86%B5%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">6.3.</span> <span class="nav-text">不同情况的时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%E4%B8%8E%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">7.</span> <span class="nav-text">常见陷阱与调试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%B8%80%EF%BC%9A%E7%AA%97%E5%8F%A3%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-number">7.1.</span> <span class="nav-text">陷阱一：窗口边界处理错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%BA%8C%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9B%B4%E6%96%B0%E6%97%B6%E6%9C%BA%E9%94%99%E8%AF%AF"><span class="nav-number">7.2.</span> <span class="nav-text">陷阱二：哈希表更新时机错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%B8%89%EF%BC%9Avalid-%E8%AE%A1%E6%95%B0%E6%9B%B4%E6%96%B0%E9%94%99%E8%AF%AF"><span class="nav-number">7.3.</span> <span class="nav-text">陷阱三：valid 计数更新错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E5%9B%9B%EF%BC%9A%E7%A9%BA%E7%AA%97%E5%8F%A3%E6%88%96%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6"><span class="nav-number">7.4.</span> <span class="nav-text">陷阱四：空窗口或边界条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7-v4"><span class="nav-number">7.5.</span> <span class="nav-text">调试技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%9D%93-Q-A-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">8.</span> <span class="nav-text">❓ Q&amp;A: 滑动窗口常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Q1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">Q1: 什么时候应该使用滑动窗口？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.2.</span> <span class="nav-text">Q2: 滑动窗口和双指针有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q3-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%AA%97%E5%8F%A3%E5%BA%94%E8%AF%A5%E6%89%A9%E5%A4%A7%E8%BF%98%E6%98%AF%E7%BC%A9%E5%B0%8F%EF%BC%9F"><span class="nav-number">8.3.</span> <span class="nav-text">Q3: 如何判断窗口应该扩大还是缩小？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q4-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF-O-n-%E8%80%8C%E4%B8%8D%E6%98%AF-O-n%C2%B2-%EF%BC%9F"><span class="nav-number">8.4.</span> <span class="nav-text">Q4: 为什么滑动窗口的时间复杂度是 O(n) 而不是 O(n²)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q5-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AA%97%E5%8F%A3%E5%86%85%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="nav-number">8.5.</span> <span class="nav-text">Q5: 如何处理窗口内有重复元素的情况？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q6-valid-%E8%AE%A1%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%83%EF%BC%9F"><span class="nav-number">8.6.</span> <span class="nav-text">Q6: valid 计数是什么？为什么要用它？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q7-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%93%AA%E4%BA%9B-LeetCode-%E9%A2%98%E7%9B%AE%EF%BC%9F"><span class="nav-number">8.7.</span> <span class="nav-text">Q7: 滑动窗口可以解决哪些 LeetCode 题目？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q8-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.8.</span> <span class="nav-text">Q8: 滑动窗口在字符串和数组问题中有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q9-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9F"><span class="nav-number">8.9.</span> <span class="nav-text">Q9: 如何优化滑动窗口的空间复杂度？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q10-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%98%E4%BD%93%EF%BC%9F"><span class="nav-number">8.10.</span> <span class="nav-text">Q10: 滑动窗口算法有哪些常见的变体？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%8E%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98-v4"><span class="nav-number">9.</span> <span class="nav-text">变体与扩展问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%80%EF%BC%9A%E5%A4%9A%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98"><span class="nav-number">9.1.</span> <span class="nav-text">变体一：多窗口问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%BA%8C%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">9.2.</span> <span class="nav-text">变体二：滑动窗口 + 前缀和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%89%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">9.3.</span> <span class="nav-text">变体三：滑动窗口 + 双指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98%E6%8E%A8%E8%8D%90"><span class="nav-number">9.4.</span> <span class="nav-text">扩展问题推荐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E5%BB%BA%E8%AE%AE-v4"><span class="nav-number">10.</span> <span class="nav-text">实战建议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%AF%86%E5%88%AB%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98"><span class="nav-number">10.1.</span> <span class="nav-text">如何快速识别滑动窗口问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4-v3"><span class="nav-number">10.2.</span> <span class="nav-text">解题步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%E4%B8%8E%E9%81%BF%E5%85%8D%E6%96%B9%E6%B3%95"><span class="nav-number">10.3.</span> <span class="nav-text">常见陷阱与避免方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7-v5"><span class="nav-number">10.4.</span> <span class="nav-text">调试技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE-v4"><span class="nav-number">10.5.</span> <span class="nav-text">性能优化建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-v8"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
