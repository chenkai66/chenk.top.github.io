<!DOCTYPE html>



<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode（四）—— 滑动窗口技巧 |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"zh-CN","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode（四）—— 滑动窗口技巧</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-05-29 00:00:00</span>
        <span class="mobile">2023-05-29 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>12.4k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>50 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>滑动窗口是解决数组和字符串问题的一把利器。当你遇到"子数组"、"子串"、"连续"这些关键词时，滑动窗口往往能提供
<span class="math inline">\(O(n)\)</span>
时间复杂度的优雅解法。这篇文章会从基础概念开始，逐步深入到固定窗口和可变窗口两种模式，并通过多道
LeetCode 经典题目帮你彻底掌握这个技巧。</p>
<span id="more"></span>
<h2 id="什么是滑动窗口">什么是滑动窗口</h2>
<p>滑动窗口（Sliding
Window）是一种双指针技巧的变体，主要用于解决数组或字符串中的连续子区间问题。它维护一个窗口，通过移动窗口的左右边界来遍历所有可能的子区间，同时利用窗口内的信息避免重复计算。</p>
<p>想象一下，你在一列火车上，透过一个固定大小的窗户看外面的风景。随着火车前进，窗户会"滑动"到新的位置，但窗户的大小保持不变。这就是固定窗口大小的情况。另一种情况是，窗户的大小可以变化——可以拉大或缩小窗户，直到看到最合适的风景。这就是可变窗口大小的情况。</p>
<p>在算法中，滑动窗口通常涉及两个指针（left 和 right）：</p>
<ul>
<li><strong>左指针（left）</strong>：窗口的左边界</li>
<li><strong>右指针（right）</strong>：窗口的右边界</li>
<li><strong>窗口</strong>：left 和 right 之间的区间</li>
</ul>
<p>通过移动这两个指针，可以：</p>
<ol type="1">
<li>扩大窗口：移动 right 指针</li>
<li>缩小窗口：移动 left 指针</li>
<li>保持窗口大小：同时移动 left 和 right</li>
</ol>
<h2 id="滑动窗口的核心思想">滑动窗口的核心思想</h2>
<p>滑动窗口本质上是一种<strong>双指针技术</strong>，通过维护一个"窗口"（即左右两个指针之间的区间）来解决子数组/子串问题。它的核心优势在于：<strong>避免重复计算</strong>。</p>
<h3 id="思路演进从暴力到优化">思路演进：从暴力到优化</h3>
<p><strong>❌ 方法一：暴力枚举（超时）</strong></p>
<p><strong>直觉</strong>：对于求"最长/最短子串"问题，最简单的想法是枚举所有可能的子串，检查每个子串是否满足条件。</p>
<p><strong>为什么不行</strong>： - 时间复杂度：<span class="math inline">\(O(n^2)\)</span> 或 <span class="math inline">\(O(n^3)\)</span>（枚举起点和终点 + 检查条件） -
问题：<strong>大量重复计算</strong>——每次移动起点时，前面已经检查过的部分又重新检查一遍</p>
<p><strong>示例</strong>（无重复字符的最长子串）： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力解法示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring_brute</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 枚举所有可能的起点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 枚举所有可能的终点</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            <span class="comment"># 检查 s[i:j+1] 是否无重复字符</span></span><br><span class="line">            substring = s[i:j+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(substring) == <span class="built_in">len</span>(<span class="built_in">set</span>(substring)):</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, j - i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 剪枝：遇到重复就停止</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure></p>
<p><strong>复杂度</strong>： - 时间：<span class="math inline">\(O(n^2)\)</span>（双重循环）到 <span class="math inline">\(O(n^3)\)</span>（如果不剪枝，每次还要检查整个子串）
- 空间：<span class="math inline">\(O(n)\)</span>（set 存储字符）</p>
<p><strong>✅ 方法二：滑动窗口（最优）</strong></p>
<p><strong>优化思路</strong>：利用"窗口滑动"避免重复计算。关键洞察是：</p>
<ol type="1">
<li><strong>窗口扩展</strong>：右指针向右移动，尝试扩大窗口</li>
<li><strong>窗口收缩</strong>：当窗口内不满足条件时，左指针向右移动，缩小窗口</li>
<li><strong>增量更新</strong>：每次只处理新加入/移出的元素，不重新检查整个窗口</li>
</ol>
<p><strong>为什么有效</strong>： -
每个元素<strong>最多被访问两次</strong>（一次被右指针加入，一次被左指针移出）
- 时间复杂度：<span class="math inline">\(O(n)\)</span> -
避免了暴力法的重复计算</p>
<p><strong>关键洞察</strong>： - <strong>单调性</strong>：如果
<code>[left, right]</code> 不满足条件，那么
<code>[left, right+1]</code>、<code>[left, right+2]</code>
等也不会满足（对于某些问题） -
<strong>贪心策略</strong>：在保证条件的前提下，尽量扩大窗口（求最长），或尽量缩小窗口（求最短）</p>
<h3 id="火车车厢类比">火车车厢类比</h3>
<p>想象你在查看一列火车的车厢：</p>
<ul>
<li><strong>暴力法</strong>：每次重新数一遍所有车厢（从头开始检查）</li>
<li><strong>滑动窗口</strong>：
<ul>
<li>右边新车厢进入时：只检查新车厢是否符合条件</li>
<li>左边车厢驶离时：只移除最左边的车厢</li>
<li>无需重新检查中间的车厢</li>
</ul></li>
</ul>
<p><strong>可视化示例</strong>（无重复字符的最长子串）：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">字符串：&quot;abcabcbb&quot;</span><br><span class="line">目标：找出最长无重复字符子串</span><br><span class="line"></span><br><span class="line">初始状态：</span><br><span class="line">┌─┐</span><br><span class="line">│a│ b  c  a  b  c  b  b</span><br><span class="line">└─┘</span><br><span class="line">left=0, right=0, 窗口=&quot;a&quot;, 无重复 ✓</span><br><span class="line"></span><br><span class="line">步骤1：right向右扩展</span><br><span class="line">┌───────┐</span><br><span class="line">│a  b  c│ a  b  c  b  b</span><br><span class="line">└───────┘</span><br><span class="line">left=0, right=2, 窗口=&quot;abc&quot;, 无重复 ✓, max_len=3</span><br><span class="line"></span><br><span class="line">步骤2：right继续扩展，遇到重复&#x27;a&#x27;</span><br><span class="line">┌───────────┐</span><br><span class="line">│a  b  c  a│ b  c  b  b</span><br><span class="line">└───────────┘</span><br><span class="line">left=0, right=3, 窗口=&quot;abca&quot;, 有重复 ✗</span><br><span class="line"></span><br><span class="line">步骤3：left收缩，移除重复的&#x27;a&#x27;</span><br><span class="line">      ┌───────┐</span><br><span class="line">   a │b  c  a│ b  c  b  b</span><br><span class="line">      └───────┘</span><br><span class="line">left=1, right=3, 窗口=&quot;bca&quot;, 无重复 ✓</span><br><span class="line"></span><br><span class="line">最终：max_len=3（&quot;abc&quot;）</span><br></pre></td></tr></table></figure></p>
<h3 id="滑动窗口的高效性来源">滑动窗口的高效性来源</h3>
<p>滑动窗口之所以高效，是因为它利用了问题的两个关键特性：</p>
<p><strong>重复子问题（增量更新）</strong></p>
<p>当我们计算窗口 <code>[left, right]</code> 的信息时，窗口
<code>[left+1, right+1]</code>
的信息可以通过<strong>增量更新</strong>的方式得到，而不需要重新计算整个窗口。</p>
<p><strong>例子</strong>：计算窗口内元素的和 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力法：每次重新计算整个窗口的和 O(n^2)</span></span><br><span class="line">window_sum = <span class="built_in">sum</span>(arr[left:right+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 滑动窗口：增量更新 O(1)</span></span><br><span class="line">window_sum = window_sum - arr[left] + arr[right+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>单调性（决定窗口移动策略）</strong></p>
<p>在很多问题中，窗口的某些性质（如和、最大值、字符种类数等）会随着窗口的扩大或缩小呈现单调性。例如：</p>
<ul>
<li>窗口越大，和越大（非负数组）</li>
<li>窗口越大，包含的字符种类越多</li>
<li>窗口越大，最大值不会变小（非严格单调）</li>
</ul>
<p>利用这些特性，可以用 <span class="math inline">\(O(n)\)</span>
的时间复杂度解决原本需要 <span class="math inline">\(O(n^2)\)</span>
或更高复杂度的问题。</p>
<h2 id="固定窗口大小问题">固定窗口大小问题</h2>
<p>固定窗口大小的问题相对简单，因为窗口的大小是预先确定的。我们只需要维护一个固定大小的窗口，在数组上滑动，并记录每个窗口的某些属性（如和、最大值、平均值等）。</p>
<h3 id="模板代码">模板代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fixed_window</span>(<span class="params">nums, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    固定窗口大小为 k 的模板</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt; k:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 初始化窗口 [0, k-1]</span></span><br><span class="line">    window_sum = <span class="built_in">sum</span>(nums[:k])</span><br><span class="line">    result = [window_sum]</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">        <span class="comment"># 移除左边界元素，加入右边界元素</span></span><br><span class="line">        window_sum = window_sum - nums[i - k] + nums[i]</span><br><span class="line">        result.append(window_sum)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="例题子数组最大平均值">例题：子数组最大平均值</h3>
<p><strong>LeetCode 643. 子数组最大平均值</strong></p>
<p>给定一个整数数组 <code>nums</code> 和一个整数
<code>k</code>，找出长度为 <code>k</code> 的连续子数组的最大平均值。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,12,-5,-6,50,3], k = 4</span><br><span class="line">输出: 12.75</span><br><span class="line">解释: 最大平均值 (12-5-6+50)/4 = 51/4 = 12.75</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong>：</p>
<ol type="1">
<li>维护一个大小为 <code>k</code> 的窗口</li>
<li>计算每个窗口的平均值</li>
<li>返回最大值</li>
</ol>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findMaxAverage</span>(<span class="params">nums, k</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 计算第一个窗口的和</span></span><br><span class="line">    window_sum = <span class="built_in">sum</span>(nums[:k])</span><br><span class="line">    max_sum = window_sum</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">        window_sum = window_sum - nums[i - k] + nums[i]</span><br><span class="line">        max_sum = <span class="built_in">max</span>(max_sum, window_sum)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max_sum / k</span><br></pre></td></tr></table></figure>
<p><strong>Java 实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMaxAverage</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">windowSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计算第一个窗口的和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        windowSum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> windowSum;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; n; i++) &#123;</span><br><span class="line">        windowSum = windowSum - nums[i - k] + nums[i];</span><br><span class="line">        maxSum = Math.max(maxSum, windowSum);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>) maxSum / k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，每个元素最多被访问两次（一次加入窗口，一次移出窗口）
<strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span>，只使用了常数额外空间</p>
<h3 id="例题大小为-k-且平均值大于等于阈值的子数组数目">例题：大小为 K
且平均值大于等于阈值的子数组数目</h3>
<p><strong>LeetCode 1343. 大小为 K
且平均值大于等于阈值的子数组数目</strong></p>
<p>给你一个整数数组 <code>arr</code> 和两个整数 <code>k</code> 和
<code>threshold</code>，返回长度为 <code>k</code> 且平均值大于等于
<code>threshold</code> 的子数组数目。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4</span><br><span class="line">输出: 3</span><br><span class="line">解释: 子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4, 5 和 6。</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong>：</p>
<ol type="1">
<li>维护大小为 <code>k</code> 的窗口</li>
<li>计算每个窗口的和</li>
<li>如果窗口和 &gt;= <code>threshold * k</code>，计数加一</li>
</ol>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numOfSubarrays</span>(<span class="params">arr, k, threshold</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    window_sum = <span class="built_in">sum</span>(arr[:k])</span><br><span class="line">    count = <span class="number">1</span> <span class="keyword">if</span> window_sum &gt;= k * threshold <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">        window_sum = window_sum - arr[i - k] + arr[i]</span><br><span class="line">        <span class="keyword">if</span> window_sum &gt;= k * threshold:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h2 id="可变窗口大小问题">可变窗口大小问题</h2>
<p>可变窗口大小的问题更加灵活，窗口的大小会根据问题的约束条件动态调整。这类问题通常需要找到满足某种条件的最长或最短子数组/子串。</p>
<h3 id="窗口收缩条件详解">窗口收缩条件详解</h3>
<p>窗口收缩（左指针右移）是滑动窗口最关键的部分，决定了算法的正确性。<strong>什么时候收缩</strong>和<strong>收缩到什么程度</strong>是两个核心问题。</p>
<p><strong>核心原则</strong>：当窗口不满足条件时，必须收缩直到重新满足条件。</p>
<h4 id="收缩时机三种典型场景">收缩时机：三种典型场景</h4>
<p><strong>场景一：窗口违反约束（求最长）</strong></p>
<p><strong>特征</strong>：窗口内某个指标超过了限制 -
无重复字符：窗口内出现重复字符 - 最多 k 个不同字符：窗口内不同字符数
&gt; k - 和不超过 target：窗口和 &gt; target</p>
<p><strong>收缩策略</strong>：移动 left 直到窗口重新满足约束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：无重复字符的最长子串</span></span><br><span class="line"><span class="keyword">while</span> right 指向的字符在窗口中已存在:</span><br><span class="line">    移除 left 指向的字符</span><br><span class="line">    left += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>为什么这样收缩</strong>？因为当前窗口
<code>[left, right]</code>
不满足条件，那么任何包含这个窗口的更大窗口（如
<code>[left, right+1]</code>）也不会满足条件。所以必须缩小左边界。</p>
<p><strong>场景二：窗口满足条件（求最短）</strong></p>
<p><strong>特征</strong>：窗口已经满足了目标条件 -
最小覆盖子串：窗口包含了所有目标字符 - 和 &gt;= target：窗口和已经 &gt;=
target</p>
<p><strong>收缩策略</strong>：尽可能缩小窗口，在保持满足条件的前提下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：最小覆盖子串</span></span><br><span class="line"><span class="keyword">while</span> 窗口仍然包含所有目标字符:</span><br><span class="line">    更新最小长度</span><br><span class="line">    移除 left 指向的字符</span><br><span class="line">    left += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>为什么这样收缩</strong>？因为题目要求最短/最小，所以在满足条件后，要尽可能缩小窗口，找到最小的满足条件的窗口。</p>
<p><strong>场景三：固定窗口大小</strong></p>
<p><strong>特征</strong>：窗口大小固定为 k - 大小为 k 的子数组最大和 -
长度为 k 的子串出现次数</p>
<p><strong>收缩策略</strong>：每次右指针移动时，左指针也移动（保持窗口大小
= k）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：大小为 k 的子数组最大和</span></span><br><span class="line"><span class="keyword">if</span> right - left + <span class="number">1</span> == k:</span><br><span class="line">    更新答案</span><br><span class="line">    left += <span class="number">1</span>  <span class="comment"># 保持窗口大小</span></span><br></pre></td></tr></table></figure>
<h4 id="收缩条件对比表">收缩条件对比表</h4>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 27%">
<col style="width: 27%">
<col style="width: 18%">
</colgroup>
<thead>
<tr>
<th>问题类型</th>
<th>收缩时机</th>
<th>收缩条件</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>求最长</strong></td>
<td>窗口违反约束时</td>
<td><code>while 不满足条件</code></td>
<td>无重复字符的最长子串</td>
</tr>
<tr>
<td><strong>求最短</strong></td>
<td>窗口满足条件时</td>
<td><code>while 满足条件</code></td>
<td>最小覆盖子串</td>
</tr>
<tr>
<td><strong>固定大小</strong></td>
<td>窗口达到 k 时</td>
<td><code>if size == k</code></td>
<td>大小为 k 的子数组最大和</td>
</tr>
</tbody>
</table>
<h4 id="窗口收缩的数学证明">窗口收缩的数学证明</h4>
<p><strong>为什么求最长时，遇到违反约束就收缩？</strong></p>
<p><strong>反证法</strong>：假设窗口 <code>[left, right]</code>
不满足条件，但存在一个更长的满足条件的窗口
<code>[left, right+k]</code>（k &gt; 0）。 - 因为
<code>[left, right]</code> 不满足条件，而 <code>[left, right+k]</code>
是 <code>[left, right]</code> 的超集 -
如果条件是"单调递增的"（如元素数量、字符种类数），那么
<code>[left, right+k]</code> 也不会满足条件 -
矛盾！所以不存在这样的窗口</p>
<p><strong>结论</strong>：当窗口不满足条件时，必须收缩左边界，不能继续扩大右边界。</p>
<p><strong>为什么求最短时，满足条件后仍要收缩？</strong></p>
<p><strong>贪心思想</strong>：当前窗口 <code>[left, right]</code>
满足条件，但可能不是最短的。尝试缩小左边界： -
如果缩小后仍满足条件：说明左边界的元素是"多余的"，可以继续缩小 -
如果缩小后不满足条件：说明当前窗口是以 <code>right</code>
为右边界的最短窗口</p>
<p><strong>结论</strong>：在满足条件的前提下，尽可能缩小窗口，才能找到最短的。</p>
<h3 id="两种常见模式">两种常见模式</h3>
<h4 id="模式一寻找最长子串子数组窗口违反约束时收缩">模式一：寻找最长子串/子数组（窗口违反约束时收缩）</h4>
<p>这类问题的目标是找到满足条件的最长子串。通常的做法是：</p>
<ol type="1">
<li><strong>扩展窗口</strong>：不断扩大窗口（移动 right）</li>
<li><strong>收缩窗口</strong>：当窗口<strong>不满足条件</strong>时，缩小窗口（移动
left）</li>
<li><strong>更新答案</strong>：在窗口<strong>满足条件</strong>时，更新最大长度</li>
</ol>
<p><strong>模板代码</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_length_template</span>(<span class="params">arr</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    <span class="comment"># window_state 用于维护窗口的状态（如哈希表、计数器等）</span></span><br><span class="line">    window_state = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># 将 arr[right] 加入窗口</span></span><br><span class="line">        update_window_state(arr[right], window_state)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 收缩窗口：当窗口不满足条件时</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_valid(window_state):</span><br><span class="line">            <span class="comment"># 移除 arr[left]</span></span><br><span class="line">            remove_from_window(arr[left], window_state)</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新答案：此时窗口满足条件</span></span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure></p>
<p><strong>关键点</strong>： -
收缩条件：<code>while not is_valid(window_state)</code>（窗口不满足条件）
- 更新答案：在收缩后（窗口满足条件）</p>
<h4 id="模式二寻找最短子串子数组窗口满足条件时收缩">模式二：寻找最短子串/子数组（窗口满足条件时收缩）</h4>
<p>这类问题的目标是找到满足条件的最短子串。通常的做法是：</p>
<ol type="1">
<li><strong>扩展窗口</strong>：不断扩大窗口（移动
right），直到<strong>满足条件</strong></li>
<li><strong>收缩窗口</strong>：一旦满足条件，尝试缩小窗口（移动
left），在保持满足条件的前提下寻找更短的解</li>
<li><strong>更新答案</strong>：在窗口<strong>满足条件</strong>时，更新最小长度</li>
</ol>
<p><strong>模板代码</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">min_length_template</span>(<span class="params">arr, target</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># 初始化为无穷大</span></span><br><span class="line">    window_state = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># 将 arr[right] 加入窗口</span></span><br><span class="line">        update_window_state(arr[right], window_state)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 收缩窗口：当窗口满足条件时</span></span><br><span class="line">        <span class="keyword">while</span> is_valid(window_state, target):</span><br><span class="line">            <span class="comment"># 更新答案：此时窗口满足条件，尝试更新最小长度</span></span><br><span class="line">            min_len = <span class="built_in">min</span>(min_len, right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 移除 arr[left]，尝试缩小窗口</span></span><br><span class="line">            remove_from_window(arr[left], window_state)</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min_len <span class="keyword">if</span> min_len != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p><strong>关键点</strong>： -
收缩条件：<code>while is_valid(window_state, target)</code>（窗口满足条件）
- 更新答案：在收缩前（窗口满足条件时）</p>
<p><strong>对比：最长 vs 最短</strong></p>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 36%">
<col style="width: 36%">
</colgroup>
<thead>
<tr>
<th>特性</th>
<th>求最长</th>
<th>求最短</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>收缩时机</strong></td>
<td>窗口<strong>不满足</strong>条件时</td>
<td>窗口<strong>满足</strong>条件时</td>
</tr>
<tr>
<td><strong>收缩目的</strong></td>
<td>恢复满足条件</td>
<td>寻找更短的满足条件的窗口</td>
</tr>
<tr>
<td><strong>更新答案</strong></td>
<td>收缩<strong>后</strong>（窗口满足条件）</td>
<td>收缩<strong>前</strong>（窗口满足条件）</td>
</tr>
<tr>
<td><strong>初始值</strong></td>
<td><code>max_len = 0</code></td>
<td><code>min_len = inf</code></td>
</tr>
<tr>
<td><strong>典型问题</strong></td>
<td>无重复字符的最长子串</td>
<td>最小覆盖子串</td>
</tr>
</tbody>
</table>
<h3 id="模板代码通用">模板代码（通用）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_window_template</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    可变窗口大小的通用模板</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    适用场景：</span></span><br><span class="line"><span class="string">    1. 求最长子串/子数组（窗口不满足条件时收缩）</span></span><br><span class="line"><span class="string">    2. 求最短子串/子数组（窗口满足条件时收缩）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    result = <span class="number">0</span>  <span class="comment"># 或 result = []</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 用于记录窗口状态的变量</span></span><br><span class="line">    window = &#123;&#125;  <span class="comment"># 或 window = []</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># 扩大窗口：加入 s[right]</span></span><br><span class="line">        window[s[right]] = window.get(s[right], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 判断窗口是否需要收缩</span></span><br><span class="line">        <span class="keyword">while</span> window_needs_shrink(window):</span><br><span class="line">            <span class="comment"># 缩小窗口：移除 s[left]</span></span><br><span class="line">            window[s[left]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> window[s[left]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> window[s[left]]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 更新答案</span></span><br><span class="line">        result = update_result(result, left, right)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="经典题目详解">经典题目详解</h2>
<h3 id="题目一无重复字符的最长子串">题目一：无重复字符的最长子串</h3>
<p><strong>LeetCode 3. 无重复字符的最长子串</strong></p>
<p>给定一个字符串
<code>s</code>，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p><strong>思路分析</strong>：</p>
<p>这是一个典型的"寻找最长子串"问题。需要：</p>
<ol type="1">
<li>维护一个窗口，窗口内的字符都不重复</li>
<li>用哈希表记录窗口中每个字符的出现次数</li>
<li>当窗口中出现重复字符时，缩小窗口（移动 left），直到没有重复字符</li>
<li>在窗口没有重复字符时，更新最长长度</li>
</ol>
<p><strong>详细步骤</strong>：</p>
<p>以 <code>s = "abcabcbb"</code> 为例：</p>
<ol type="1">
<li><p><strong>初始化</strong>：<code>left = 0</code>，<code>right = 0</code>，<code>max_len = 0</code>，<code>char_count = &#123;&#125;</code></p></li>
<li><p><strong>right = 0</strong>：加入 <code>'a'</code></p>
<ul>
<li><code>char_count = &#123;'a': 1&#125;</code></li>
<li>窗口
<code>[0, 0]</code>：<code>"a"</code>，无重复，<code>max_len = 1</code></li>
</ul></li>
<li><p><strong>right = 1</strong>：加入 <code>'b'</code></p>
<ul>
<li><code>char_count = &#123;'a': 1, 'b': 1&#125;</code></li>
<li>窗口
<code>[0, 1]</code>：<code>"ab"</code>，无重复，<code>max_len = 2</code></li>
</ul></li>
<li><p><strong>right = 2</strong>：加入 <code>'c'</code></p>
<ul>
<li><code>char_count = &#123;'a': 1, 'b': 1, 'c': 1&#125;</code></li>
<li>窗口
<code>[0, 2]</code>：<code>"abc"</code>，无重复，<code>max_len = 3</code></li>
</ul></li>
<li><p><strong>right = 3</strong>：加入 <code>'a'</code></p>
<ul>
<li><code>char_count = &#123;'a': 2, 'b': 1, 'c': 1&#125;</code>（出现重复！）</li>
<li>缩小窗口：移动 left，直到 <code>'a'</code> 只出现一次</li>
<li><code>left = 1</code>：移除
<code>s[0] = 'a'</code>，<code>char_count = &#123;'a': 1, 'b': 1, 'c': 1&#125;</code></li>
<li>窗口
<code>[1, 3]</code>：<code>"bca"</code>，无重复，<code>max_len = 3</code></li>
</ul></li>
<li><p><strong>right = 4</strong>：加入 <code>'b'</code></p>
<ul>
<li><code>char_count = &#123;'a': 1, 'b': 2, 'c': 1&#125;</code>（出现重复！）</li>
<li>缩小窗口：<code>left = 2</code>，移除 <code>s[1] = 'b'</code></li>
<li>窗口
<code>[2, 4]</code>：<code>"cab"</code>，无重复，<code>max_len = 3</code></li>
</ul></li>
<li><p>继续这个过程...</p></li>
</ol>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    找出字符串中无重复字符的最长子串长度</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        s: 输入字符串</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        最长无重复字符子串的长度</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    思路：滑动窗口 + 哈希表</span></span><br><span class="line"><span class="string">    - 用哈希表记录窗口内每个字符的出现次数</span></span><br><span class="line"><span class="string">    - 当窗口内出现重复字符（某字符次数 &gt; 1）时，收缩左边界</span></span><br><span class="line"><span class="string">    - 在窗口满足条件时，更新最大长度</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    时间复杂度：O(n)，每个字符最多被访问两次</span></span><br><span class="line"><span class="string">    空间复杂度：O(min(n, m))，m 是字符集大小</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 边界情况：空字符串</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    left = <span class="number">0</span>  <span class="comment"># 窗口左边界</span></span><br><span class="line">    max_len = <span class="number">0</span>  <span class="comment"># 记录最长长度</span></span><br><span class="line">    char_count = &#123;&#125;  <span class="comment"># 哈希表：&#123;字符: 出现次数&#125;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 右指针遍历字符串，扩展窗口</span></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># 关键步骤1：将右边界字符加入窗口</span></span><br><span class="line">        <span class="comment"># 为什么用 get？因为字符可能第一次出现，默认为 0</span></span><br><span class="line">        char_count[s[right]] = char_count.get(s[right], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 关键步骤2：收缩窗口（当窗口不满足条件时）</span></span><br><span class="line">        <span class="comment"># 条件：s[right] 的出现次数 &gt; 1，说明窗口内有重复字符</span></span><br><span class="line">        <span class="comment"># 为什么是 while 不是 if？因为可能需要连续移除多个字符</span></span><br><span class="line">        <span class="keyword">while</span> char_count[s[right]] &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 移除左边界字符</span></span><br><span class="line">            char_count[s[left]] -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 优化：如果字符次数降为 0，从哈希表中删除（节省空间）</span></span><br><span class="line">            <span class="keyword">if</span> char_count[s[left]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> char_count[s[left]]</span><br><span class="line">            <span class="comment"># 左指针右移</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 关键步骤3：更新答案（此时窗口满足条件：无重复字符）</span></span><br><span class="line">        <span class="comment"># 窗口大小 = right - left + 1</span></span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<p><strong>代码执行过程示例</strong>：</p>
<p>输入：<code>s = "abcabcbb"</code></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>right</th>
<th>s[right]</th>
<th>char_count</th>
<th>left</th>
<th>窗口</th>
<th>操作</th>
<th>max_len</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>-</td>
<td>-</td>
<td>{}</td>
<td>0</td>
<td>""</td>
<td>-</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>'a'</td>
<td>{'a':1}</td>
<td>0</td>
<td>"a"</td>
<td>加入'a'</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>'b'</td>
<td>{'a':1,'b':1}</td>
<td>0</td>
<td>"ab"</td>
<td>加入'b'</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>'c'</td>
<td>{'a':1,'b':1,'c':1}</td>
<td>0</td>
<td>"abc"</td>
<td>加入'c'</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>'a'</td>
<td>{'a':2,'b':1,'c':1}</td>
<td>0</td>
<td>"abca"</td>
<td>加入'a'，重复！</td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>'a'</td>
<td>{'a':1,'b':1,'c':1}</td>
<td>1</td>
<td>"bca"</td>
<td>移除'a'，不重复</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>4</td>
<td>'b'</td>
<td>{'a':1,'b':2,'c':1}</td>
<td>1</td>
<td>"bcab"</td>
<td>加入'b'，重复！</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>4</td>
<td>'b'</td>
<td>{'a':1,'b':1,'c':1}</td>
<td>2</td>
<td>"cab"</td>
<td>移除'b'，不重复</td>
<td>3</td>
</tr>
<tr>
<td>6</td>
<td>5</td>
<td>'c'</td>
<td>{'a':1,'b':1,'c':2}</td>
<td>2</td>
<td>"cabc"</td>
<td>加入'c'，重复！</td>
<td>-</td>
</tr>
<tr>
<td>6</td>
<td>5</td>
<td>'c'</td>
<td>{'a':1,'b':1,'c':1}</td>
<td>3</td>
<td>"abc"</td>
<td>移除'c'，不重复</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>6</td>
<td>'b'</td>
<td>{'a':1,'b':2,'c':1}</td>
<td>3</td>
<td>"abcb"</td>
<td>加入'b'，重复！</td>
<td>-</td>
</tr>
<tr>
<td>7</td>
<td>6</td>
<td>'b'</td>
<td>{'b':2,'c':1}</td>
<td>4</td>
<td>"bcb"</td>
<td>移除'a'，仍重复</td>
<td>-</td>
</tr>
<tr>
<td>7</td>
<td>6</td>
<td>'b'</td>
<td>{'b':1,'c':1}</td>
<td>5</td>
<td>"cb"</td>
<td>移除'b'，不重复</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>7</td>
<td>'b'</td>
<td>{'b':2,'c':1}</td>
<td>5</td>
<td>"cbb"</td>
<td>加入'b'，重复！</td>
<td>-</td>
</tr>
<tr>
<td>8</td>
<td>7</td>
<td>'b'</td>
<td>{'b':2}</td>
<td>6</td>
<td>"bb"</td>
<td>移除'c'，仍重复</td>
<td>-</td>
</tr>
<tr>
<td>8</td>
<td>7</td>
<td>'b'</td>
<td>{'b':1}</td>
<td>7</td>
<td>"b"</td>
<td>移除'b'，不重复</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><strong>为什么这样设计？</strong></p>
<ol type="1">
<li><strong>一次遍历</strong>：right 指针只向右移动，每个字符最多被
right 访问一次</li>
<li><strong>增量更新</strong>：每次只处理新加入的字符，不重新检查整个窗口</li>
<li><strong>及时收缩</strong>：遇到重复立即收缩左边界，保证窗口始终满足条件</li>
<li><strong>哈希表优化</strong>：用哈希表 O(1)
查找字符是否重复，避免遍历窗口</li>
</ol>
<p><strong>Java 实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character, Integer&gt; charCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        charCount.put(c, charCount.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果出现重复字符，缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span> (charCount.get(c) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">leftChar</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            charCount.put(leftChar, charCount.get(leftChar) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (charCount.get(leftChar) == <span class="number">0</span>) &#123;</span><br><span class="line">                charCount.remove(leftChar);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        maxLen = Math.max(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>时间复杂度：<span class="math inline">\(O(n)\)</span></strong></p>
<p><strong>推导过程</strong>： 1. <strong>外层循环</strong>：右指针
<code>right</code> 遍历字符串，执行 <span class="math inline">\(n\)</span> 次 2. <strong>内层 while
循环</strong>：左指针 <code>left</code>
移动，看似嵌套，但<strong>关键洞察</strong>： - <code>left</code>
只会向右移动，不会回退 - <code>left</code> 最多移动 <span class="math inline">\(n\)</span> 次（从 0 到 n-1） -
所以内层循环的<strong>总</strong>执行次数是 <span class="math inline">\(O(n)\)</span>，而不是 <span class="math inline">\(O(n^2)\)</span> 3.
<strong>哈希表操作</strong>：插入/删除/查找都是 <span class="math inline">\(O(1)\)</span> 4. <strong>总计</strong>：<span class="math inline">\(O(n) + O(n) = O(n)\)</span></p>
<p><strong>为什么不是 <span class="math inline">\(O(n^2)\)</span>？</strong></p>
<p>虽然代码中有 <code>for right in range(n)</code> 嵌套
<code>while char_count[s[right]] &gt; 1</code>，但这<strong>不是</strong>传统的双重循环。关键在于：
- 每个字符<strong>最多被 left 访问一次，被 right 访问一次</strong> -
所以总操作数是 <span class="math inline">\(2n\)</span>，时间复杂度仍是
<span class="math inline">\(O(n)\)</span></p>
<p><strong>数值示例</strong>： - 字符串长度 100：约 200
次操作（每个字符被访问 2 次） - 字符串长度 1000：约 2000 次操作 -
增长趋势：<strong>线性增长</strong>，不是 <span class="math inline">\(n^2\)</span></p>
<p><strong>空间复杂度：<span class="math inline">\(O(\min(n,
m))\)</span></strong></p>
<p><strong>推导过程</strong>： -
<strong>哈希表大小</strong>：最多存储窗口内的所有字符 -
<strong>最坏情况</strong>： - 如果字符串全部不重复：哈希表大小 = <span class="math inline">\(n\)</span>（字符串长度） - 但受限于字符集大小
<span class="math inline">\(m\)</span>（如 ASCII 是 128，Unicode
常用字符约 65536） - 所以实际大小 = <span class="math inline">\(\min(n,
m)\)</span> -
<strong>最好情况</strong>：如果字符串有大量重复，哈希表大小可能远小于
<span class="math inline">\(n\)</span></p>
<p><strong>为什么是 <span class="math inline">\(\min(n, m)\)</span>
而不是 <span class="math inline">\(n\)</span>？</strong> -
字符集有限：即使字符串很长（<span class="math inline">\(n\)</span>
很大），不同字符的种类不会超过字符集大小 <span class="math inline">\(m\)</span> - 例如：英文字母字符串，哈希表最多 26
个键，与字符串长度无关</p>
<p><strong>实际例子</strong>： - 输入
<code>"abcdefghij...xyz"</code>（26 个字母）：哈希表大小 = 26 - 输入
<code>"aaaaaaa..."</code>（100 个 'a'）：哈希表大小 = 1 - 输入随机 ASCII
字符串（长度 1000）：哈希表大小 ≤ 128</p>
<h3 id="题目二最小覆盖子串">题目二：最小覆盖子串</h3>
<p><strong>LeetCode 76. 最小覆盖子串</strong></p>
<p>给你一个字符串 <code>s</code>、一个字符串 <code>t</code>。返回
<code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果
<code>s</code> 中不存在涵盖 <code>t</code>
所有字符的子串，则返回空字符串 <code>""</code>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出: &quot;BANC&quot;</span><br><span class="line">解释: 最小覆盖子串 &quot;BANC&quot; 包含 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br></pre></td></tr></table></figure>
<p><strong>思路分析</strong>：</p>
<p>这是一个"寻找最短子串"问题。需要：</p>
<ol type="1">
<li>用哈希表记录 <code>t</code> 中每个字符需要的数量</li>
<li>维护一个窗口，不断扩大窗口直到包含 <code>t</code> 的所有字符</li>
<li>一旦窗口满足条件，尝试缩小窗口，寻找更短的解</li>
<li>记录满足条件的最短窗口</li>
</ol>
<p><strong>详细步骤</strong>：</p>
<p>以 <code>s = "ADOBECODEBANC"</code>，<code>t = "ABC"</code>
为例：</p>
<ol type="1">
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>need = &#123;'A': 1, 'B': 1, 'C': 1&#125;</code>（<code>t</code>
中每个字符需要的数量）</li>
<li><code>window = &#123;&#125;</code>（窗口中每个字符的数量）</li>
<li><code>valid = 0</code>（窗口中满足 <code>need</code>
条件的字符种类数）</li>
<li><code>left = 0</code>，<code>right = 0</code></li>
<li><code>start = 0</code>，<code>min_len = float('inf')</code></li>
</ul></li>
<li><p><strong>扩大窗口</strong>：</p>
<ul>
<li><code>right = 0</code>：加入
<code>'A'</code>，<code>window = &#123;'A': 1&#125;</code>，<code>valid = 1</code>（<code>'A'</code>
满足条件）</li>
<li><code>right = 1</code>：加入
<code>'D'</code>，<code>window = &#123;'A': 1, 'D': 1&#125;</code>，<code>valid = 1</code></li>
<li><code>right = 2</code>：加入
<code>'O'</code>，<code>window = &#123;'A': 1, 'D': 1, 'O': 1&#125;</code>，<code>valid = 1</code></li>
<li><code>right = 3</code>：加入
<code>'B'</code>，<code>window = &#123;'A': 1, 'B': 1, 'D': 1, 'O': 1&#125;</code>，<code>valid = 2</code>（<code>'B'</code>
满足条件）</li>
<li><code>right = 4</code>：加入
<code>'E'</code>，<code>window = &#123;'A': 1, 'B': 1, 'D': 1, 'E': 1, 'O': 1&#125;</code>，<code>valid = 2</code></li>
<li><code>right = 5</code>：加入
<code>'C'</code>，<code>window = &#123;'A': 1, 'B': 1, 'C': 1, 'D': 1, 'E': 1, 'O': 1&#125;</code>，<code>valid = 3</code>（所有字符都满足条件！）</li>
</ul></li>
<li><p><strong>缩小窗口</strong>（<code>valid == len(need)</code>）：</p>
<ul>
<li>当前窗口 <code>[0, 5]</code>：<code>"ADOBEC"</code>，长度为 6</li>
<li>尝试缩小：<code>left = 0</code>，移除 <code>'A'</code>，但
<code>'A'</code> 是必需的，不能移除</li>
<li>实际上，需要检查移除字符后是否还满足条件</li>
<li>正确的做法：当
<code>window[s[left]] &gt; need.get(s[left], 0)</code> 时，可以移除</li>
</ul></li>
<li><p><strong>继续扩大窗口</strong>：</p>
<ul>
<li><code>right = 6</code>：加入 <code>'O'</code>...</li>
<li>当窗口再次满足条件时，尝试缩小并更新答案</li>
</ul></li>
</ol>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">s, t</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> t:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 记录 t 中每个字符需要的数量</span></span><br><span class="line">    need = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">        need[c] = need.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 记录窗口中每个字符的数量</span></span><br><span class="line">    window = &#123;&#125;</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    valid = <span class="number">0</span>  <span class="comment"># 窗口中满足 need 条件的字符种类数</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        c = s[right]</span><br><span class="line">        <span class="comment"># 扩大窗口</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> need:</span><br><span class="line">            window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                valid += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 判断窗口是否需要收缩</span></span><br><span class="line">        <span class="keyword">while</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">            <span class="comment"># 更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> right - left + <span class="number">1</span> &lt; min_len:</span><br><span class="line">                start = left</span><br><span class="line">                min_len = right - left + <span class="number">1</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment"># 缩小窗口</span></span><br><span class="line">            d = s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                    valid -= <span class="number">1</span></span><br><span class="line">                window[d] -= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span> <span class="keyword">if</span> min_len == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> s[start:start + min_len]</span><br></pre></td></tr></table></figure>
<p><strong>Java 实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || t == <span class="literal">null</span> || s.length() == <span class="number">0</span> || t.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 记录 t 中每个字符需要的数量</span></span><br><span class="line">    Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 记录窗口中每个字符的数量</span></span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 窗口中满足 need 条件的字符种类数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="comment">// 扩大窗口</span></span><br><span class="line">        <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (window.get(c).equals(need.get(c))) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 判断窗口是否需要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.size()) &#123;</span><br><span class="line">            <span class="comment">// 更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; minLen) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                minLen = right - left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window.get(d).equals(need.get(d))) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + minLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(|s| +
|t|)\)</span>，其中 <span class="math inline">\(|s|\)</span> 和 <span class="math inline">\(|t|\)</span> 分别是字符串 <code>s</code> 和
<code>t</code> 的长度 <strong>空间复杂度</strong>：<span class="math inline">\(O(|s| + |t|)\)</span>，用于存储哈希表</p>
<h3 id="题目三长度最小的子数组">题目三：长度最小的子数组</h3>
<p><strong>LeetCode 209. 长度最小的子数组</strong></p>
<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数
<code>target</code>，找出该数组中满足其和 <code>≥ target</code>
的长度最小的<strong>连续子数组</strong>
<code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，并返回其长度。如果不存在符合条件的子数组，返回
<code>0</code>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>
<p><strong>思路分析</strong>：</p>
<p>这是一个"寻找最短子数组"问题。需要：</p>
<ol type="1">
<li>维护一个窗口，不断扩大窗口直到窗口和 <code>≥ target</code></li>
<li>一旦满足条件，尝试缩小窗口，寻找更短的解</li>
<li>记录满足条件的最短长度</li>
</ol>
<p><strong>详细步骤</strong>：</p>
<p>以 <code>target = 7</code>，<code>nums = [2,3,1,2,4,3]</code>
为例：</p>
<ol type="1">
<li><p><strong>初始化</strong>：<code>left = 0</code>，<code>right = 0</code>，<code>window_sum = 0</code>，<code>min_len = float('inf')</code></p></li>
<li><p><strong>扩大窗口</strong>：</p>
<ul>
<li><code>right = 0</code>：加入
<code>2</code>，<code>window_sum = 2</code>，窗口
<code>[0, 0]</code>：<code>[2]</code>，和 &lt; 7</li>
<li><code>right = 1</code>：加入
<code>3</code>，<code>window_sum = 5</code>，窗口
<code>[0, 1]</code>：<code>[2,3]</code>，和 &lt; 7</li>
<li><code>right = 2</code>：加入
<code>1</code>，<code>window_sum = 6</code>，窗口
<code>[0, 2]</code>：<code>[2,3,1]</code>，和 &lt; 7</li>
<li><code>right = 3</code>：加入
<code>2</code>，<code>window_sum = 8</code>，窗口
<code>[0, 3]</code>：<code>[2,3,1,2]</code>，和 ≥ 7！</li>
</ul></li>
<li><p><strong>缩小窗口</strong>：</p>
<ul>
<li>当前窗口 <code>[0, 3]</code> 长度为 4，<code>min_len = 4</code></li>
<li><code>left = 0</code>：移除
<code>2</code>，<code>window_sum = 6</code>，窗口
<code>[1, 3]</code>：<code>[3,1,2]</code>，和 &lt; 7，停止缩小</li>
<li>继续扩大窗口...</li>
</ul></li>
<li><p><strong>继续过程</strong>：</p>
<ul>
<li><code>right = 4</code>：加入
<code>4</code>，<code>window_sum = 10</code>，窗口
<code>[1, 4]</code>：<code>[3,1,2,4]</code>，和 ≥ 7</li>
<li>缩小：<code>left = 1</code>，移除
<code>3</code>，<code>window_sum = 7</code>，窗口
<code>[2, 4]</code>：<code>[1,2,4]</code>，和 ≥ 7</li>
<li>缩小：<code>left = 2</code>，移除
<code>1</code>，<code>window_sum = 6</code>，和 &lt; 7，停止</li>
<li><code>min_len = min(4, 3) = 3</code></li>
</ul></li>
<li><p><strong>最终</strong>：<code>right = 5</code>，加入
<code>3</code>，<code>window_sum = 9</code>，窗口
<code>[2, 5]</code>：<code>[2,4,3]</code>，和 ≥ 7</p>
<ul>
<li>缩小：<code>left = 2</code>，移除
<code>2</code>，<code>window_sum = 7</code>，窗口
<code>[3, 5]</code>：<code>[4,3]</code>，和 ≥ 7</li>
<li>缩小：<code>left = 3</code>，移除
<code>4</code>，<code>window_sum = 3</code>，和 &lt; 7，停止</li>
<li><code>min_len = min(3, 2) = 2</code></li>
</ul></li>
</ol>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">target, nums</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    window_sum = <span class="number">0</span></span><br><span class="line">    min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># 扩大窗口</span></span><br><span class="line">        window_sum += nums[right]</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 当窗口和满足条件时，尝试缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span> window_sum &gt;= target:</span><br><span class="line">            min_len = <span class="built_in">min</span>(min_len, right - left + <span class="number">1</span>)</span><br><span class="line">            window_sum -= nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> min_len == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> min_len</span><br></pre></td></tr></table></figure>
<p><strong>Java 实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">windowSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">        <span class="comment">// 扩大窗口</span></span><br><span class="line">        windowSum += nums[right];</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 当窗口和满足条件时，尝试缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span> (windowSum &gt;= target) &#123;</span><br><span class="line">            minLen = Math.min(minLen, right - left + <span class="number">1</span>);</span><br><span class="line">            windowSum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，每个元素最多被访问两次
<strong>空间复杂度</strong>：<span class="math inline">\(O(1)\)</span></p>
<h3 id="题目四字符串的排列">题目四：字符串的排列</h3>
<p><strong>LeetCode 567. 字符串的排列</strong></p>
<p>给你两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断
<code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回
<code>true</code>；否则，返回 <code>false</code>。</p>
<p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code>
的<strong>子串</strong>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure>
<p><strong>思路分析</strong>：</p>
<p>这个问题可以转化为：在 <code>s2</code> 中是否存在一个长度为
<code>len(s1)</code> 的子串，其字符频率与 <code>s1</code> 完全相同。</p>
<p>可以：</p>
<ol type="1">
<li>用固定大小的窗口（大小为 <code>len(s1)</code>）在 <code>s2</code>
上滑动</li>
<li>对于每个窗口，检查窗口内字符的频率是否与 <code>s1</code> 相同</li>
<li>如果相同，返回 <code>true</code></li>
</ol>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s1) &gt; <span class="built_in">len</span>(s2):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 记录 s1 中每个字符需要的数量</span></span><br><span class="line">    need = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s1:</span><br><span class="line">        need[c] = need.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 记录窗口中每个字符的数量</span></span><br><span class="line">    window = &#123;&#125;</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 初始化窗口 [0, len(s1)-1]</span></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)):</span><br><span class="line">        c = s2[right]</span><br><span class="line">        window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 检查第一个窗口</span></span><br><span class="line">    <span class="keyword">if</span> window == need:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)):</span><br><span class="line">        <span class="comment"># 加入右边界字符</span></span><br><span class="line">        c = s2[right]</span><br><span class="line">        window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 移除左边界字符</span></span><br><span class="line">        d = s2[left]</span><br><span class="line">        window[d] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> window[d] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">del</span> window[d]</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 检查窗口</span></span><br><span class="line">        <span class="keyword">if</span> window == need:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>优化版本</strong>（使用 valid
计数，避免每次比较整个字典）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s1) &gt; <span class="built_in">len</span>(s2):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">    need = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s1:</span><br><span class="line">        need[c] = need.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    window = &#123;&#125;</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    valid = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2)):</span><br><span class="line">        c = s2[right]</span><br><span class="line">        <span class="comment"># 扩大窗口</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> need:</span><br><span class="line">            window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                valid += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 如果窗口大小超过 len(s1)，缩小窗口</span></span><br><span class="line">        <span class="keyword">if</span> right - left + <span class="number">1</span> &gt; <span class="built_in">len</span>(s1):</span><br><span class="line">            d = s2[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                    valid -= <span class="number">1</span></span><br><span class="line">                window[d] -= <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 检查是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>Java 实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() &gt; s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s1.toCharArray()) &#123;</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s2.length(); right++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s2.charAt(right);</span><br><span class="line">        <span class="comment">// 扩大窗口</span></span><br><span class="line">        <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (window.get(c).equals(need.get(c))) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果窗口大小超过 len(s1)，缩小窗口</span></span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; s1.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s2.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window.get(d).equals(need.get(d))) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 检查是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (valid == need.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(|s1| +
|s2|)\)</span> <strong>空间复杂度</strong>：<span class="math inline">\(O(|s1|)\)</span></p>
<h3 id="题目五找到字符串中所有字母异位词">题目五：找到字符串中所有字母异位词</h3>
<p><strong>LeetCode 438. 找到字符串中所有字母异位词</strong></p>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code>
中所有 <code>p</code>
的<strong>字母异位词</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>字母异位词指字母相同，但排列不同的字符串。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br></pre></td></tr></table></figure>
<p><strong>思路分析</strong>：</p>
<p>这个问题与上一题非常相似，区别在于：</p>
<ul>
<li>上一题只需要判断是否存在，这一题需要找到所有满足条件的起始索引</li>
<li>窗口大小固定为 <code>len(p)</code></li>
<li>对于每个满足条件的窗口，记录其起始索引</li>
</ul>
<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">s, p</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">  </span><br><span class="line">    need = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> p:</span><br><span class="line">        need[c] = need.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    window = &#123;&#125;</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    valid = <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        c = s[right]</span><br><span class="line">        <span class="comment"># 扩大窗口</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> need:</span><br><span class="line">            window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                valid += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 如果窗口大小超过 len(p)，缩小窗口</span></span><br><span class="line">        <span class="keyword">if</span> right - left + <span class="number">1</span> &gt; <span class="built_in">len</span>(p):</span><br><span class="line">            d = s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                    valid -= <span class="number">1</span></span><br><span class="line">                window[d] -= <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 检查是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> valid == <span class="built_in">len</span>(need) <span class="keyword">and</span> right - left + <span class="number">1</span> == <span class="built_in">len</span>(p):</span><br><span class="line">            result.append(left)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>Java 实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (p.length() &gt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : p.toCharArray()) &#123;</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="comment">// 扩大窗口</span></span><br><span class="line">        <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (window.get(c).equals(need.get(c))) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果窗口大小超过 len(p)，缩小窗口</span></span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; p.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window.get(d).equals(need.get(d))) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 检查是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (valid == need.size() &amp;&amp; right - left + <span class="number">1</span> == p.length()) &#123;</span><br><span class="line">            result.add(left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(|s| +
|p|)\)</span> <strong>空间复杂度</strong>：<span class="math inline">\(O(|p|)\)</span></p>
<h2 id="时间复杂度分析">时间复杂度分析</h2>
<p>滑动窗口算法的时间复杂度分析有一个通用的方法：</p>
<h3 id="基本分析">基本分析</h3>
<p>对于滑动窗口算法：</p>
<ul>
<li><strong>外层循环</strong>：<code>right</code> 指针从 <code>0</code>
移动到 <code>n-1</code>，共 <span class="math inline">\(n\)</span>
次迭代</li>
<li><strong>内层循环</strong>：<code>left</code> 指针的移动</li>
</ul>
<p>虽然有一个 <code>while</code> 循环，但 <code>left</code>
指针<strong>只会向前移动，不会后退</strong>。因此，在整个算法执行过程中：</p>
<ul>
<li><code>right</code> 指针移动了 <span class="math inline">\(n\)</span>
次</li>
<li><code>left</code> 指针最多移动 <span class="math inline">\(n\)</span> 次</li>
</ul>
<p>所以总的时间复杂度是 <span class="math inline">\(O(n)\)</span>，而不是 <span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="摊还分析amortized-analysis">摊还分析（Amortized Analysis）</h3>
<p>可以用摊还分析来更严格地证明：</p>
<p>设 <code>right</code> 移动了 <span class="math inline">\(n\)</span>
次，<code>left</code> 移动了 <span class="math inline">\(m\)</span>
次。由于 <code>left</code> 不会超过 <code>right</code>，所以 <span class="math inline">\(m \leq n\)</span>。</p>
<p>总操作数 = <code>right</code> 移动次数 + <code>left</code> 移动次数 =
<span class="math inline">\(n + m \leq 2n = O(n)\)</span></p>
<p>因此，每个元素的摊还时间复杂度是 <span class="math inline">\(O(1)\)</span>，总时间复杂度是 <span class="math inline">\(O(n)\)</span>。</p>
<h3 id="不同情况的时间复杂度">不同情况的时间复杂度</h3>
<ol type="1">
<li><p><strong>固定窗口大小</strong>：<span class="math inline">\(O(n)\)</span></p>
<ul>
<li>每个元素被访问两次（一次加入，一次移出）</li>
</ul></li>
<li><p><strong>可变窗口大小（最长子串）</strong>：<span class="math inline">\(O(n)\)</span></p>
<ul>
<li>每个元素最多被访问两次</li>
</ul></li>
<li><p><strong>可变窗口大小（最短子串）</strong>：<span class="math inline">\(O(n)\)</span></p>
<ul>
<li>每个元素最多被访问两次</li>
</ul></li>
<li><p><strong>需要排序或复杂操作</strong>：可能更高</p>
<ul>
<li>例如，如果窗口内需要维护有序结构，可能是 <span class="math inline">\(O(n \log n)\)</span></li>
</ul></li>
</ol>
<h2 id="常见陷阱与调试技巧">常见陷阱与调试技巧</h2>
<h3 id="陷阱一窗口边界处理错误">陷阱一：窗口边界处理错误</h3>
<p><strong>问题</strong>：窗口的左右边界 <code>[left, right]</code>
是闭区间还是左闭右开区间？</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>统一使用<strong>左闭右闭区间</strong>
<code>[left, right]</code></li>
<li>窗口长度 = <code>right - left + 1</code></li>
<li>初始化时，<code>left = 0</code>，<code>right = -1</code>（空窗口）或
<code>left = 0</code>，<code>right = 0</code>（包含第一个元素）</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误：窗口长度计算错误</span></span><br><span class="line">window_len = right - left  <span class="comment"># 应该是 right - left + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确</span></span><br><span class="line">window_len = right - left + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="陷阱二哈希表更新时机错误">陷阱二：哈希表更新时机错误</h3>
<p><strong>问题</strong>：在缩小窗口时，忘记更新哈希表，或者在更新哈希表之前就检查条件。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>先更新窗口状态（加入/移除元素）</li>
<li>再检查窗口是否满足条件</li>
<li>最后更新答案</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误：先检查条件，再更新窗口</span></span><br><span class="line"><span class="keyword">if</span> window_satisfies_condition():</span><br><span class="line">    update_answer()</span><br><span class="line">    window.remove(s[left])  <span class="comment"># 错误：应该在检查之前更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：先更新窗口，再检查条件</span></span><br><span class="line">window.add(s[right])</span><br><span class="line"><span class="keyword">if</span> window_satisfies_condition():</span><br><span class="line">    update_answer()</span><br><span class="line">window.remove(s[left])</span><br></pre></td></tr></table></figure>
<h3 id="陷阱三valid-计数更新错误">陷阱三：valid 计数更新错误</h3>
<p><strong>问题</strong>：在使用 <code>valid</code> 计数优化时，更新
<code>valid</code> 的时机不对。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>当 <code>window[c] == need[c]</code> 时，<code>valid++</code></li>
<li>当 <code>window[c]</code> 从 <code>need[c]</code> 变为
<code>need[c] - 1</code> 时，<code>valid--</code></li>
<li>注意：只有当 <code>window[c]</code> <strong>恰好等于</strong>
<code>need[c]</code> 时，才计入 <code>valid</code></li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误：没有检查是否恰好相等</span></span><br><span class="line"><span class="keyword">if</span> window[c] &gt;= need[c]:  <span class="comment"># 错误：可能重复计数</span></span><br><span class="line">    valid += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：检查是否恰好相等</span></span><br><span class="line"><span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">    valid += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="陷阱四空窗口或边界条件">陷阱四：空窗口或边界条件</h3>
<p><strong>问题</strong>：没有处理空字符串、空数组、窗口大小为 0
等边界情况。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>在函数开始处检查边界条件</li>
<li>确保窗口大小至少为 1（如果需要）</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_window</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:  <span class="comment"># 处理空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; k:  <span class="comment"># 处理窗口大小大于字符串长度的情况</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># ... 主逻辑</span></span><br></pre></td></tr></table></figure>
<h3 id="调试技巧">调试技巧</h3>
<ol type="1">
<li><strong>打印窗口状态</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_window</span>(<span class="params">s</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># 打印当前窗口</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;窗口 [<span class="subst">&#123;left&#125;</span>, <span class="subst">&#123;right&#125;</span>]: <span class="subst">&#123;s[left:right+<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;窗口状态: <span class="subst">&#123;window&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># ... 其他逻辑</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>使用断言检查不变量</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查窗口大小</span></span><br><span class="line"><span class="keyword">assert</span> right - left + <span class="number">1</span> &gt;= <span class="number">0</span>, <span class="string">&quot;窗口大小不能为负&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 valid 计数</span></span><br><span class="line"><span class="keyword">assert</span> valid &lt;= <span class="built_in">len</span>(need), <span class="string">&quot;valid 不能超过 need 的大小&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><p><strong>单步调试</strong>：</p>
<ul>
<li>使用调试器逐步执行</li>
<li>观察
<code>left</code>、<code>right</code>、<code>window</code>、<code>valid</code>
的变化</li>
<li>检查每个步骤是否符合预期</li>
</ul></li>
<li><p><strong>测试用例</strong>：</p>
<ul>
<li>空输入</li>
<li>单个元素</li>
<li>所有元素相同</li>
<li>无解的情况</li>
<li>多个解的情况</li>
</ul></li>
</ol>
<h2 id="qa-滑动窗口常见问题">❓ Q&amp;A: 滑动窗口常见问题</h2>
<h3 id="q1-什么时候应该使用滑动窗口">Q1: 什么时候应该使用滑动窗口？</h3>
<p><strong>A</strong>: 当你遇到以下关键词时，可以考虑滑动窗口：</p>
<ul>
<li><strong>连续子数组/子串</strong>：问题要求找到连续的区间</li>
<li><strong>最长/最短</strong>：需要找到满足条件的最长或最短区间</li>
<li><strong>固定大小</strong>：窗口大小固定（如长度为 k 的子数组）</li>
<li><strong>包含/不包含</strong>：窗口需要包含或不包含某些元素</li>
</ul>
<p>典型场景：</p>
<ul>
<li>字符串匹配、子串查找</li>
<li>数组中的连续子数组问题</li>
<li>需要维护窗口内某些统计信息的问题</li>
</ul>
<h3 id="q2-滑动窗口和双指针有什么区别">Q2:
滑动窗口和双指针有什么区别？</h3>
<p><strong>A</strong>: 滑动窗口是双指针技巧的一种特殊应用：</p>
<ul>
<li><strong>双指针</strong>：两个指针可以以任意方式移动（同向、反向、快慢指针等）</li>
<li><strong>滑动窗口</strong>：两个指针（left 和
right）维护一个连续的区间，通常 right 先移动，left 后移动</li>
</ul>
<p>滑动窗口可以看作是一种<strong>约束更严格的双指针</strong>，专门用于解决连续区间问题。</p>
<h3 id="q3-如何判断窗口应该扩大还是缩小">Q3:
如何判断窗口应该扩大还是缩小？</h3>
<p><strong>A</strong>: 这取决于问题的目标：</p>
<p><strong>寻找最长子串/子数组</strong>：</p>
<ul>
<li>先扩大窗口（移动 right），直到窗口不满足条件</li>
<li>然后缩小窗口（移动 left），直到窗口再次满足条件</li>
<li>在窗口满足条件时更新答案</li>
</ul>
<p><strong>寻找最短子串/子数组</strong>：</p>
<ul>
<li>先扩大窗口（移动 right），直到窗口满足条件</li>
<li>然后缩小窗口（移动 left），尝试找到更短的解</li>
<li>在窗口满足条件时更新答案</li>
</ul>
<p><strong>固定窗口大小</strong>：</p>
<ul>
<li>同时移动 left 和 right，保持窗口大小不变</li>
</ul>
<h3 id="q4-为什么滑动窗口的时间复杂度是-on-而不是-on²">Q4:
为什么滑动窗口的时间复杂度是 O(n) 而不是 O(n²)？</h3>
<p><strong>A</strong>: <code>left</code>
指针<strong>只会向前移动，不会后退</strong>。</p>
<p>虽然有一个 <code>while</code> 循环，但：</p>
<ul>
<li><code>right</code> 指针移动了 <span class="math inline">\(n\)</span>
次</li>
<li><code>left</code> 指针最多移动 <span class="math inline">\(n\)</span> 次（因为
<code>left &lt;= right</code>）</li>
</ul>
<p>总操作数 = <span class="math inline">\(n + n = 2n = O(n)\)</span></p>
<p>每个元素最多被访问两次（一次加入窗口，一次移出窗口），所以时间复杂度是
<span class="math inline">\(O(n)\)</span>。</p>
<h3 id="q5-如何处理窗口内有重复元素的情况">Q5:
如何处理窗口内有重复元素的情况？</h3>
<p><strong>A</strong>: 这取决于问题的要求：</p>
<p><strong>不允许重复</strong>（如"无重复字符的最长子串"）：</p>
<ul>
<li>使用哈希表记录每个元素的出现次数</li>
<li>当某个元素出现次数 &gt; 1 时，缩小窗口直到该元素只出现一次</li>
</ul>
<p><strong>允许重复但有限制</strong>（如"最多包含 k 个重复元素"）：</p>
<ul>
<li>使用哈希表记录每个元素的出现次数</li>
<li>当某个元素出现次数 &gt; k 时，缩小窗口</li>
</ul>
<p><strong>完全允许重复</strong>：</p>
<ul>
<li>不需要特殊处理，按正常逻辑即可</li>
</ul>
<h3 id="q6-valid-计数是什么为什么要用它">Q6: valid
计数是什么？为什么要用它？</h3>
<p><strong>A</strong>: <code>valid</code>
计数用于优化窗口条件的检查。</p>
<p><strong>不使用 valid</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次都要比较整个字典，时间复杂度 O(m)，其中 m 是字符集大小</span></span><br><span class="line"><span class="keyword">if</span> window == need:</span><br><span class="line">    <span class="comment"># 满足条件</span></span><br></pre></td></tr></table></figure>
<p><strong>使用 valid</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只需要检查 valid == len(need)，时间复杂度 O(1)</span></span><br><span class="line"><span class="keyword">if</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">    <span class="comment"># 满足条件</span></span><br></pre></td></tr></table></figure>
<p><code>valid</code> 表示窗口中<strong>恰好满足 <code>need</code>
条件的字符种类数</strong>。当 <code>valid == len(need)</code>
时，说明窗口中所有需要的字符都满足条件了。</p>
<h3 id="q7-滑动窗口可以解决哪些-leetcode-题目">Q7: 滑动窗口可以解决哪些
LeetCode 题目？</h3>
<p><strong>A</strong>: 以下是一些经典的滑动窗口题目：</p>
<p><strong>固定窗口大小</strong>：</p>
<ul>
<li><ol start="643" type="1">
<li>子数组最大平均值</li>
</ol></li>
<li><ol start="1343" type="1">
<li>大小为 K 且平均值大于等于阈值的子数组数目</li>
</ol></li>
<li><ol start="239" type="1">
<li>滑动窗口最大值（需要特殊数据结构）</li>
</ol></li>
</ul>
<p><strong>可变窗口大小（最长）</strong>：</p>
<ul>
<li><ol start="3" type="1">
<li>无重复字符的最长子串</li>
</ol></li>
<li><ol start="159" type="1">
<li>至多包含两个不同字符的最长子串</li>
</ol></li>
<li><ol start="340" type="1">
<li>至多包含 K 个不同字符的最长子串</li>
</ol></li>
</ul>
<p><strong>可变窗口大小（最短）</strong>：</p>
<ul>
<li><ol start="76" type="1">
<li>最小覆盖子串</li>
</ol></li>
<li><ol start="209" type="1">
<li>长度最小的子数组</li>
</ol></li>
<li><ol start="713" type="1">
<li>乘积小于K的子数组</li>
</ol></li>
</ul>
<p><strong>其他</strong>：</p>
<ul>
<li><ol start="567" type="1">
<li>字符串的排列</li>
</ol></li>
<li><ol start="438" type="1">
<li>找到字符串中所有字母异位词</li>
</ol></li>
<li><ol start="30" type="1">
<li>串联所有单词的子串</li>
</ol></li>
</ul>
<h3 id="q8-滑动窗口在字符串和数组问题中有什么区别">Q8:
滑动窗口在字符串和数组问题中有什么区别？</h3>
<p><strong>A</strong>:
本质上没有区别，都是维护一个连续的区间。主要区别在于：</p>
<p><strong>字符串问题</strong>：</p>
<ul>
<li>通常需要处理字符频率、字符匹配等</li>
<li>可能需要使用哈希表记录字符出现次数</li>
<li>窗口大小可能固定（如找固定长度的子串）或可变</li>
</ul>
<p><strong>数组问题</strong>：</p>
<ul>
<li>通常需要处理数值和、最大值、最小值等</li>
<li>可能需要维护窗口内的统计信息（和、积等）</li>
<li>窗口大小可能固定或可变</li>
</ul>
<p>核心思路是一样的：维护窗口状态，通过移动边界来遍历所有可能的子区间。</p>
<h3 id="q9-如何优化滑动窗口的空间复杂度">Q9:
如何优化滑动窗口的空间复杂度？</h3>
<p><strong>A</strong>: 几种优化方法：</p>
<ol type="1">
<li><strong>使用数组代替哈希表</strong>（如果字符集/数值范围较小）：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果字符都是小写字母，可以用数组代替哈希表</span></span><br><span class="line">count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">count[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>原地更新</strong>（如果不需要保留原数组）：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接在原数组上操作，不创建新数组</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>只记录必要信息</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只记录窗口内需要的信息，而不是所有信息</span></span><br><span class="line"><span class="comment"># 例如，只需要记录字符频率，不需要记录字符位置</span></span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><strong>使用 valid 计数</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 避免每次比较整个字典，减少空间和时间开销</span></span><br></pre></td></tr></table></figure>
<h3 id="q10-滑动窗口算法有哪些常见的变体">Q10:
滑动窗口算法有哪些常见的变体？</h3>
<p><strong>A</strong>: 常见的变体包括：</p>
<ol type="1">
<li><p><strong>多指针滑动窗口</strong>：</p>
<ul>
<li>使用三个或更多指针维护多个窗口</li>
<li>例如：同时维护多个不同大小的窗口</li>
</ul></li>
<li><p><strong>滑动窗口 + 数据结构</strong>：</p>
<ul>
<li>窗口内需要维护有序结构（如堆、平衡树）</li>
<li>例如：239. 滑动窗口最大值（需要维护窗口内的最大值）</li>
</ul></li>
<li><p><strong>滑动窗口 + 前缀和</strong>：</p>
<ul>
<li>结合前缀和优化窗口和的计算</li>
<li>例如：560. 和为K的子数组</li>
</ul></li>
<li><p><strong>滑动窗口 + 动态规划</strong>：</p>
<ul>
<li>窗口状态需要动态规划来维护</li>
<li>例如：一些复杂的字符串匹配问题</li>
</ul></li>
<li><p><strong>滑动窗口 + 二分查找</strong>：</p>
<ul>
<li>窗口大小不确定，需要二分查找最优大小</li>
<li>例如：某些优化问题</li>
</ul></li>
</ol>
<h2 id="变体与扩展问题">变体与扩展问题</h2>
<h3 id="变体一多窗口问题">变体一：多窗口问题</h3>
<p>有些问题需要同时维护多个窗口，或者在不同条件下使用不同的窗口策略。</p>
<p><strong>例题：至多包含两个不同字符的最长子串（LeetCode
159）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstringTwoDistinct</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">  </span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    char_count = &#123;&#125;</span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        char_count[s[right]] = char_count.get(s[right], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 当字符种类超过2时，缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(char_count) &gt; <span class="number">2</span>:</span><br><span class="line">            char_count[s[left]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> char_count[s[left]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> char_count[s[left]]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：使用 <code>len(char_count)</code>
来判断窗口内字符种类数，而不是用 <code>valid</code> 计数。</p>
<h3 id="变体二滑动窗口-前缀和">变体二：滑动窗口 + 前缀和</h3>
<p>当需要快速计算窗口和时，可以结合前缀和优化。</p>
<p><strong>例题：和为 K 的子数组（LeetCode 560）</strong></p>
<p>虽然这道题通常用哈希表解决，但也可以用滑动窗口的思想理解：维护一个窗口，当窗口和等于
K 时计数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">nums, k</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    prefix_sum = <span class="number">0</span></span><br><span class="line">    sum_map = &#123;<span class="number">0</span>: <span class="number">1</span>&#125;  <span class="comment"># 前缀和为0出现1次</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        prefix_sum += num</span><br><span class="line">        <span class="comment"># 如果存在前缀和 prefix_sum - k，说明存在子数组和为 k</span></span><br><span class="line">        <span class="keyword">if</span> prefix_sum - k <span class="keyword">in</span> sum_map:</span><br><span class="line">            count += sum_map[prefix_sum - k]</span><br><span class="line">        sum_map[prefix_sum] = sum_map.get(prefix_sum, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h3 id="变体三滑动窗口-双指针">变体三：滑动窗口 + 双指针</h3>
<p>有些问题需要结合双指针技巧，在窗口内进行更复杂的操作。</p>
<p><strong>例题：最小区间（LeetCode 632）</strong></p>
<p>需要在多个有序数组中找到包含每个数组至少一个元素的最小区间。可以用滑动窗口的思想，配合双指针在多个数组间移动。</p>
<h3 id="扩展问题推荐">扩展问题推荐</h3>
<ol type="1">
<li><p><strong>困难级别</strong>：</p>
<ul>
<li><ol start="30" type="1">
<li>串联所有单词的子串：固定窗口大小，但需要处理单词匹配</li>
</ol></li>
<li><ol start="76" type="1">
<li>最小覆盖子串：可变窗口，需要维护字符频率</li>
</ol></li>
<li><ol start="239" type="1">
<li>滑动窗口最大值：固定窗口，需要维护最大值（用单调队列）</li>
</ol></li>
</ul></li>
<li><p><strong>中等难度</strong>：</p>
<ul>
<li><ol start="159" type="1">
<li>至多包含两个不同字符的最长子串</li>
</ol></li>
<li><ol start="340" type="1">
<li>至多包含 K 个不同字符的最长子串</li>
</ol></li>
<li><ol start="424" type="1">
<li>替换后的最长重复字符</li>
</ol></li>
<li><ol start="713" type="1">
<li>乘积小于K的子数组</li>
</ol></li>
</ul></li>
<li><p><strong>简单级别</strong>：</p>
<ul>
<li><ol start="643" type="1">
<li>子数组最大平均值</li>
</ol></li>
<li><ol start="1343" type="1">
<li>大小为 K 且平均值大于等于阈值的子数组数目</li>
</ol></li>
</ul></li>
</ol>
<h2 id="实战建议">实战建议</h2>
<h3 id="如何快速识别滑动窗口问题">如何快速识别滑动窗口问题</h3>
<p>看到以下关键词时，优先考虑滑动窗口：</p>
<ul>
<li><strong>连续子数组/子串</strong>：问题明确要求连续区间</li>
<li><strong>最长/最短</strong>：需要找到满足条件的最长或最短区间</li>
<li><strong>固定长度</strong>：窗口大小固定（如长度为 k）</li>
<li><strong>包含/不包含</strong>：窗口需要包含或不包含某些元素</li>
<li><strong>和/积/频率</strong>：需要维护窗口内的统计信息</li>
</ul>
<h3 id="解题步骤">解题步骤</h3>
<ol type="1">
<li><p><strong>确定窗口类型</strong>：</p>
<ul>
<li>固定大小：窗口大小不变，同时移动左右边界</li>
<li>可变大小：先扩大窗口，满足条件后缩小</li>
</ul></li>
<li><p><strong>确定窗口状态</strong>：</p>
<ul>
<li>需要记录什么信息？（字符频率、和、最大值等）</li>
<li>用什么数据结构？（哈希表、数组、变量）</li>
</ul></li>
<li><p><strong>确定收缩条件</strong>：</p>
<ul>
<li>什么时候缩小窗口？</li>
<li>缩小到什么时候停止？</li>
</ul></li>
<li><p><strong>更新答案的时机</strong>：</p>
<ul>
<li>在扩大窗口时更新？</li>
<li>在缩小窗口时更新？</li>
<li>在满足条件时更新？</li>
</ul></li>
</ol>
<h3 id="常见陷阱与避免方法">常见陷阱与避免方法</h3>
<p><strong>陷阱一：窗口边界处理</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误：窗口长度计算错误</span></span><br><span class="line">window_len = right - left  <span class="comment"># 应该是 right - left + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确</span></span><br><span class="line">window_len = right - left + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>陷阱二：哈希表更新顺序</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误：先检查条件，再更新窗口</span></span><br><span class="line"><span class="keyword">if</span> window_satisfies_condition():</span><br><span class="line">    update_answer()</span><br><span class="line">    window.remove(s[left])  <span class="comment"># 应该在检查前更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：先更新窗口，再检查条件</span></span><br><span class="line">window.add(s[right])</span><br><span class="line"><span class="keyword">if</span> window_satisfies_condition():</span><br><span class="line">    update_answer()</span><br><span class="line">window.remove(s[left])</span><br></pre></td></tr></table></figure>
<p><strong>陷阱三：valid 计数错误</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误：没有检查是否恰好相等</span></span><br><span class="line"><span class="keyword">if</span> window[c] &gt;= need[c]:  <span class="comment"># 可能重复计数</span></span><br><span class="line">    valid += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：检查是否恰好相等</span></span><br><span class="line"><span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">    valid += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="调试技巧-1">调试技巧</h3>
<ol type="1">
<li><strong>打印窗口状态</strong>：在关键位置打印
<code>left</code>、<code>right</code>、窗口内容、窗口状态</li>
<li><strong>单步调试</strong>：使用调试器逐步执行，观察变量变化</li>
<li><strong>测试边界情况</strong>：空输入、单个元素、所有元素相同、无解情况</li>
<li><strong>对比暴力解法</strong>：先用暴力法验证思路，再优化为滑动窗口</li>
</ol>
<h3 id="性能优化建议">性能优化建议</h3>
<ol type="1">
<li><p><strong>空间优化</strong>：</p>
<ul>
<li>如果字符集小（如只有小写字母），用数组代替哈希表</li>
<li>如果只需要计数，不需要具体字符，用变量代替哈希表</li>
</ul></li>
<li><p><strong>时间优化</strong>：</p>
<ul>
<li>使用 <code>valid</code> 计数避免每次比较整个字典</li>
<li>提前终止：如果已经找到最优解，可以提前结束</li>
</ul></li>
<li><p><strong>代码优化</strong>：</p>
<ul>
<li>合并相似逻辑，减少重复代码</li>
<li>使用更高效的数据结构（如 <code>collections.defaultdict</code>）</li>
</ul></li>
</ol>
<h2 id="总结">总结</h2>
<p>滑动窗口是一种强大的算法技巧，特别适合解决连续子区间问题。掌握滑动窗口的要点：</p>
<ol type="1">
<li><strong>理解核心思想</strong>：维护一个窗口，通过移动边界遍历所有可能的子区间</li>
<li><strong>识别问题模式</strong>：固定窗口大小 vs 可变窗口大小，最长 vs
最短</li>
<li><strong>掌握模板代码</strong>：理解扩大窗口、缩小窗口、更新答案的时机</li>
<li><strong>注意边界条件</strong>：空输入、窗口大小、边界处理</li>
<li><strong>优化技巧</strong>：使用 valid 计数、数组代替哈希表等</li>
</ol>
<p>通过大量练习，你会发现滑动窗口是解决 LeetCode
中很多问题的"万能钥匙"。记住，算法学习是一个循序渐进的过程，多思考、多练习，你一定能掌握这个技巧！</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>本文标题：LeetCode（四）—— 滑动窗口技巧</li>
        <li>本文作者：Chen Kai</li>
        <li>创建时间：2023-05-29 00:00:00</li>
        <li>
            本文链接：https://www.chenk.top/LeetCode%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/LeetCode%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode（十）—— 栈与队列</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/LeetCode%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E6%9E%84%E9%80%A0/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode（六）—— 二叉树遍历与构造</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情赞美帅气伟大的ck吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- 由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">1.</span> <span class="nav-text">什么是滑动窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">2.</span> <span class="nav-text">滑动窗口的核心思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%E6%BC%94%E8%BF%9B%E4%BB%8E%E6%9A%B4%E5%8A%9B%E5%88%B0%E4%BC%98%E5%8C%96"><span class="nav-number">2.1.</span> <span class="nav-text">思路演进：从暴力到优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%81%AB%E8%BD%A6%E8%BD%A6%E5%8E%A2%E7%B1%BB%E6%AF%94"><span class="nav-number">2.2.</span> <span class="nav-text">火车车厢类比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E9%AB%98%E6%95%88%E6%80%A7%E6%9D%A5%E6%BA%90"><span class="nav-number">2.3.</span> <span class="nav-text">滑动窗口的高效性来源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">固定窗口大小问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81"><span class="nav-number">3.1.</span> <span class="nav-text">模板代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="nav-number">3.2.</span> <span class="nav-text">例题：子数组最大平均值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98%E5%A4%A7%E5%B0%8F%E4%B8%BA-k-%E4%B8%94%E5%B9%B3%E5%9D%87%E5%80%BC%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E9%98%88%E5%80%BC%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE"><span class="nav-number">3.3.</span> <span class="nav-text">例题：大小为 K
且平均值大于等于阈值的子数组数目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">可变窗口大小问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E6%94%B6%E7%BC%A9%E6%9D%A1%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.1.</span> <span class="nav-text">窗口收缩条件详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B6%E7%BC%A9%E6%97%B6%E6%9C%BA%E4%B8%89%E7%A7%8D%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF"><span class="nav-number">4.1.1.</span> <span class="nav-text">收缩时机：三种典型场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B6%E7%BC%A9%E6%9D%A1%E4%BB%B6%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="nav-number">4.1.2.</span> <span class="nav-text">收缩条件对比表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E6%94%B6%E7%BC%A9%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E"><span class="nav-number">4.1.3.</span> <span class="nav-text">窗口收缩的数学证明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">两种常见模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%AF%BB%E6%89%BE%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%AD%90%E6%95%B0%E7%BB%84%E7%AA%97%E5%8F%A3%E8%BF%9D%E5%8F%8D%E7%BA%A6%E6%9D%9F%E6%97%B6%E6%94%B6%E7%BC%A9"><span class="nav-number">4.2.1.</span> <span class="nav-text">模式一：寻找最长子串&#x2F;子数组（窗口违反约束时收缩）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E4%BA%8C%E5%AF%BB%E6%89%BE%E6%9C%80%E7%9F%AD%E5%AD%90%E4%B8%B2%E5%AD%90%E6%95%B0%E7%BB%84%E7%AA%97%E5%8F%A3%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E6%97%B6%E6%94%B6%E7%BC%A9"><span class="nav-number">4.2.2.</span> <span class="nav-text">模式二：寻找最短子串&#x2F;子数组（窗口满足条件时收缩）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%E9%80%9A%E7%94%A8"><span class="nav-number">4.3.</span> <span class="nav-text">模板代码（通用）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.</span> <span class="nav-text">经典题目详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%80%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">5.1.</span> <span class="nav-text">题目一：无重复字符的最长子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">5.2.</span> <span class="nav-text">复杂度分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%8C%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="nav-number">5.3.</span> <span class="nav-text">题目二：最小覆盖子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%89%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">5.4.</span> <span class="nav-text">题目三：长度最小的子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%9B%9B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">5.5.</span> <span class="nav-text">题目四：字符串的排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%94%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">5.6.</span> <span class="nav-text">题目五：找到字符串中所有字母异位词</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">6.</span> <span class="nav-text">时间复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%9E%90"><span class="nav-number">6.1.</span> <span class="nav-text">基本分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%91%8A%E8%BF%98%E5%88%86%E6%9E%90amortized-analysis"><span class="nav-number">6.2.</span> <span class="nav-text">摊还分析（Amortized Analysis）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E6%83%85%E5%86%B5%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">6.3.</span> <span class="nav-text">不同情况的时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%E4%B8%8E%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">7.</span> <span class="nav-text">常见陷阱与调试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%B8%80%E7%AA%97%E5%8F%A3%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-number">7.1.</span> <span class="nav-text">陷阱一：窗口边界处理错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%BA%8C%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9B%B4%E6%96%B0%E6%97%B6%E6%9C%BA%E9%94%99%E8%AF%AF"><span class="nav-number">7.2.</span> <span class="nav-text">陷阱二：哈希表更新时机错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%B8%89valid-%E8%AE%A1%E6%95%B0%E6%9B%B4%E6%96%B0%E9%94%99%E8%AF%AF"><span class="nav-number">7.3.</span> <span class="nav-text">陷阱三：valid 计数更新错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E5%9B%9B%E7%A9%BA%E7%AA%97%E5%8F%A3%E6%88%96%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6"><span class="nav-number">7.4.</span> <span class="nav-text">陷阱四：空窗口或边界条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">7.5.</span> <span class="nav-text">调试技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qa-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">8.</span> <span class="nav-text">❓ Q&amp;A: 滑动窗口常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#q1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">8.1.</span> <span class="nav-text">Q1: 什么时候应该使用滑动窗口？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">8.2.</span> <span class="nav-text">Q2:
滑动窗口和双指针有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q3-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%AA%97%E5%8F%A3%E5%BA%94%E8%AF%A5%E6%89%A9%E5%A4%A7%E8%BF%98%E6%98%AF%E7%BC%A9%E5%B0%8F"><span class="nav-number">8.3.</span> <span class="nav-text">Q3:
如何判断窗口应该扩大还是缩小？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q4-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF-on-%E8%80%8C%E4%B8%8D%E6%98%AF-on%C2%B2"><span class="nav-number">8.4.</span> <span class="nav-text">Q4:
为什么滑动窗口的时间复杂度是 O(n) 而不是 O(n²)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q5-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AA%97%E5%8F%A3%E5%86%85%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">8.5.</span> <span class="nav-text">Q5:
如何处理窗口内有重复元素的情况？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q6-valid-%E8%AE%A1%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%83"><span class="nav-number">8.6.</span> <span class="nav-text">Q6: valid
计数是什么？为什么要用它？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q7-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%93%AA%E4%BA%9B-leetcode-%E9%A2%98%E7%9B%AE"><span class="nav-number">8.7.</span> <span class="nav-text">Q7: 滑动窗口可以解决哪些
LeetCode 题目？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q8-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">8.8.</span> <span class="nav-text">Q8:
滑动窗口在字符串和数组问题中有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q9-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">8.9.</span> <span class="nav-text">Q9:
如何优化滑动窗口的空间复杂度？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q10-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%98%E4%BD%93"><span class="nav-number">8.10.</span> <span class="nav-text">Q10:
滑动窗口算法有哪些常见的变体？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%8E%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">变体与扩展问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%80%E5%A4%9A%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98"><span class="nav-number">9.1.</span> <span class="nav-text">变体一：多窗口问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%BA%8C%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">9.2.</span> <span class="nav-text">变体二：滑动窗口 + 前缀和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%89%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">9.3.</span> <span class="nav-text">变体三：滑动窗口 + 双指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98%E6%8E%A8%E8%8D%90"><span class="nav-number">9.4.</span> <span class="nav-text">扩展问题推荐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E5%BB%BA%E8%AE%AE"><span class="nav-number">10.</span> <span class="nav-text">实战建议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%AF%86%E5%88%AB%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98"><span class="nav-number">10.1.</span> <span class="nav-text">如何快速识别滑动窗口问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="nav-number">10.2.</span> <span class="nav-text">解题步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%E4%B8%8E%E9%81%BF%E5%85%8D%E6%96%B9%E6%B3%95"><span class="nav-number">10.3.</span> <span class="nav-text">常见陷阱与避免方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7-1"><span class="nav-number">10.4.</span> <span class="nav-text">调试技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-number">10.5.</span> <span class="nav-text">性能优化建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
