<!DOCTYPE html>



<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode（七）—— 回溯算法 |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"zh-CN","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode（七）—— 回溯算法</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-07-28 00:00:00</span>
        <span class="mobile">2023-07-28 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>9.2k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>36 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>回溯算法是解决组合优化问题的经典方法，在 LeetCode
中应用广泛。从全排列到 N
皇后，从子集生成到括号匹配，回溯算法以其清晰的递归结构和强大的搜索能力，成为解决这类问题的首选方案。本文将深入探讨回溯算法的核心思想、实现框架、优化技巧，并通过多个经典例题帮助读者掌握这一重要算法。</p>
<span id="more"></span>
<h2 id="什么是回溯算法">什么是回溯算法</h2>
<p>回溯算法（Backtracking）是一种通过探索所有可能的候选解来找出所有解的算法。当探索到某一步时，如果发现这个选择不能得到有效解，就回退一步，重新选择。回溯算法本质上是一种<strong>深度优先搜索（DFS）</strong>的特殊形式，区别在于回溯算法会在搜索过程中<strong>撤销之前的选择</strong>。</p>
<p>回溯算法的核心思想可以用一句话概括：<strong>尝试所有可能的选择，如果当前选择不可行，就回退并尝试下一个选择</strong>。这种"试错"的过程，就像走迷宫时遇到死胡同就返回上一个路口重新选择路径一样。</p>
<p>回溯算法的历史可以追溯到 19 世纪，但真正系统化是在 20 世纪 50
年代。回溯算法特别适合解决约束满足问题（Constraint Satisfaction
Problems, CSP），这类问题的特点是：</p>
<ul>
<li>变量之间存在约束关系</li>
<li>需要找到满足所有约束的解</li>
<li>解的数量可能是指数级的</li>
</ul>
<p>在计算机科学中，回溯算法被广泛应用于人工智能、编译器设计、组合数学等领域。在
LeetCode 中，回溯算法是解决排列、组合、子集等问题的标准方法。</p>
<h2 id="回溯与-dfs-的关系">回溯与 DFS 的关系</h2>
<p>很多初学者会困惑：回溯算法和深度优先搜索（DFS）有什么区别？实际上，回溯算法是
DFS 的一种应用形式。</p>
<p><strong>DFS</strong>
是一种遍历图或树的算法，它沿着一条路径尽可能深地搜索，直到无法继续，然后回溯到上一个节点继续搜索。DFS
的核心是<strong>遍历</strong>，目标是访问所有节点。</p>
<p><strong>回溯算法</strong> 在 DFS
的基础上，增加了<strong>状态恢复</strong>的机制。当我们做出一个选择后，会递归地探索后续的可能性；当递归返回时，需要撤销这个选择，恢复到之前的状态，以便尝试其他选择。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFS 遍历树（不需要恢复状态）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(node.val)  <span class="comment"># 访问节点</span></span><br><span class="line">    dfs(node.left)</span><br><span class="line">    dfs(node.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回溯算法（需要恢复状态）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        记录结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        path.append(choice)      <span class="comment"># 做选择</span></span><br><span class="line">        backtrack(path, choices) <span class="comment"># 递归</span></span><br><span class="line">        path.pop()               <span class="comment"># 撤销选择（关键！）</span></span><br></pre></td></tr></table></figure>
<p>回溯算法中的 <code>path.pop()</code>
就是状态恢复的关键。没有这一步，算法就无法正确地探索所有可能性。</p>
<h3 id="实际应用场景对比">实际应用场景对比</h3>
<p>为了更好地理解两者的区别，我们看一个具体例子：</p>
<p><strong>DFS
遍历二叉树</strong>：我们只需要访问每个节点一次，不需要恢复状态，因为每个节点的访问是独立的。</p>
<p><strong>回溯解决全排列</strong>：我们需要尝试所有可能的排列。当我们选择数字
1 后，需要尝试选择 2 和 3；尝试完以 1 开头的所有排列后，需要"撤销"对 1
的选择，尝试选择 2，然后尝试以 2
开头的所有排列。这里的"撤销"就是状态恢复。</p>
<h3 id="回溯算法的搜索树">回溯算法的搜索树</h3>
<p>回溯算法可以看作是在一棵隐式的搜索树上进行
DFS。树的每个节点代表一个状态，边代表一个选择。当我们到达一个叶子节点时，如果满足条件，就找到了一个解；如果不满足，就回溯到父节点，尝试其他分支。</p>
<p>例如，对于全排列 <code>[1,2,3]</code>，搜索树的第一层有三个分支（选择
1、2 或
3），第二层有两个分支（选择剩余的两个数字之一），第三层只有一个分支（选择最后一个数字）。整个搜索树有
<span class="math inline">\(3! = 6\)</span> 个叶子节点，对应 6
个排列。</p>
<h2 id="回溯算法的三要素">回溯算法的三要素</h2>
<p>理解回溯算法，需要掌握三个核心要素：<strong>选择（Choice）</strong>、<strong>约束（Constraint）</strong>、<strong>目标（Goal）</strong>。</p>
<h3 id="选择choice">选择（Choice）</h3>
<p>选择是指在当前状态下，我们可以做出的所有可能决策。例如：</p>
<ul>
<li>在全排列问题中，选择是"选择哪个数字放在当前位置"</li>
<li>在 N 皇后问题中，选择是"在当前位置放置皇后"</li>
<li>在组合问题中，选择是"是否包含当前元素"</li>
</ul>
<h3 id="约束constraint">约束（Constraint）</h3>
<p>约束是指限制我们做出选择的条件。只有满足约束条件的选择才是合法的。例如：</p>
<ul>
<li>全排列中，不能选择已经使用过的数字</li>
<li>N 皇后中，不能与已有皇后在同一行、列或对角线上</li>
<li>组合总和问题中，选择的数字之和不能超过目标值</li>
</ul>
<h3 id="目标goal">目标（Goal）</h3>
<p>目标是指我们想要达到的终止条件。当满足目标时，我们就找到了一个解。例如：</p>
<ul>
<li>全排列中，当路径长度等于数组长度时，得到一个排列</li>
<li>N 皇后中，当成功放置 N 个皇后时，得到一个解</li>
<li>子集问题中，当遍历完所有元素时，得到一个子集</li>
</ul>
<h2 id="回溯算法模板">回溯算法模板</h2>
<p>回溯算法有一个通用的模板，掌握这个模板可以解决大部分回溯问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">    <span class="comment"># 终止条件：找到解或无法继续</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        结果.append(path[:])  <span class="comment"># 注意：需要复制，不能直接 append(path)</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历所有可能的选择</span></span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        <span class="comment"># 剪枝：跳过不满足约束的选择</span></span><br><span class="line">        <span class="keyword">if</span> 不满足约束条件:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        path.append(choice)</span><br><span class="line">        <span class="comment"># 更新选择列表（如果需要）</span></span><br><span class="line">        <span class="comment"># new_choices = 更新后的选择列表</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        backtrack(path, new_choices)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 撤销选择（回溯）</span></span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>： 1.
<strong>结果保存</strong>：<code>path[:]</code> 创建了 <code>path</code>
的副本。如果直接 <code>append(path)</code>，由于 <code>path</code>
是引用，后续修改会影响已保存的结果。 2.
<strong>状态恢复</strong>：<code>path.pop()</code>
必须在递归返回后执行，确保回溯到上一个状态。 3.
<strong>剪枝优化</strong>：在循环中提前判断约束条件，避免无效递归。</p>
<h3 id="模板的变体">模板的变体</h3>
<p>根据问题的不同特点，模板会有一些变体：</p>
<p><strong>变体一：需要返回值的回溯</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 找到一个解就返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        <span class="keyword">if</span> 不满足约束条件:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        path.append(choice)</span><br><span class="line">        <span class="keyword">if</span> backtrack(path, new_choices):  <span class="comment"># 如果找到解，立即返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        path.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 所有选择都尝试过，无解</span></span><br></pre></td></tr></table></figure>
<p><strong>变体二：需要记录路径的回溯</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices, result</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.append(path[:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        <span class="keyword">if</span> 不满足约束条件:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        path.append(choice)</span><br><span class="line">        backtrack(path, new_choices, result)</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>
<p><strong>变体三：使用索引而非列表拷贝</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">index, path</span>):</span><br><span class="line">    <span class="keyword">if</span> index == <span class="built_in">len</span>(nums):</span><br><span class="line">        result.append(path[:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择1：不包含当前元素</span></span><br><span class="line">    backtrack(index + <span class="number">1</span>, path)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择2：包含当前元素</span></span><br><span class="line">    path.append(nums[index])</span><br><span class="line">    backtrack(index + <span class="number">1</span>, path)</span><br><span class="line">    path.pop()</span><br></pre></td></tr></table></figure>
<h2 id="经典问题一全排列">经典问题一：全排列</h2>
<p><strong>问题描述</strong>：给定一个不含重复数字的数组
<code>nums</code>，返回其所有可能的全排列。</p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</span><br></pre></td></tr></table></figure></p>
<p><strong>思路分析</strong>：</p>
<ul>
<li><strong>选择</strong>：当前位置可以选择哪些数字</li>
<li><strong>约束</strong>：不能选择已经使用过的数字</li>
<li><strong>目标</strong>：路径长度等于数组长度</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)  <span class="comment"># 标记哪些数字已使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>():</span><br><span class="line">        <span class="comment"># 终止条件：路径长度等于数组长度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历所有可能的选择</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 约束：跳过已使用的数字</span></span><br><span class="line">            <span class="keyword">if</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 做选择</span></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 递归</span></span><br><span class="line">            backtrack()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 撤销选择</span></span><br><span class="line">            path.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    backtrack()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n \times
n!)\)</span>，其中 <span class="math inline">\(n\)</span>
是数组长度。共有 <span class="math inline">\(n!\)</span>
个排列，每个排列需要 <span class="math inline">\(O(n)\)</span>
时间复制。</p>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，递归栈深度为 <span class="math inline">\(n\)</span>，<code>path</code> 和 <code>used</code>
数组各需要 <span class="math inline">\(O(n)\)</span> 空间。</p>
<h3 id="全排列问题的搜索过程">全排列问题的搜索过程</h3>
<p>让我们追踪一下 <code>permute([1,2,3])</code> 的执行过程：</p>
<ol type="1">
<li><p>初始状态：<code>path = []</code>,
<code>used = [False, False, False]</code></p></li>
<li><p>第一层递归：选择 1</p>
<ul>
<li><code>path = [1]</code>,
<code>used = [True, False, False]</code></li>
<li>第二层递归：选择 2
<ul>
<li><code>path = [1,2]</code>,
<code>used = [True, True, False]</code></li>
<li>第三层递归：选择 3
<ul>
<li><code>path = [1,2,3]</code> → 满足条件，保存结果</li>
<li>回溯：<code>path = [1,2]</code>,
<code>used = [True, True, False]</code></li>
</ul></li>
<li>回溯：<code>path = [1]</code>,
<code>used = [True, False, False]</code></li>
</ul></li>
<li>第二层递归：选择 3
<ul>
<li><code>path = [1,3]</code>,
<code>used = [True, False, True]</code></li>
<li>第三层递归：选择 2
<ul>
<li><code>path = [1,3,2]</code> → 满足条件，保存结果</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>回溯到第一层：<code>path = []</code>,
<code>used = [False, False, False]</code></p></li>
<li><p>第一层递归：选择 2（继续类似过程）...</p></li>
</ol>
<p>通过这个过程可以看出，回溯算法系统地探索了所有 <span class="math inline">\(3! = 6\)</span> 种可能性。</p>
<h3 id="全排列-ii包含重复元素">全排列 II（包含重复元素）</h3>
<p>如果数组包含重复元素，需要去重。有两种方法：</p>
<p><strong>方法一：排序 + 剪枝</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    nums.sort()  <span class="comment"># 排序，使相同元素相邻</span></span><br><span class="line">    used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 剪枝：如果当前数字与前一个相同，且前一个未使用，则跳过</span></span><br><span class="line">            <span class="comment"># 这确保了相同数字的相对顺序，避免重复</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            backtrack()</span><br><span class="line">            path.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    backtrack()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>方法二：使用集合去重</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        seen = <span class="built_in">set</span>()  <span class="comment"># 当前层已使用的数字</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> used[i] <span class="keyword">or</span> nums[i] <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            seen.add(nums[i])</span><br><span class="line">            </span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            backtrack()</span><br><span class="line">            path.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    backtrack()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="经典问题二组合总和">经典问题二：组合总和</h2>
<p><strong>问题描述</strong>：给定一个无重复元素的数组
<code>candidates</code> 和一个目标数 <code>target</code>，找出
<code>candidates</code> 中所有可以使数字和为 <code>target</code>
的组合。<code>candidates</code> 中的数字可以无限制重复被选取。</p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7</span><br><span class="line">输出: [[2,2,3], [7]]</span><br></pre></td></tr></table></figure></p>
<p><strong>思路分析</strong>：</p>
<ul>
<li><strong>选择</strong>：选择哪个数字加入当前组合</li>
<li><strong>约束</strong>：组合的和不能超过 <code>target</code></li>
<li><strong>目标</strong>：组合的和等于 <code>target</code></li>
</ul>
<p><strong>关键点</strong>：为了避免重复（如 <code>[2,3]</code> 和
<code>[3,2]</code>），我们需要保证选择的顺序性，即只从当前位置及之后选择，不从之前选择。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">candidates, target</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start, remain</span>):</span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> remain == <span class="number">0</span>:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> remain &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从 start 开始选择，避免重复</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(candidates)):</span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            <span class="comment"># 注意：可以重复使用，所以从 i 开始（不是 i+1）</span></span><br><span class="line">            backtrack(i, remain - candidates[i])</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：最坏情况下，每个数字都可以被选择多次，时间复杂度为
<span class="math inline">\(O(2^N)\)</span>，其中 <span class="math inline">\(N\)</span> 是 <code>target</code>
除以最小候选数的值。实际上，由于可以重复选择，搜索空间可能更大。</p>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(target)\)</span>，递归栈深度最多为
<code>target</code>（当每次都选择最小数字时）。</p>
<h3 id="组合总和问题的优化">组合总和问题的优化</h3>
<p>可以通过排序和提前终止来优化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">candidates, target</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    candidates.sort()  <span class="comment"># 排序，便于剪枝</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start, remain</span>):</span><br><span class="line">        <span class="keyword">if</span> remain == <span class="number">0</span>:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(candidates)):</span><br><span class="line">            <span class="comment"># 剪枝：如果当前数字已经大于剩余值，后续数字更大，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> candidates[i] &gt; remain:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 注意是 break 不是 continue，因为已排序</span></span><br><span class="line">            </span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            backtrack(i, remain - candidates[i])</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>这个优化利用了排序的性质：如果
<code>candidates[i] &gt; remain</code>，那么
<code>candidates[i+1]</code> 及之后的数字都大于
<code>remain</code>，可以直接终止循环。</p>
<h3 id="组合总和-ii每个数字只能使用一次">组合总和
II（每个数字只能使用一次）</h3>
<p>如果每个数字只能使用一次，且数组可能包含重复元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">candidates, target</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    candidates.sort()  <span class="comment"># 排序以便去重</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start, remain</span>):</span><br><span class="line">        <span class="keyword">if</span> remain == <span class="number">0</span>:</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> remain &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(candidates)):</span><br><span class="line">            <span class="comment"># 剪枝：跳过重复元素</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> candidates[i] == candidates[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            <span class="comment"># 每个数字只能用一次，所以从 i+1 开始</span></span><br><span class="line">            backtrack(i + <span class="number">1</span>, remain - candidates[i])</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="经典问题三子集">经典问题三：子集</h2>
<p><strong>问题描述</strong>：给定一个不含重复元素的整数数组
<code>nums</code>，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。</p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]</span><br></pre></td></tr></table></figure></p>
<p><strong>思路分析</strong>：
子集问题与组合问题的区别在于：组合问题有明确的终止条件（如达到某个长度），而子集问题的每个状态都是一个解。</p>
<p><strong>方法一：回溯法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start</span>):</span><br><span class="line">        <span class="comment"># 每个状态都是一个解</span></span><br><span class="line">        result.append(path[:])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从 start 开始选择，避免重复</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            backtrack(i + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>方法二：位运算</strong></p>
<p>对于小规模问题，也可以用位运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 每个数字对应一个 bit，共 2^n 种组合</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n):</span><br><span class="line">        subset = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i &amp; (<span class="number">1</span> &lt;&lt; j):</span><br><span class="line">                subset.append(nums[j])</span><br><span class="line">        result.append(subset)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n \times
2^n)\)</span>，共有 <span class="math inline">\(2^n\)</span>
个子集，每个子集需要 <span class="math inline">\(O(n)\)</span>
时间复制。</p>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，递归栈深度为 <span class="math inline">\(n\)</span>。</p>
<h3 id="子集问题的另一种理解">子集问题的另一种理解</h3>
<p>子集问题可以理解为：对于每个元素，我们有两个选择：包含或不包含。因此，对于
<span class="math inline">\(n\)</span> 个元素，共有 <span class="math inline">\(2^n\)</span> 种选择方式，对应 <span class="math inline">\(2^n\)</span> 个子集。</p>
<p>这种理解方式对应了另一种实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">index</span>):</span><br><span class="line">        <span class="comment"># 终止条件：处理完所有元素</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(nums):</span><br><span class="line">            result.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 选择1：不包含当前元素</span></span><br><span class="line">        backtrack(index + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 选择2：包含当前元素</span></span><br><span class="line">        path.append(nums[index])</span><br><span class="line">        backtrack(index + <span class="number">1</span>)</span><br><span class="line">        path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>这种实现方式更直观地体现了"每个元素有两个选择"的思想，但两种实现的时间复杂度相同。</p>
<h3 id="子集-ii包含重复元素">子集 II（包含重复元素）</h3>
<p>如果数组包含重复元素，需要去重：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    nums.sort()  <span class="comment"># 排序以便去重</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start</span>):</span><br><span class="line">        result.append(path[:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 剪枝：跳过重复元素</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            backtrack(i + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="经典问题四n-皇后">经典问题四：N 皇后</h2>
<p><strong>问题描述</strong>：<span class="math inline">\(n\)</span>
皇后问题研究的是如何将 <span class="math inline">\(n\)</span>
个皇后放置在 <span class="math inline">\(n \times n\)</span>
的棋盘上，并且使皇后彼此之间不能相互攻击（不能在同一行、同一列或同一对角线上）。</p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: [</span><br><span class="line"> [&quot;.Q..&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"> [&quot;..Q.&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p><strong>思路分析</strong>：</p>
<ul>
<li><strong>选择</strong>：在当前行选择哪一列放置皇后</li>
<li><strong>约束</strong>：不能与已有皇后在同一列或对角线上</li>
<li><strong>目标</strong>：成功放置 <span class="math inline">\(n\)</span> 个皇后</li>
</ul>
<p><strong>关键优化</strong>： 1. 使用集合记录已占用的列和对角线 2.
对角线判断：主对角线 <code>row - col</code> 为常数，副对角线
<code>row + col</code> 为常数</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">n</span>):</span><br><span class="line">    result = []</span><br><span class="line">    board = [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    cols = <span class="built_in">set</span>()  <span class="comment"># 已占用的列</span></span><br><span class="line">    diag1 = <span class="built_in">set</span>()  <span class="comment"># 主对角线：row - col</span></span><br><span class="line">    diag2 = <span class="built_in">set</span>()  <span class="comment"># 副对角线：row + col</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row</span>):</span><br><span class="line">        <span class="comment"># 终止条件：成功放置 n 个皇后</span></span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            result.append([<span class="string">&#x27;&#x27;</span>.join(row) <span class="keyword">for</span> row <span class="keyword">in</span> board])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 尝试在当前行的每一列放置皇后</span></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 约束检查</span></span><br><span class="line">            <span class="keyword">if</span> col <span class="keyword">in</span> cols <span class="keyword">or</span> (row - col) <span class="keyword">in</span> diag1 <span class="keyword">or</span> (row + col) <span class="keyword">in</span> diag2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 做选择</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">            cols.add(col)</span><br><span class="line">            diag1.add(row - col)</span><br><span class="line">            diag2.add(row + col)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 递归</span></span><br><span class="line">            backtrack(row + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 撤销选择</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">            cols.remove(col)</span><br><span class="line">            diag1.remove(row - col)</span><br><span class="line">            diag2.remove(row + col)</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n!)\)</span>，第一行有 <span class="math inline">\(n\)</span> 种选择，第二行最多 <span class="math inline">\(n-1\)</span>
种，以此类推。实际上，由于约束条件的存在，实际搜索的节点数会远小于 <span class="math inline">\(n!\)</span>。</p>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，递归栈深度为 <span class="math inline">\(n\)</span>，集合和棋盘各需要 <span class="math inline">\(O(n)\)</span> 空间。</p>
<h3 id="n-皇后问题的优化技巧">N 皇后问题的优化技巧</h3>
<p><strong>优化一：使用位运算</strong></p>
<p>对于小规模的 N 皇后问题，可以使用位运算来加速约束检查：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">n</span>):</span><br><span class="line">    result = []</span><br><span class="line">    board = [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row, cols, diag1, diag2</span>):</span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            result.append([<span class="string">&#x27;&#x27;</span>.join(row) <span class="keyword">for</span> row <span class="keyword">in</span> board])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算可用的列</span></span><br><span class="line">        available = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &amp; (~(cols | diag1 | diag2))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> available:</span><br><span class="line">            <span class="comment"># 获取最低位的 1</span></span><br><span class="line">            col = available &amp; -available</span><br><span class="line">            col_index = <span class="built_in">bin</span>(col - <span class="number">1</span>).count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            board[row][col_index] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">            backtrack(row + <span class="number">1</span>, </span><br><span class="line">                     cols | col, </span><br><span class="line">                     (diag1 | col) &lt;&lt; <span class="number">1</span>, </span><br><span class="line">                     (diag2 | col) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            board[row][col_index] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 移除最低位的 1</span></span><br><span class="line">            available &amp;= available - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>优化二：只统计解的个数</strong></p>
<p>如果只需要统计解的个数而不需要具体解，可以进一步优化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">totalNQueens</span>(<span class="params">n</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    cols = <span class="built_in">set</span>()</span><br><span class="line">    diag1 = <span class="built_in">set</span>()</span><br><span class="line">    diag2 = <span class="built_in">set</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> col <span class="keyword">in</span> cols <span class="keyword">or</span> (row - col) <span class="keyword">in</span> diag1 <span class="keyword">or</span> (row + col) <span class="keyword">in</span> diag2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            cols.add(col)</span><br><span class="line">            diag1.add(row - col)</span><br><span class="line">            diag2.add(row + col)</span><br><span class="line">            backtrack(row + <span class="number">1</span>)</span><br><span class="line">            cols.remove(col)</span><br><span class="line">            diag1.remove(row - col)</span><br><span class="line">            diag2.remove(row + col)</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p>这种优化避免了构建和保存棋盘状态，只统计解的个数，空间复杂度更低。</p>
<h2 id="经典问题五括号生成">经典问题五：括号生成</h2>
<p><strong>问题描述</strong>：数字 <span class="math inline">\(n\)</span>
代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。</p>
<p><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 3</span><br><span class="line">输出: [&quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;]</span><br></pre></td></tr></table></figure></p>
<p><strong>思路分析</strong>：</p>
<ul>
<li><strong>选择</strong>：当前位置放置左括号还是右括号</li>
<li><strong>约束</strong>：
<ul>
<li>左括号数量不能超过 <span class="math inline">\(n\)</span></li>
<li>右括号数量不能超过左括号数量</li>
</ul></li>
<li><strong>目标</strong>：生成长度为 <span class="math inline">\(2n\)</span> 的有效括号序列</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">n</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">left, right</span>):</span><br><span class="line">        <span class="comment"># 终止条件：生成长度为 2n 的序列</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">2</span> * n:</span><br><span class="line">            result.append(<span class="string">&#x27;&#x27;</span>.join(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 选择1：放置左括号</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; n:</span><br><span class="line">            path.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            backtrack(left + <span class="number">1</span>, right)</span><br><span class="line">            path.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 选择2：放置右括号（需要满足约束）</span></span><br><span class="line">        <span class="keyword">if</span> right &lt; left:</span><br><span class="line">            path.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            backtrack(left, right + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(\frac{4^n}{\sqrt{n}})\)</span>，这是第 <span class="math inline">\(n\)</span> 个卡特兰数的渐近复杂度。第 <span class="math inline">\(n\)</span> 个卡特兰数 <span class="math inline">\(C_n = \frac{1}{n+1}\binom{2n}{n} =
\frac{(2n)!}{(n+1)!n!}\)</span>。</p>
<p><strong>空间复杂度</strong>：<span class="math inline">\(O(n)\)</span>，递归栈深度最多为 <span class="math inline">\(2n\)</span>。</p>
<h3 id="括号生成问题的数学背景">括号生成问题的数学背景</h3>
<p>括号生成问题与<strong>卡特兰数（Catalan Number）</strong>密切相关。第
<span class="math inline">\(n\)</span> 个卡特兰数表示 <span class="math inline">\(n\)</span>
对括号可以组成的不同有效括号序列的数量。</p>
<p>卡特兰数在组合数学中有很多应用：</p>
<ul>
<li><span class="math inline">\(n\)</span> 对括号的有效序列数</li>
<li><span class="math inline">\(n\)</span>
个节点的不同二叉搜索树数量</li>
<li><span class="math inline">\(n+2\)</span> 边形的三角剖分数</li>
<li>在 <span class="math inline">\(n \times n\)</span>
网格中，从左下角到右上角不越过对角线的路径数</li>
</ul>
<h3 id="括号生成问题的其他解法">括号生成问题的其他解法</h3>
<p><strong>方法一：动态规划</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> left <span class="keyword">in</span> generateParenthesis(i):</span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> generateParenthesis(n - <span class="number">1</span> - i):</span><br><span class="line">                result.append(<span class="string">&#x27;(&#x27;</span> + left + <span class="string">&#x27;)&#x27;</span> + right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>这种方法的思路是：第一个括号内包含 <span class="math inline">\(i\)</span> 对括号，第一个括号外包含 <span class="math inline">\(n-1-i\)</span> 对括号。</p>
<p><strong>方法二：迭代生成</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">n</span>):</span><br><span class="line">    result = [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * n):</span><br><span class="line">        new_result = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> result:</span><br><span class="line">            left_count = s.count(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            right_count = s.count(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> left_count &lt; n:</span><br><span class="line">                new_result.append(s + <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> right_count &lt; left_count:</span><br><span class="line">                new_result.append(s + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        result = new_result</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>这种方法逐字符生成，每次添加一个左括号或右括号，保证始终满足约束条件。</p>
<h2 id="剪枝优化技巧">剪枝优化技巧</h2>
<p>剪枝是回溯算法优化的重要手段，通过提前排除不可能的分支，大幅减少搜索空间。</p>
<h3 id="约束剪枝">1. 约束剪枝</h3>
<p>在进入递归前检查约束条件，不满足则跳过：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">    <span class="keyword">if</span> 不满足约束条件:  <span class="comment"># 剪枝</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 做选择并递归</span></span><br></pre></td></tr></table></figure>
<p><strong>示例</strong>：组合总和问题中，如果剩余值小于
0，直接返回。</p>
<h3 id="重复剪枝">2. 重复剪枝</h3>
<p>对于包含重复元素的问题，通过排序和跳过相同元素避免重复：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 跳过重复元素</span></span><br></pre></td></tr></table></figure>
<h3 id="可行性剪枝">3. 可行性剪枝</h3>
<p>提前判断当前分支是否可能产生解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果剩余元素不足以构成解，剪枝</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) + (n - i) &lt; target_length:</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h3 id="上下界剪枝">4. 上下界剪枝</h3>
<p>在搜索过程中维护上下界，提前排除不可能的范围：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前和 + 剩余最大和 &lt; target，剪枝</span></span><br><span class="line"><span class="keyword">if</span> current_sum + max_remaining_sum &lt; target:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="comment"># 当前和 + 剩余最小和 &gt; target，剪枝</span></span><br><span class="line"><span class="keyword">if</span> current_sum + min_remaining_sum &gt; target:</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h3 id="对称性剪枝">5. 对称性剪枝</h3>
<p>利用问题的对称性减少搜索：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如：全排列中，如果 nums[i] == nums[j]，且 i &lt; j</span></span><br><span class="line"><span class="comment"># 那么选择 nums[i] 和 nums[j] 的结果是对称的</span></span><br><span class="line"><span class="comment"># 可以只选择其中一个</span></span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析">时间复杂度分析</h2>
<p>回溯算法的时间复杂度分析通常比较复杂，因为需要分析所有可能的搜索路径。</p>
<h3 id="一般分析方法">一般分析方法</h3>
<ol type="1">
<li><strong>确定搜索树的大小</strong>：有多少个节点？</li>
<li><strong>确定每个节点的处理时间</strong>：生成子节点需要多少时间？</li>
<li><strong>总时间复杂度</strong> = 节点数 × 每个节点的处理时间</li>
</ol>
<h3 id="常见复杂度">常见复杂度</h3>
<ul>
<li><strong>全排列</strong>：<span class="math inline">\(O(n \times
n!)\)</span>
<ul>
<li>共有 <span class="math inline">\(n!\)</span> 个叶子节点（排列）</li>
<li>每个排列需要 <span class="math inline">\(O(n)\)</span> 时间复制</li>
</ul></li>
<li><strong>子集</strong>：<span class="math inline">\(O(n \times
2^n)\)</span>
<ul>
<li>共有 <span class="math inline">\(2^n\)</span> 个子集</li>
<li>每个子集需要 <span class="math inline">\(O(n)\)</span> 时间复制</li>
</ul></li>
<li><strong>组合</strong>：<span class="math inline">\(O(C(n,k) \times
k)\)</span>
<ul>
<li>共有 <span class="math inline">\(C(n,k)\)</span> 个组合</li>
<li>每个组合需要 <span class="math inline">\(O(k)\)</span> 时间复制</li>
</ul></li>
<li><strong>N 皇后</strong>：<span class="math inline">\(O(n!)\)</span>
<ul>
<li>第一行 <span class="math inline">\(n\)</span> 种选择，第二行最多
<span class="math inline">\(n-1\)</span> 种，以此类推</li>
</ul></li>
</ul>
<h3 id="优化后的复杂度">优化后的复杂度</h3>
<p>剪枝可以大幅减少实际搜索的节点数，但最坏情况复杂度通常不变。平均情况下，剪枝可能将复杂度降低一个数量级。</p>
<h2 id="更多经典问题">更多经典问题</h2>
<h3 id="单词搜索">单词搜索</h3>
<p><strong>问题描述</strong>：给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中"相邻"单元格是那些水平相邻或垂直相邻的单元格。</p>
<p><strong>思路</strong>：从网格的每个位置开始，使用回溯算法搜索单词。需要标记已访问的单元格，回溯时恢复状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">board, word</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row, col, index</span>):</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> row &gt;= m <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> col &gt;= n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> board[row][col] != word[index]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 标记为已访问</span></span><br><span class="line">        temp = board[row][col]</span><br><span class="line">        board[row][col] = <span class="string">&#x27;#&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 尝试四个方向</span></span><br><span class="line">        <span class="keyword">for</span> dr, dc <span class="keyword">in</span> directions:</span><br><span class="line">            <span class="keyword">if</span> backtrack(row + dr, col + dc, index + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 回溯：恢复状态</span></span><br><span class="line">        board[row][col] = temp</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> backtrack(i, j, <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="数独求解">数独求解</h3>
<p><strong>问题描述</strong>：编写一个程序，通过已填充的空格来解决数独问题。数独的解法需遵循规则：数字
1-9 在每一行、每一列和每一个 3x3 宫格内只能出现一次。</p>
<p><strong>思路</strong>：使用回溯算法，逐个填充空格。对于每个空格，尝试
1-9 的所有可能值，检查是否满足约束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solveSudoku</span>(<span class="params">board</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">row, col, num</span>):</span><br><span class="line">        <span class="comment"># 检查行</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[row][j] == num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[i][col] == num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查 3x3 宫格</span></span><br><span class="line">        start_row, start_col = (row // <span class="number">3</span>) * <span class="number">3</span>, (col // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_row, start_row + <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(start_col, start_col + <span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == num:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="string">&#x27;123456789&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span> isValid(i, j, num):</span><br><span class="line">                            board[i][j] = num</span><br><span class="line">                            <span class="keyword">if</span> backtrack():</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                            board[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    backtrack()</span><br></pre></td></tr></table></figure>
<h3 id="复原-ip-地址">复原 IP 地址</h3>
<p><strong>问题描述</strong>：给定一个只包含数字的字符串，复原它并返回所有可能的
IP 地址格式。</p>
<p><strong>思路</strong>：使用回溯算法，将字符串分成四段，每段是 0-255
之间的数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">s</span>):</span><br><span class="line">    result = []</span><br><span class="line">    path = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">start</span>):</span><br><span class="line">        <span class="comment"># 终止条件：分成四段且用完所有字符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> start == <span class="built_in">len</span>(s):</span><br><span class="line">                result.append(<span class="string">&#x27;.&#x27;</span>.join(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每段最多 3 位数字</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">min</span>(start + <span class="number">3</span>, <span class="built_in">len</span>(s))):</span><br><span class="line">            segment = s[start:end + <span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 约束检查</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(segment) &gt; <span class="number">1</span> <span class="keyword">and</span> segment[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:  <span class="comment"># 不能有前导 0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(segment) &gt; <span class="number">255</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            path.append(segment)</span><br><span class="line">            backtrack(end + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="常见陷阱与注意事项">常见陷阱与注意事项</h2>
<h3 id="结果保存时未复制">1. 结果保存时未复制</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误</span></span><br><span class="line">result.append(path)  <span class="comment"># path 是引用，后续修改会影响已保存的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line">result.append(path[:])  <span class="comment"># 创建副本</span></span><br></pre></td></tr></table></figure>
<h3 id="状态恢复不完整">2. 状态恢复不完整</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：忘记恢复 used 数组</span></span><br><span class="line">path.pop()</span><br><span class="line"><span class="comment"># used[i] = False  # 遗漏！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line">path.pop()</span><br><span class="line">used[i] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="剪枝条件错误">3. 剪枝条件错误</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：去重剪枝条件写反</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>] <span class="keyword">and</span> used[i-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">continue</span>  <span class="comment"># 应该是 not used[i-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<h3 id="选择列表更新错误">4. 选择列表更新错误</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：在组合问题中从 0 开始选择，导致重复</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):  <span class="comment"># 应该从 start 开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br></pre></td></tr></table></figure>
<h3 id="终止条件遗漏">5. 终止条件遗漏</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：忘记检查边界条件</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">    result.append(path[:])</span><br><span class="line">    <span class="comment"># return  # 遗漏！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">    result.append(path[:])</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h2 id="回溯算法的迭代实现">回溯算法的迭代实现</h2>
<p>虽然回溯算法通常用递归实现，但也可以使用迭代方式。迭代实现使用显式栈来模拟递归调用。</p>
<h3 id="全排列的迭代实现">全排列的迭代实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute_iterative</span>(<span class="params">nums</span>):</span><br><span class="line">    result = []</span><br><span class="line">    stack = [([], [<span class="literal">False</span>] * <span class="built_in">len</span>(nums))]  <span class="comment"># (path, used)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        path, used = stack.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            result.append(path)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                new_path = path + [nums[i]]</span><br><span class="line">                new_used = used[:]</span><br><span class="line">                new_used[i] = <span class="literal">True</span></span><br><span class="line">                stack.append((new_path, new_used))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="子集的迭代实现">子集的迭代实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subsets_iterative</span>(<span class="params">nums</span>):</span><br><span class="line">    result = [[]]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># 对于已有的每个子集，添加当前数字形成新子集</span></span><br><span class="line">        new_subsets = []</span><br><span class="line">        <span class="keyword">for</span> subset <span class="keyword">in</span> result:</span><br><span class="line">            new_subsets.append(subset + [num])</span><br><span class="line">        result.extend(new_subsets)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>迭代实现的优势：</p>
<ul>
<li>避免栈溢出问题</li>
<li>可以更好地控制搜索顺序</li>
<li>在某些情况下可能更高效</li>
</ul>
<p>迭代实现的劣势：</p>
<ul>
<li>代码通常更复杂</li>
<li>状态管理更困难</li>
<li>对于复杂问题，递归实现更直观</li>
</ul>
<h2 id="回溯算法与其他算法的关系">回溯算法与其他算法的关系</h2>
<h3 id="回溯-vs-动态规划">回溯 vs 动态规划</h3>
<p>回溯算法和动态规划都用于解决优化问题，但适用场景不同：</p>
<ul>
<li><strong>回溯算法</strong>：需要找出<strong>所有解</strong>，时间复杂度通常是指数级</li>
<li><strong>动态规划</strong>：需要找出<strong>最优解</strong>，通过记忆化将时间复杂度降低到多项式级</li>
</ul>
<p>有些问题既可以用回溯也可以用动态规划，选择取决于需求：</p>
<ul>
<li>如果需要所有解：用回溯</li>
<li>如果只需要最优解：用动态规划</li>
</ul>
<h3 id="回溯-vs-贪心算法">回溯 vs 贪心算法</h3>
<p>回溯算法和贪心算法都通过做选择来解决问题：</p>
<ul>
<li><strong>回溯算法</strong>：系统地尝试所有选择，如果当前选择不可行就回溯</li>
<li><strong>贪心算法</strong>：每次选择当前看起来最优的选择，不回溯</li>
</ul>
<p>贪心算法通常更快，但只能保证局部最优，不一定得到全局最优解。回溯算法虽然慢，但可以保证找到所有解或全局最优解。</p>
<h3 id="回溯-vs-分支限界">回溯 vs 分支限界</h3>
<p>回溯算法和分支限界（Branch and Bound）都是搜索算法：</p>
<ul>
<li><strong>回溯算法</strong>：深度优先搜索，找到解后继续搜索其他解</li>
<li><strong>分支限界</strong>：广度优先或最佳优先搜索，使用界限函数剪枝</li>
</ul>
<p>分支限界通常用于优化问题，通过界限函数提前排除不可能产生最优解的分支。</p>
<h2 id="实战技巧总结">实战技巧总结</h2>
<ol type="1">
<li><p><strong>先画搜索树</strong>：在编码前画出问题的搜索树，理解选择、约束和目标。</p></li>
<li><p><strong>使用模板</strong>：掌握回溯模板，大部分问题都可以套用。</p></li>
<li><p><strong>注意去重</strong>：对于包含重复元素的问题，排序 +
剪枝是常用方法。</p></li>
<li><p><strong>合理剪枝</strong>：根据问题特点设计剪枝策略，可以大幅提升效率。</p></li>
<li><p><strong>状态管理</strong>：使用合适的数据结构（集合、数组）管理状态，提高约束检查效率。</p></li>
<li><p><strong>边界处理</strong>：仔细处理边界条件，避免数组越界或无限递归。</p></li>
<li><p><strong>调试技巧</strong>：在关键位置打印 <code>path</code>
和选择列表，理解搜索过程。</p></li>
</ol>
<h2 id="qa-回溯算法常见问题">❓ Q&amp;A: 回溯算法常见问题</h2>
<h3 id="q1-回溯算法和-dfs-有什么区别">Q1: 回溯算法和 DFS
有什么区别？</h3>
<p><strong>A</strong>: 回溯算法是 DFS 的一种应用形式。DFS
专注于遍历所有节点，而回溯算法在 DFS
的基础上增加了<strong>状态恢复</strong>机制。回溯算法在递归返回时会撤销之前的选择，恢复到上一个状态，以便尝试其他可能性。没有状态恢复的
DFS 无法解决需要探索所有可能组合的问题。</p>
<h3 id="q2-为什么回溯算法中要用-path-而不是-path">Q2:
为什么回溯算法中要用 <code>path[:]</code> 而不是
<code>path</code>？</h3>
<p><strong>A</strong>: <code>path</code> 是一个列表引用，如果直接
<code>append(path)</code>，保存的是同一个引用。当后续修改
<code>path</code> 时（如
<code>path.pop()</code>），已保存的结果也会被修改。<code>path[:]</code>
创建了 <code>path</code>
的浅拷贝，保存的是独立的副本，后续修改不会影响已保存的结果。</p>
<h3 id="q3-如何判断一个问题是否适合用回溯算法">Q3:
如何判断一个问题是否适合用回溯算法？</h3>
<p><strong>A</strong>: 适合用回溯算法的问题通常具有以下特征： 1.
需要找出所有可能的解（而不是单一最优解） 2. 解可以表示为一系列选择 3.
选择之间有约束关系 4. 可以通过试错的方式探索所有可能性</p>
<p>典型问题包括：排列、组合、子集、N 皇后、数独、括号生成等。</p>
<h3 id="q4-回溯算法的时间复杂度如何分析">Q4:
回溯算法的时间复杂度如何分析？</h3>
<p><strong>A</strong>: 回溯算法的时间复杂度通常是指数级的。分析方法： 1.
确定搜索树的节点数（通常是 <span class="math inline">\(O(2^n)\)</span>
或 <span class="math inline">\(O(n!)\)</span>） 2.
确定每个节点的处理时间（通常是 <span class="math inline">\(O(n)\)</span>
或 <span class="math inline">\(O(1)\)</span>） 3. 总复杂度 = 节点数 ×
每个节点的处理时间</p>
<p>例如，全排列问题有 <span class="math inline">\(n!\)</span>
个叶子节点，每个节点需要 <span class="math inline">\(O(n)\)</span>
时间，总复杂度为 <span class="math inline">\(O(n \times
n!)\)</span>。</p>
<h3 id="q5-如何优化回溯算法的性能">Q5: 如何优化回溯算法的性能？</h3>
<p><strong>A</strong>: 主要优化方法： 1.
<strong>剪枝</strong>：提前排除不可能的分支 2.
<strong>排序</strong>：对输入排序，便于去重和剪枝 3.
<strong>记忆化</strong>：对于重叠子问题，使用记忆化避免重复计算 4.
<strong>约束传播</strong>：利用约束关系提前缩小搜索空间 5.
<strong>启发式搜索</strong>：优先探索更可能产生解的分支</p>
<h3 id="q6-去重剪枝中-usedi-1-的判断逻辑是什么">Q6: 去重剪枝中
<code>used[i-1]</code> 的判断逻辑是什么？</h3>
<p><strong>A</strong>:
在包含重复元素的排列/组合问题中，排序后相同元素会相邻。去重策略是：如果当前元素与前一个元素相同，且前一个元素<strong>未被使用</strong>，则跳过当前元素。</p>
<p>这是因为：如果前一个相同元素未被使用，说明我们在同一层已经尝试过选择它，当前选择会产生重复结果。如果前一个元素已被使用，说明我们在上一层选择了它，当前选择是合法的（因为位置不同）。</p>
<h3 id="q7-组合问题中为什么要从-start-开始选择">Q7: 组合问题中为什么要从
<code>start</code> 开始选择？</h3>
<p><strong>A</strong>:
组合问题要求结果中元素的顺序不重要（<code>[1,2]</code> 和
<code>[2,1]</code> 是同一个组合）。如果从 0
开始选择，会产生重复。例如选择 2 后再选择 1，和选择 1 后再选择 2
是重复的。</p>
<p>从 <code>start</code>
开始选择保证了我们总是按照数组的顺序选择元素，避免了重复组合。每次递归时，<code>start</code>
递增，确保不会选择之前的元素。</p>
<h3 id="q8-回溯算法会栈溢出吗">Q8: 回溯算法会栈溢出吗？</h3>
<p><strong>A</strong>:
可能会。回溯算法使用递归实现，递归深度等于问题的规模。对于大规模问题（如
<span class="math inline">\(n &gt; 20\)</span>
的全排列），递归深度可能很大，导致栈溢出。</p>
<p>解决方法： 1. <strong>迭代实现</strong>：使用显式栈模拟递归 2.
<strong>限制深度</strong>：对于超大规模问题，考虑其他算法 3.
<strong>尾递归优化</strong>：某些语言支持尾递归优化（但 Python
不支持）</p>
<h3 id="q9-如何将回溯算法改为迭代实现">Q9:
如何将回溯算法改为迭代实现？</h3>
<p><strong>A</strong>: 使用显式栈模拟递归过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack_iterative</span>():</span><br><span class="line">    stack = [(初始状态)]</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        state = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">            result.append(state)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">            <span class="keyword">if</span> 满足约束:</span><br><span class="line">                new_state = 更新状态(state, choice)</span><br><span class="line">                stack.append(new_state)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>迭代实现的优势是避免了栈溢出，但代码通常更复杂，状态管理也更困难。</p>
<h3 id="q10-回溯算法可以解决动态规划问题吗">Q10:
回溯算法可以解决动态规划问题吗？</h3>
<p><strong>A</strong>:
理论上可以，但不推荐。回溯算法会探索所有可能的路径，时间复杂度通常是指数级的。动态规划通过记忆化和状态转移，将时间复杂度降低到多项式级别。</p>
<p>例如，0-1 背包问题可以用回溯解决（<span class="math inline">\(O(2^n)\)</span>），但用动态规划可以优化到 <span class="math inline">\(O(n \times
W)\)</span>。只有在需要找出所有解（而不是最优解）时，回溯算法才有优势。</p>
<h3 id="q11-如何调试回溯算法">Q11: 如何调试回溯算法？</h3>
<p><strong>A</strong>: 调试回溯算法的几个技巧：</p>
<ol type="1">
<li><strong>打印路径和状态</strong>：在关键位置打印
<code>path</code>、<code>used</code> 等状态变量</li>
<li><strong>使用调试器</strong>：设置断点，单步执行，观察状态变化</li>
<li><strong>可视化搜索树</strong>：画出问题的搜索树，理解算法的执行流程</li>
<li><strong>小规模测试</strong>：先用小规模数据测试，验证逻辑正确性</li>
<li><strong>对比结果</strong>：与已知正确答案对比，找出差异</li>
</ol>
<h3 id="q12-回溯算法的时间复杂度总是指数级的吗">Q12:
回溯算法的时间复杂度总是指数级的吗？</h3>
<p><strong>A</strong>:
不一定。虽然回溯算法在最坏情况下通常是指数级复杂度，但通过有效的剪枝，实际运行时间可能远小于理论最坏情况。</p>
<p>例如，N 皇后问题的理论复杂度是 <span class="math inline">\(O(n!)\)</span>，但由于约束条件的存在，实际搜索的节点数远小于
<span class="math inline">\(n!\)</span>。对于 <span class="math inline">\(n=8\)</span>，理论上有 <span class="math inline">\(8! = 40320\)</span> 种可能，但实际只需要搜索约
2000 个节点就能找到所有解。</p>
<h3 id="q13-如何选择回溯算法的数据结构">Q13:
如何选择回溯算法的数据结构？</h3>
<p><strong>A</strong>: 选择合适的数据结构可以提升效率：</p>
<ul>
<li><strong>路径存储</strong>：使用列表 <code>list</code>，支持高效的
<code>append</code> 和 <code>pop</code></li>
<li><strong>已访问标记</strong>：使用集合 <code>set</code>
或布尔数组，根据操作频率选择</li>
<li><strong>约束检查</strong>：使用集合可以 <span class="math inline">\(O(1)\)</span> 时间检查，比列表更高效</li>
<li><strong>去重</strong>：使用集合去重，或排序后使用剪枝</li>
</ul>
<p>例如，在全排列问题中，如果频繁检查数字是否已使用，用集合比列表更高效。</p>
<h3 id="q14-回溯算法可以并行化吗">Q14: 回溯算法可以并行化吗？</h3>
<p><strong>A</strong>:
可以，但需要谨慎设计。回溯算法的并行化主要有两种方式：</p>
<ol type="1">
<li><strong>任务级并行</strong>：将搜索树的不同分支分配给不同线程/进程</li>
<li><strong>数据级并行</strong>：并行处理同一层的多个选择</li>
</ol>
<p>并行化的挑战：</p>
<ul>
<li>负载均衡：不同分支的搜索时间可能差异很大</li>
<li>共享状态：需要同步访问共享的结果集</li>
<li>开销：线程/进程创建和通信的开销可能抵消并行化的收益</li>
</ul>
<p>对于大规模问题，并行化可以显著提升性能，但需要仔细设计以避免竞争条件和性能瓶颈。</p>
<h2 id="总结">总结</h2>
<p>回溯算法是解决组合优化问题的强大工具。掌握回溯算法的关键在于：</p>
<ol type="1">
<li><strong>理解三要素</strong>：选择、约束、目标</li>
<li><strong>掌握模板</strong>：熟练运用回溯模板解决各类问题</li>
<li><strong>学会剪枝</strong>：通过合理的剪枝大幅提升效率</li>
<li><strong>注意细节</strong>：状态恢复、结果复制、去重处理等</li>
</ol>
<p>通过大量练习，回溯算法会成为你解决 LeetCode
问题的得力助手。记住：回溯算法的本质是"试错"，通过系统地探索所有可能性，最终找到所有解。</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>本文标题：LeetCode（七）—— 回溯算法</li>
        <li>本文作者：Chen Kai</li>
        <li>创建时间：2023-07-28 00:00:00</li>
        <li>
            本文链接：https://www.chenk.top/LeetCode%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/LeetCode%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E5%93%88%E5%B8%8C%E8%A1%A8/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode（一）—— 哈希表</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/LAMP-%E4%B8%8E%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LAMP 与阿里云服务器详解</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情赞美帅气伟大的ck吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- 由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">什么是回溯算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E4%B8%8E-dfs-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.</span> <span class="nav-text">回溯与 DFS 的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%AF%94"><span class="nav-number">2.1.</span> <span class="nav-text">实际应用场景对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">2.2.</span> <span class="nav-text">回溯算法的搜索树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">3.</span> <span class="nav-text">回溯算法的三要素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9choice"><span class="nav-number">3.1.</span> <span class="nav-text">选择（Choice）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9Fconstraint"><span class="nav-number">3.2.</span> <span class="nav-text">约束（Constraint）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87goal"><span class="nav-number">3.3.</span> <span class="nav-text">目标（Goal）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.</span> <span class="nav-text">回溯算法模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8F%98%E4%BD%93"><span class="nav-number">4.1.</span> <span class="nav-text">模板的变体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E4%B8%80%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">经典问题一：全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E7%9A%84%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">全排列问题的搜索过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97-ii%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">5.2.</span> <span class="nav-text">全排列 II（包含重复元素）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E4%BA%8C%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">6.</span> <span class="nav-text">经典问题二：组合总和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">6.1.</span> <span class="nav-text">组合总和问题的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-ii%E6%AF%8F%E4%B8%AA%E6%95%B0%E5%AD%97%E5%8F%AA%E8%83%BD%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AC%A1"><span class="nav-number">6.2.</span> <span class="nav-text">组合总和
II（每个数字只能使用一次）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E4%B8%89%E5%AD%90%E9%9B%86"><span class="nav-number">7.</span> <span class="nav-text">经典问题三：子集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%90%86%E8%A7%A3"><span class="nav-number">7.1.</span> <span class="nav-text">子集问题的另一种理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E9%9B%86-ii%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">7.2.</span> <span class="nav-text">子集 II（包含重复元素）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%9B%9Bn-%E7%9A%87%E5%90%8E"><span class="nav-number">8.</span> <span class="nav-text">经典问题四：N 皇后</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="nav-number">8.1.</span> <span class="nav-text">N 皇后问题的优化技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E4%BA%94%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-number">9.</span> <span class="nav-text">经典问题五：括号生成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B0%E5%AD%A6%E8%83%8C%E6%99%AF"><span class="nav-number">9.1.</span> <span class="nav-text">括号生成问题的数学背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B6%E4%BB%96%E8%A7%A3%E6%B3%95"><span class="nav-number">9.2.</span> <span class="nav-text">括号生成问题的其他解法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="nav-number">10.</span> <span class="nav-text">剪枝优化技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F%E5%89%AA%E6%9E%9D"><span class="nav-number">10.1.</span> <span class="nav-text">1. 约束剪枝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E5%89%AA%E6%9E%9D"><span class="nav-number">10.2.</span> <span class="nav-text">2. 重复剪枝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%89%AA%E6%9E%9D"><span class="nav-number">10.3.</span> <span class="nav-text">3. 可行性剪枝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E7%95%8C%E5%89%AA%E6%9E%9D"><span class="nav-number">10.4.</span> <span class="nav-text">4. 上下界剪枝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%89%AA%E6%9E%9D"><span class="nav-number">10.5.</span> <span class="nav-text">5. 对称性剪枝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">11.</span> <span class="nav-text">时间复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="nav-number">11.1.</span> <span class="nav-text">一般分析方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">11.2.</span> <span class="nav-text">常见复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">11.3.</span> <span class="nav-text">优化后的复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="nav-number">12.</span> <span class="nav-text">更多经典问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="nav-number">12.1.</span> <span class="nav-text">单词搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%8B%AC%E6%B1%82%E8%A7%A3"><span class="nav-number">12.2.</span> <span class="nav-text">数独求解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%8E%9F-ip-%E5%9C%B0%E5%9D%80"><span class="nav-number">12.3.</span> <span class="nav-text">复原 IP 地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">13.</span> <span class="nav-text">常见陷阱与注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98%E6%97%B6%E6%9C%AA%E5%A4%8D%E5%88%B6"><span class="nav-number">13.1.</span> <span class="nav-text">1. 结果保存时未复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E4%B8%8D%E5%AE%8C%E6%95%B4"><span class="nav-number">13.2.</span> <span class="nav-text">2. 状态恢复不完整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%AA%E6%9E%9D%E6%9D%A1%E4%BB%B6%E9%94%99%E8%AF%AF"><span class="nav-number">13.3.</span> <span class="nav-text">3. 剪枝条件错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%88%97%E8%A1%A8%E6%9B%B4%E6%96%B0%E9%94%99%E8%AF%AF"><span class="nav-number">13.4.</span> <span class="nav-text">4. 选择列表更新错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6%E9%81%97%E6%BC%8F"><span class="nav-number">13.5.</span> <span class="nav-text">5. 终止条件遗漏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.</span> <span class="nav-text">回溯算法的迭代实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.1.</span> <span class="nav-text">全排列的迭代实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E9%9B%86%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.2.</span> <span class="nav-text">子集的迭代实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">15.</span> <span class="nav-text">回溯算法与其他算法的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-vs-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">15.1.</span> <span class="nav-text">回溯 vs 动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-vs-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">15.2.</span> <span class="nav-text">回溯 vs 贪心算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-vs-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C"><span class="nav-number">15.3.</span> <span class="nav-text">回溯 vs 分支限界</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93"><span class="nav-number">16.</span> <span class="nav-text">实战技巧总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qa-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">17.</span> <span class="nav-text">❓ Q&amp;A: 回溯算法常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#q1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%92%8C-dfs-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">17.1.</span> <span class="nav-text">Q1: 回溯算法和 DFS
有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%AD%E8%A6%81%E7%94%A8-path-%E8%80%8C%E4%B8%8D%E6%98%AF-path"><span class="nav-number">17.2.</span> <span class="nav-text">Q2:
为什么回溯算法中要用 path[:] 而不是
path？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q3-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88%E7%94%A8%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">17.3.</span> <span class="nav-text">Q3:
如何判断一个问题是否适合用回溯算法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q4-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90"><span class="nav-number">17.4.</span> <span class="nav-text">Q4:
回溯算法的时间复杂度如何分析？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q5-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">17.5.</span> <span class="nav-text">Q5: 如何优化回溯算法的性能？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q6-%E5%8E%BB%E9%87%8D%E5%89%AA%E6%9E%9D%E4%B8%AD-usedi-1-%E7%9A%84%E5%88%A4%E6%96%AD%E9%80%BB%E8%BE%91%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">17.6.</span> <span class="nav-text">Q6: 去重剪枝中
used[i-1] 的判断逻辑是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q7-%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BB%8E-start-%E5%BC%80%E5%A7%8B%E9%80%89%E6%8B%A9"><span class="nav-number">17.7.</span> <span class="nav-text">Q7: 组合问题中为什么要从
start 开始选择？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q8-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%E5%90%97"><span class="nav-number">17.8.</span> <span class="nav-text">Q8: 回溯算法会栈溢出吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q9-%E5%A6%82%E4%BD%95%E5%B0%86%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%94%B9%E4%B8%BA%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="nav-number">17.9.</span> <span class="nav-text">Q9:
如何将回溯算法改为迭代实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q10-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%90%97"><span class="nav-number">17.10.</span> <span class="nav-text">Q10:
回溯算法可以解决动态规划问题吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q11-%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">17.11.</span> <span class="nav-text">Q11: 如何调试回溯算法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q12-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E6%98%AF%E6%8C%87%E6%95%B0%E7%BA%A7%E7%9A%84%E5%90%97"><span class="nav-number">17.12.</span> <span class="nav-text">Q12:
回溯算法的时间复杂度总是指数级的吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q13-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">17.13.</span> <span class="nav-text">Q13:
如何选择回溯算法的数据结构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q14-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%B9%B6%E8%A1%8C%E5%8C%96%E5%90%97"><span class="nav-number">17.14.</span> <span class="nav-text">Q14: 回溯算法可以并行化吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">18.</span> <span class="nav-text">总结</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
