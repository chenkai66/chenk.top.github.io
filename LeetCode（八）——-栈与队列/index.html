<!DOCTYPE html>



<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chen Kai">
    
    <title>
        
            LeetCode（八）—— 栈与队列 |
        
        Chen Kai Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"chenk.top","root":"/","language":"zh-CN","default_language":"zh-CN","languages":["zh-CN","en"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Chen Kai Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    
    
    
    
    

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Chen Kai Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            
                            
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    <li class="menu-item lang-switch lang-switch-trigger" title="Language">
                        <i class="fas fa-globe"></i>
                    </li>
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item lang-switch-trigger"><i class="fas fa-globe"></i></div>
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    
                    
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    
    
    
    

    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LeetCode（八）—— 栈与队列</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chen Kai</span>
                        
                            <span class="author-label">BOSS</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    
    
    
    
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2023-08-20 00:00:00</span>
        <span class="mobile">2023-08-20 00:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Algorithm/">Algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Leetcode/">Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>8.3k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>34 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>栈和队列是两种最基础的数据结构，也是算法面试中的常客。它们看似简单，但实际应用中却变化多端：从括号匹配到单调栈优化，从
BFS
遍历到优先队列，从滑动窗口到双端队列，几乎每个算法题都可能用到它们。掌握好栈和队列，不仅能解决大量
LeetCode 题目，更能深入理解递归、回溯、BFS 等算法的本质。</p>
<p>这篇文章将从基础概念出发，通过经典题目深入理解栈和队列的应用场景，然后逐步深入到单调栈、优先队列、双端队列等进阶技巧，最后通过
Q&amp;A
解答常见疑问。每个知识点都配有详细的代码实现和复杂度分析，确保你能真正掌握这些数据结构。</p>
<span id="more"></span>
<h2 id="栈与队列的基本概念">栈与队列的基本概念</h2>
<h3 id="栈stack">栈（Stack）</h3>
<p>栈是一种<strong>后进先出</strong>（LIFO, Last In First
Out）的线性数据结构。想象一下叠盘子：你只能从最上面取盘子，也只能把新盘子放在最上面。</p>
<p>栈有两个核心操作：</p>
<ul>
<li><strong>push</strong>：将元素压入栈顶</li>
<li><strong>pop</strong>：从栈顶弹出元素</li>
</ul>
<p>此外还有：</p>
<ul>
<li><strong>peek/top</strong>：查看栈顶元素（不删除）</li>
<li><strong>isEmpty</strong>：判断栈是否为空</li>
<li><strong>size</strong>：获取栈中元素个数</li>
</ul>
<p>在 Python 中，我们可以用列表模拟栈：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack = []</span><br><span class="line">stack.append(<span class="number">1</span>)  <span class="comment"># push</span></span><br><span class="line">stack.append(<span class="number">2</span>)</span><br><span class="line">top = stack[-<span class="number">1</span>]  <span class="comment"># peek</span></span><br><span class="line">val = stack.pop()  <span class="comment"># pop</span></span><br></pre></td></tr></table></figure>
<h3 id="队列queue">队列（Queue）</h3>
<p>队列是一种<strong>先进先出</strong>（FIFO, First In First
Out）的线性数据结构。就像排队买票：先来的人先买到票，后来的人排在队尾。</p>
<p>队列的核心操作：</p>
<ul>
<li><strong>enqueue/offer</strong>：将元素加入队尾</li>
<li><strong>dequeue/poll</strong>：从队首取出元素</li>
<li><strong>peek/front</strong>：查看队首元素（不删除）</li>
<li><strong>isEmpty</strong>：判断队列是否为空</li>
<li><strong>size</strong>：获取队列中元素个数</li>
</ul>
<p>在 Python 中，使用 <code>collections.deque</code>
实现队列效率更高：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">queue = deque()</span><br><span class="line">queue.append(<span class="number">1</span>)  <span class="comment"># enqueue</span></span><br><span class="line">queue.append(<span class="number">2</span>)</span><br><span class="line">front = queue[<span class="number">0</span>]  <span class="comment"># peek</span></span><br><span class="line">val = queue.popleft()  <span class="comment"># dequeue</span></span><br></pre></td></tr></table></figure>
<h3 id="为什么需要栈和队列">为什么需要栈和队列？</h3>
<p>栈和队列虽然简单，但它们能帮助我们：</p>
<ol type="1">
<li><strong>管理递归调用</strong>：函数调用栈本质上就是栈</li>
<li><strong>实现回溯算法</strong>：DFS 可以用栈模拟</li>
<li><strong>层次遍历</strong>：BFS 必须用队列</li>
<li><strong>处理匹配问题</strong>：括号、标签匹配等</li>
<li><strong>优化时间复杂度</strong>：单调栈可以 O(n) 解决某些问题</li>
</ol>
<h2 id="栈的经典应用">栈的经典应用</h2>
<h3 id="有效的括号leetcode-20">有效的括号（LeetCode 20）</h3>
<p><strong>题目</strong>：给定一个只包括
<code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code>
的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合</li>
<li>左括号必须以正确的顺序闭合</li>
<li>注意空字符串可被认为是有效字符串</li>
</ul>
<p><strong>思路</strong>：遇到左括号就入栈，遇到右括号就检查栈顶是否匹配。如果匹配就弹出，不匹配或栈为空则无效。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    stack = []</span><br><span class="line">    mapping = &#123;<span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> mapping:  <span class="comment"># 右括号</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack.pop() != mapping[char]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 左括号</span></span><br><span class="line">            stack.append(char)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span>，遍历字符串一次</li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span>，最坏情况下所有字符都是左括号</li>
</ul>
<p><strong>变式</strong>：如果括号可以嵌套多层，或者需要输出最长有效括号子串的长度（LeetCode
32），思路类似，但需要记录索引。</p>
<h3 id="最小栈leetcode-155">最小栈（LeetCode 155）</h3>
<p><strong>题目</strong>：设计一个支持 push，pop，top
操作，并能在常数时间内检索到最小元素的栈。</p>
<p><strong>思路</strong>：如果只用一个栈，获取最小值需要遍历所有元素，时间复杂度是
<span class="math inline">\(O(n)\)</span>。我们可以用两个栈：一个存储所有元素，另一个存储当前最小值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack.append(val)</span><br><span class="line">        <span class="comment"># 如果 min_stack 为空，或者新值更小，则入栈</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack <span class="keyword">or</span> val &lt;= self.min_stack[-<span class="number">1</span>]:</span><br><span class="line">            self.min_stack.append(val)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            val = self.stack.pop()</span><br><span class="line">            <span class="comment"># 如果弹出的是最小值，min_stack 也要弹出</span></span><br><span class="line">            <span class="keyword">if</span> self.min_stack <span class="keyword">and</span> val == self.min_stack[-<span class="number">1</span>]:</span><br><span class="line">                self.min_stack.pop()</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong>：如果允许存储冗余数据，可以简化代码。每次 push
时，如果新值大于当前最小值，仍然把当前最小值再 push 一次到
min_stack：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack.append(val)</span><br><span class="line">        <span class="comment"># 总是 push 当前最小值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack:</span><br><span class="line">            self.min_stack.append(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.min_stack.append(<span class="built_in">min</span>(val, self.min_stack[-<span class="number">1</span>]))</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>所有操作时间复杂度：<span class="math inline">\(O(1)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span>，需要额外的
min_stack</li>
</ul>
<h3 id="逆波兰表达式求值leetcode-150">逆波兰表达式求值（LeetCode
150）</h3>
<p><strong>题目</strong>：根据逆波兰表示法，求表达式的值。有效的算符包括
<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p><strong>逆波兰表达式</strong>（后缀表达式）的特点：</p>
<ul>
<li>操作符在操作数之后</li>
<li>不需要括号来指定运算顺序</li>
<li>适合用栈来计算</li>
</ul>
<p><strong>思路</strong>：遍历表达式，遇到数字就入栈，遇到运算符就弹出两个数字进行计算，结果再入栈。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    stack = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>]:</span><br><span class="line">            <span class="comment"># 注意顺序：先弹出的是右操作数，后弹出的是左操作数</span></span><br><span class="line">            right = stack.pop()</span><br><span class="line">            left = stack.pop()</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> token == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                result = left + right</span><br><span class="line">            <span class="keyword">elif</span> token == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                result = left - right</span><br><span class="line">            <span class="keyword">elif</span> token == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                result = left * right</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># &#x27;/&#x27;</span></span><br><span class="line">                <span class="comment"># 注意：题目要求向零截断，即 truncate toward zero</span></span><br><span class="line">                result = <span class="built_in">int</span>(left / right)</span><br><span class="line">          </span><br><span class="line">            stack.append(result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(<span class="built_in">int</span>(token))</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>：</p>
<ol type="1">
<li>除法运算：Python 的 <code>//</code>
是向下取整，但题目要求向零截断。例如
<code>-7 // 3 = -3</code>，但应该返回 <code>-2</code>。使用
<code>int(left / right)</code> 可以正确处理。</li>
<li>操作数顺序：减法、除法不满足交换律，要注意左右操作数的顺序。</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span>，遍历一次表达式</li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span>，栈的空间</li>
</ul>
<h3 id="每日温度leetcode-739">每日温度（LeetCode 739）</h3>
<p><strong>题目</strong>：给定一个整数数组
<code>temperatures</code>，表示每天的温度，返回一个数组
<code>answer</code>，其中 <code>answer[i]</code> 是指对于第
<code>i</code>
天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用
<code>0</code> 来代替。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>思路一：暴力法</strong>
对于每个位置，向后查找第一个大于它的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">    answer = [<span class="number">0</span>] * n</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> temperatures[j] &gt; temperatures[i]:</span><br><span class="line">                answer[i] = j - i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O(n^2)\)</span>，空间复杂度：<span class="math inline">\(O(1)\)</span>。</p>
<p><strong>思路二：单调栈</strong>
维护一个单调递减栈（从栈底到栈顶递减），栈中存储索引。遍历数组：</p>
<ul>
<li>如果当前温度大于栈顶温度，说明找到了栈顶元素的下一个更高温度，弹出并计算差值</li>
<li>否则将当前索引入栈</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">    answer = [<span class="number">0</span>] * n</span><br><span class="line">    stack = []  <span class="comment"># 存储索引</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 当前温度大于栈顶温度</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[i] &gt; temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">            idx = stack.pop()</span><br><span class="line">            answer[idx] = i - idx</span><br><span class="line">        stack.append(i)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span>，每个元素最多入栈和出栈一次</li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span>，栈的空间</li>
</ul>
<p><strong>为什么单调栈能优化？</strong>
暴力法对每个位置都要向后查找，而单调栈利用了"如果当前元素比栈顶大，那么它可能比栈中其他元素也大"这一性质，避免了重复比较。</p>
<h2 id="单调栈详解">单调栈详解</h2>
<p>单调栈是栈的一种特殊应用，栈中的元素保持单调性（递增或递减）。它常用于解决"下一个更大/更小元素"、"左边第一个更大/更小元素"等问题。</p>
<h3 id="下一个更大元素-ileetcode-496">下一个更大元素 I（LeetCode
496）</h3>
<p><strong>题目</strong>：<code>nums1</code> 中数字 <code>x</code>
的下一个更大元素是指 <code>x</code> 在 <code>nums2</code>
中对应位置右侧的第一个比 <code>x</code>
大的元素。如果不存在，对应位置输出 <code>-1</code>。</p>
<p><strong>思路</strong>：先用单调栈找出 <code>nums2</code>
中每个元素的下一个更大元素，存储在哈希表中，然后遍历 <code>nums1</code>
查询。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># 用单调栈找出 nums2 中每个元素的下一个更大元素</span></span><br><span class="line">    stack = []</span><br><span class="line">    next_greater = &#123;&#125;  <span class="comment"># 元素 -&gt; 下一个更大元素</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums2:</span><br><span class="line">        <span class="comment"># 当前元素大于栈顶元素</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> num &gt; stack[-<span class="number">1</span>]:</span><br><span class="line">            next_greater[stack.pop()] = num</span><br><span class="line">        stack.append(num)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 对于栈中剩余元素，它们没有下一个更大元素</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        next_greater[stack.pop()] = -<span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 查询 nums1</span></span><br><span class="line">    <span class="keyword">return</span> [next_greater.get(num, -<span class="number">1</span>) <span class="keyword">for</span> num <span class="keyword">in</span> nums1]</span><br></pre></td></tr></table></figure>
<h3 id="下一个更大元素-iileetcode-503">下一个更大元素 II（LeetCode
503）</h3>
<p><strong>题目</strong>：给定一个循环数组，输出每个元素的下一个更大元素。如果不存在，则输出
<code>-1</code>。</p>
<p><strong>思路</strong>：循环数组可以展开成两倍长度的数组，或者用取模运算模拟循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    answer = [-<span class="number">1</span>] * n</span><br><span class="line">    stack = []  <span class="comment"># 存储索引</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 遍历两倍长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * n):</span><br><span class="line">        idx = i % n</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> nums[idx] &gt; nums[stack[-<span class="number">1</span>]]:</span><br><span class="line">            answer[stack.pop()] = nums[idx]</span><br><span class="line">        <span class="comment"># 只在第一轮遍历时入栈</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; n:</span><br><span class="line">            stack.append(idx)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<h3 id="柱状图中最大的矩形leetcode-84">柱状图中最大的矩形（LeetCode
84）</h3>
<p><strong>题目</strong>：给定 <code>n</code>
个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为
1。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>思路</strong>：对于每个柱子，以它的高度为矩形高度，向左右扩展，找到左右第一个比它矮的柱子，这就是矩形的边界。</p>
<p>使用单调递增栈（从栈底到栈顶递增）：</p>
<ul>
<li>当当前高度小于栈顶高度时，说明找到了栈顶柱子的右边界</li>
<li>栈中前一个元素就是左边界</li>
<li>计算以栈顶柱子高度为矩形高度的最大面积</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    stack = []</span><br><span class="line">    max_area = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i, h <span class="keyword">in</span> <span class="built_in">enumerate</span>(heights):</span><br><span class="line">        <span class="comment"># 当前高度小于栈顶高度，找到了右边界</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> h &lt; heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">            height = heights[stack.pop()]</span><br><span class="line">            <span class="comment"># 左边界：如果栈为空，说明左边没有更矮的，左边界是 -1</span></span><br><span class="line">            width = i - stack[-<span class="number">1</span>] - <span class="number">1</span> <span class="keyword">if</span> stack <span class="keyword">else</span> i</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, height * width)</span><br><span class="line">        stack.append(i)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 处理栈中剩余元素（它们的右边界是数组末尾）</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        height = heights[stack.pop()]</span><br><span class="line">        width = <span class="built_in">len</span>(heights) - stack[-<span class="number">1</span>] - <span class="number">1</span> <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="built_in">len</span>(heights)</span><br><span class="line">        max_area = <span class="built_in">max</span>(max_area, height * width)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong>：在数组两端添加高度为 0
的哨兵，简化边界处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 添加哨兵</span></span><br><span class="line">    heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]</span><br><span class="line">    stack = [<span class="number">0</span>]  <span class="comment"># 先放入左哨兵的索引</span></span><br><span class="line">    max_area = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(heights)):</span><br><span class="line">        <span class="keyword">while</span> heights[i] &lt; heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">            height = heights[stack.pop()]</span><br><span class="line">            width = i - stack[-<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, height * width)</span><br><span class="line">        stack.append(i)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span>，每个元素最多入栈和出栈一次</li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span>，栈的空间</li>
</ul>
<h3 id="接雨水leetcode-42">接雨水（LeetCode 42）</h3>
<p><strong>题目</strong>：给定 <code>n</code> 个非负整数表示每个宽度为 1
的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>思路</strong>：使用单调递减栈。当遇到比栈顶高的柱子时，说明形成了一个凹槽，可以接雨水。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    stack = []</span><br><span class="line">    water = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i, h <span class="keyword">in</span> <span class="built_in">enumerate</span>(height):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> h &gt; height[stack[-<span class="number">1</span>]]:</span><br><span class="line">            bottom = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 左边界、右边界、底边</span></span><br><span class="line">            left = stack[-<span class="number">1</span>]</span><br><span class="line">            right = i</span><br><span class="line">            <span class="comment"># 雨水高度 = min(左边界高度, 右边界高度) - 底边高度</span></span><br><span class="line">            water_height = <span class="built_in">min</span>(height[left], height[right]) - height[bottom]</span><br><span class="line">            water_width = right - left - <span class="number">1</span></span><br><span class="line">            water += water_height * water_width</span><br><span class="line">        stack.append(i)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> water</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ul>
<h2 id="队列与-bfs">队列与 BFS</h2>
<h3 id="bfs-的基本思想">BFS 的基本思想</h3>
<p>广度优先搜索（BFS）使用队列来实现层次遍历。它的核心思想是：</p>
<ol type="1">
<li><p>将起始节点入队</p></li>
<li><p>当队列不为空时：</p>
<ul>
<li>取出队首节点</li>
<li>访问该节点</li>
<li>将该节点的所有未访问邻居入队</li>
</ul></li>
<li><p>重复步骤 2</p></li>
</ol>
<h3 id="二叉树的层次遍历leetcode-102">二叉树的层次遍历（LeetCode
102）</h3>
<p><strong>题目</strong>：给你二叉树的根节点
<code>root</code>，返回其节点值的层序遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">  </span><br><span class="line">    result = []</span><br><span class="line">    queue = deque([root])</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">        level = []</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            level.append(node.val)</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">      </span><br><span class="line">        result.append(level)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>关键点</strong>：</p>
<ul>
<li>使用 <code>level_size</code>
记录当前层的节点数，确保每次处理完一层</li>
<li>在遍历当前层时，下一层的节点已经入队</li>
</ul>
<h3 id="岛屿数量leetcode-200">岛屿数量（LeetCode 200）</h3>
<p><strong>题目</strong>：给你一个由 <code>'1'</code>（陆地）和
<code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p><strong>思路</strong>：遍历网格，遇到 <code>'1'</code> 就用 BFS
标记整个岛屿。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">i, j</span>):</span><br><span class="line">        queue = deque([(i, j)])</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>  <span class="comment"># 标记为已访问</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x, y = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> directions:</span><br><span class="line">                nx, ny = x + dx, y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; n <span class="keyword">and</span> grid[nx][ny] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    grid[nx][ny] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    queue.append((nx, ny))</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                bfs(i, j)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(m \times
n)\)</span>，每个格子最多访问一次</li>
<li>空间复杂度：<span class="math inline">\(O(m \times
n)\)</span>，队列的空间，最坏情况下整个网格都是陆地</li>
</ul>
<h3 id="打开转盘锁leetcode-752">打开转盘锁（LeetCode 752）</h3>
<p><strong>题目</strong>：你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有
10 个数字：<code>'0'</code> 到
<code>'9'</code>。每个拨轮可以自由旋转：例如把 <code>'9'</code> 变为
<code>'0'</code>，<code>'0'</code> 变为
<code>'9'</code>。每次旋转都只能旋转一个拨轮的一个数字。</p>
<p>锁的初始数字为
<code>'0000'</code>，一个代表四个拨轮的数字的字符串。列表
<code>deadends</code>
包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，锁将会被永久锁定，无法再被旋转。</p>
<p>给你一个目标数字
<code>target</code>，返回需要的最少旋转次数，如果无论如何不能解锁，返回
<code>-1</code>。</p>
<p><strong>思路</strong>：BFS 求最短路径。每个状态有 8 个邻居（4
个拨轮，每个可以向上或向下转）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">openLock</span>(<span class="params">deadends: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    deadends_set = <span class="built_in">set</span>(deadends)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;0000&#x27;</span> <span class="keyword">in</span> deadends_set:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    queue = deque([(<span class="string">&#x27;0000&#x27;</span>, <span class="number">0</span>)])</span><br><span class="line">    visited = &#123;<span class="string">&#x27;0000&#x27;</span>&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_neighbors</span>(<span class="params">state</span>):</span><br><span class="line">        neighbors = []</span><br><span class="line">        state_list = <span class="built_in">list</span>(state)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="comment"># 向上转</span></span><br><span class="line">            temp = state_list[:]</span><br><span class="line">            temp[i] = <span class="built_in">str</span>((<span class="built_in">int</span>(temp[i]) + <span class="number">1</span>) % <span class="number">10</span>)</span><br><span class="line">            neighbors.append(<span class="string">&#x27;&#x27;</span>.join(temp))</span><br><span class="line">          </span><br><span class="line">            <span class="comment"># 向下转</span></span><br><span class="line">            temp = state_list[:]</span><br><span class="line">            temp[i] = <span class="built_in">str</span>((<span class="built_in">int</span>(temp[i]) - <span class="number">1</span>) % <span class="number">10</span>)</span><br><span class="line">            neighbors.append(<span class="string">&#x27;&#x27;</span>.join(temp))</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> neighbors</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        state, moves = queue.popleft()</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> state == target:</span><br><span class="line">            <span class="keyword">return</span> moves</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> get_neighbors(state):</span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> deadends_set:</span><br><span class="line">                visited.add(neighbor)</span><br><span class="line">                queue.append((neighbor, moves + <span class="number">1</span>))</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(10^4 \times 8) =
O(80000)\)</span>，最多有 10000 个状态，每个状态有 8 个邻居</li>
<li>空间复杂度：<span class="math inline">\(O(10^4)\)</span>，visited
集合和队列的空间</li>
</ul>
<h2 id="优先队列堆应用">优先队列（堆）应用</h2>
<p>优先队列（Priority
Queue）是一种特殊的队列，每次出队的是优先级最高的元素。在 Python
中，可以使用 <code>heapq</code> 模块实现最小堆。</p>
<h3 id="前-k-个高频元素leetcode-347">前 K 个高频元素（LeetCode
347）</h3>
<p><strong>题目</strong>：给你一个整数数组 <code>nums</code> 和一个整数
<code>k</code>，请你返回其中出现频率前 <code>k</code>
高的元素。你可以按任意顺序返回答案。</p>
<p><strong>思路一：排序</strong> 统计频率后排序，时间复杂度 <span class="math inline">\(O(n \log n)\)</span>。</p>
<p><strong>思路二：最小堆</strong> 维护一个大小为 <code>k</code>
的最小堆，堆顶是频率最小的元素。遍历频率字典，如果堆大小小于
<code>k</code> 或当前频率大于堆顶，则入堆。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># 统计频率</span></span><br><span class="line">    counter = Counter(nums)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 最小堆</span></span><br><span class="line">    heap = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> num, freq <span class="keyword">in</span> counter.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) &lt; k:</span><br><span class="line">            heapq.heappush(heap, (freq, num))</span><br><span class="line">        <span class="keyword">elif</span> freq &gt; heap[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">            heapq.heapreplace(heap, (freq, num))</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> [num <span class="keyword">for</span> freq, num <span class="keyword">in</span> heap]</span><br></pre></td></tr></table></figure>
<p><strong>思路三：桶排序</strong>
如果频率范围已知，可以用桶排序，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    counter = Counter(nums)</span><br><span class="line">    <span class="comment"># 桶：索引是频率，值是数字列表</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) + <span class="number">1</span>)]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> num, freq <span class="keyword">in</span> counter.items():</span><br><span class="line">        buckets[freq].append(num)</span><br><span class="line">  </span><br><span class="line">    result = []</span><br><span class="line">    <span class="comment"># 从高频到低频遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums), <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        result.extend(buckets[i])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(result) &gt;= k:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result[:k]</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>堆方法：时间复杂度 <span class="math inline">\(O(n \log
k)\)</span>，空间复杂度 <span class="math inline">\(O(n)\)</span></li>
<li>桶排序：时间复杂度 <span class="math inline">\(O(n)\)</span>，空间复杂度 <span class="math inline">\(O(n)\)</span></li>
</ul>
<h3 id="合并-k-个升序链表leetcode-23">合并 K 个升序链表（LeetCode
23）</h3>
<p><strong>题目</strong>：给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>思路</strong>：使用最小堆，每次取出最小的节点，然后将其下一个节点入堆。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">lists: <span class="type">List</span>[ListNode]</span>) -&gt; ListNode:</span><br><span class="line">    <span class="comment"># 最小堆：存储 (值, 节点索引, 节点)</span></span><br><span class="line">    heap = []</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 初始化：每个链表的头节点入堆</span></span><br><span class="line">    <span class="keyword">for</span> i, node <span class="keyword">in</span> <span class="built_in">enumerate</span>(lists):</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            heapq.heappush(heap, (node.val, i, node))</span><br><span class="line">  </span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">    current = dummy</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> heap:</span><br><span class="line">        val, idx, node = heapq.heappop(heap)</span><br><span class="line">        current.<span class="built_in">next</span> = node</span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 如果该链表还有下一个节点，入堆</span></span><br><span class="line">        <span class="keyword">if</span> node.<span class="built_in">next</span>:</span><br><span class="line">            heapq.heappush(heap, (node.<span class="built_in">next</span>.val, idx, node.<span class="built_in">next</span>))</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(n \log k)\)</span>，其中
<span class="math inline">\(n\)</span> 是所有节点数，<span class="math inline">\(k\)</span> 是链表数</li>
<li>空间复杂度：<span class="math inline">\(O(k)\)</span>，堆的大小</li>
</ul>
<h3 id="数据流的中位数leetcode-295">数据流的中位数（LeetCode 295）</h3>
<p><strong>题目</strong>：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li><code>void addNum(int num)</code>：从数据流中添加一个整数到数据结构中</li>
<li><code>double findMedian()</code>：返回目前所有元素的中位数</li>
</ul>
<p><strong>思路</strong>：使用两个堆：一个大顶堆存储较小的一半，一个小顶堆存储较大的一半。保持两个堆的大小差不超过
1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 大顶堆：存储较小的一半（Python 的 heapq 是最小堆，所以用负数）</span></span><br><span class="line">        self.max_heap = []</span><br><span class="line">        <span class="comment"># 小顶堆：存储较大的一半</span></span><br><span class="line">        self.min_heap = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 先加入大顶堆</span></span><br><span class="line">        heapq.heappush(self.max_heap, -num)</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 保证大顶堆的最大值 &lt;= 小顶堆的最小值</span></span><br><span class="line">        <span class="keyword">if</span> self.max_heap <span class="keyword">and</span> self.min_heap <span class="keyword">and</span> -self.max_heap[<span class="number">0</span>] &gt; self.min_heap[<span class="number">0</span>]:</span><br><span class="line">            val = -heapq.heappop(self.max_heap)</span><br><span class="line">            heapq.heappush(self.min_heap, val)</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 平衡两个堆的大小</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.max_heap) &gt; <span class="built_in">len</span>(self.min_heap) + <span class="number">1</span>:</span><br><span class="line">            val = -heapq.heappop(self.max_heap)</span><br><span class="line">            heapq.heappush(self.min_heap, val)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(self.min_heap) &gt; <span class="built_in">len</span>(self.max_heap) + <span class="number">1</span>:</span><br><span class="line">            val = heapq.heappop(self.min_heap)</span><br><span class="line">            heapq.heappush(self.max_heap, -val)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedian</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.max_heap) &gt; <span class="built_in">len</span>(self.min_heap):</span><br><span class="line">            <span class="keyword">return</span> -self.max_heap[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(self.min_heap) &gt; <span class="built_in">len</span>(self.max_heap):</span><br><span class="line">            <span class="keyword">return</span> self.min_heap[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (-self.max_heap[<span class="number">0</span>] + self.min_heap[<span class="number">0</span>]) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li><code>addNum</code>：<span class="math inline">\(O(\log
n)\)</span></li>
<li><code>findMedian</code>：<span class="math inline">\(O(1)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ul>
<h2 id="双端队列滑动窗口最大值">双端队列（滑动窗口最大值）</h2>
<p>双端队列（Deque）允许在两端进行插入和删除操作。在 Python
中，<code>collections.deque</code> 提供了高效的双端队列实现。</p>
<h3 id="滑动窗口最大值leetcode-239">滑动窗口最大值（LeetCode 239）</h3>
<p><strong>题目</strong>：给你一个整数数组
<code>nums</code>，有一个大小为 <code>k</code>
的滑动窗口从数组的最左侧移动到最右侧。你只可以看到在滑动窗口内的
<code>k</code>
个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。</p>
<p><strong>思路一：暴力法</strong>
对每个窗口，遍历找到最大值。时间复杂度 <span class="math inline">\(O(nk)\)</span>。</p>
<p><strong>思路二：单调队列</strong>
维护一个单调递减的双端队列，队首是当前窗口的最大值。队列中存储索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    dq = deque()  <span class="comment"># 存储索引</span></span><br><span class="line">    result = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># 移除窗口外的元素</span></span><br><span class="line">        <span class="keyword">while</span> dq <span class="keyword">and</span> dq[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">            dq.popleft()</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 移除小于当前元素的元素（它们不可能成为最大值）</span></span><br><span class="line">        <span class="keyword">while</span> dq <span class="keyword">and</span> nums[dq[-<span class="number">1</span>]] &lt; nums[i]:</span><br><span class="line">            dq.pop()</span><br><span class="line">      </span><br><span class="line">        dq.append(i)</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 窗口大小达到 k 时，开始记录结果</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            result.append(nums[dq[<span class="number">0</span>]])</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><strong>为什么单调队列有效？</strong></p>
<ul>
<li>如果新元素大于队列中的某些元素，那么这些元素在后续窗口中也不可能成为最大值（因为新元素更大且更靠后）</li>
<li>因此可以安全地移除它们，保持队列单调递减</li>
</ul>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(n)\)</span>，每个元素最多入队和出队一次</li>
<li>空间复杂度：<span class="math inline">\(O(k)\)</span>，队列的大小</li>
</ul>
<h3 id="滑动窗口最小值">滑动窗口最小值</h3>
<p>类似地，可以求滑动窗口的最小值，只需维护一个单调递增队列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minSlidingWindow</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    dq = deque()</span><br><span class="line">    result = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">while</span> dq <span class="keyword">and</span> dq[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">            dq.popleft()</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 移除大于当前元素的元素</span></span><br><span class="line">        <span class="keyword">while</span> dq <span class="keyword">and</span> nums[dq[-<span class="number">1</span>]] &gt; nums[i]:</span><br><span class="line">            dq.pop()</span><br><span class="line">      </span><br><span class="line">        dq.append(i)</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            result.append(nums[dq[<span class="number">0</span>]])</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="栈实现队列-队列实现栈">栈实现队列 / 队列实现栈</h2>
<h3 id="用栈实现队列leetcode-232">用栈实现队列（LeetCode 232）</h3>
<p><strong>题目</strong>：请你仅使用两个栈实现先入先出队列。</p>
<p><strong>思路</strong>：使用两个栈 <code>stack_in</code> 和
<code>stack_out</code>：</p>
<ul>
<li><code>push</code>：直接压入 <code>stack_in</code></li>
<li><code>pop</code>：如果 <code>stack_out</code> 为空，将
<code>stack_in</code> 的所有元素弹出并压入
<code>stack_out</code>，然后从 <code>stack_out</code> 弹出</li>
<li><code>peek</code>：同 <code>pop</code>，但不删除元素</li>
<li><code>empty</code>：两个栈都为空</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack_in = []</span><br><span class="line">        self.stack_out = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack_in.append(x)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.move()</span><br><span class="line">        <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.move()</span><br><span class="line">        <span class="keyword">return</span> self.stack_out[-<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stack_in) == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(self.stack_out) == <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 如果 stack_out 为空，将 stack_in 的元素全部移到 stack_out</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack_out:</span><br><span class="line">            <span class="keyword">while</span> self.stack_in:</span><br><span class="line">                self.stack_out.append(self.stack_in.pop())</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li><code>push</code>：<span class="math inline">\(O(1)\)</span></li>
<li><code>pop</code>：均摊 <span class="math inline">\(O(1)\)</span>（每个元素最多移动一次）</li>
<li><code>peek</code>：均摊 <span class="math inline">\(O(1)\)</span></li>
<li><code>empty</code>：<span class="math inline">\(O(1)\)</span></li>
</ul>
<h3 id="用队列实现栈leetcode-225">用队列实现栈（LeetCode 225）</h3>
<p><strong>题目</strong>：请你仅使用两个队列实现一个后入先出（LIFO）的栈。</p>
<p><strong>思路一：两个队列</strong> 使用两个队列 <code>queue1</code> 和
<code>queue2</code>：</p>
<ul>
<li><code>push</code>：直接加入 <code>queue1</code></li>
<li><code>pop</code>：将 <code>queue1</code> 的前 <code>n-1</code>
个元素移到 <code>queue2</code>，弹出最后一个元素，然后交换
<code>queue1</code> 和 <code>queue2</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue1 = deque()</span><br><span class="line">        self.queue2 = deque()</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.queue1.append(x)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.queue1) &gt; <span class="number">1</span>:</span><br><span class="line">            self.queue2.append(self.queue1.popleft())</span><br><span class="line">        result = self.queue1.popleft()</span><br><span class="line">        self.queue1, self.queue2 = self.queue2, self.queue1</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.queue1[-<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue1) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>思路二：一个队列</strong> 只用一个队列，<code>push</code>
时先加入新元素，然后将前面的元素依次出队再入队：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue = deque()</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.queue.append(x)</span><br><span class="line">        <span class="comment"># 将前面的元素移到后面</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.queue) - <span class="number">1</span>):</span><br><span class="line">            self.queue.append(self.queue.popleft())</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.queue.popleft()</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li><code>push</code>：<span class="math inline">\(O(n)\)</span>（需要移动 <span class="math inline">\(n-1\)</span> 个元素）</li>
<li><code>pop</code>：<span class="math inline">\(O(1)\)</span></li>
<li><code>top</code>：<span class="math inline">\(O(1)\)</span></li>
<li><code>empty</code>：<span class="math inline">\(O(1)\)</span></li>
</ul>
<h2 id="时间空间复杂度分析">时间空间复杂度分析</h2>
<h3 id="栈操作复杂度">栈操作复杂度</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>push</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr>
<td>pop</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr>
<td>peek</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr>
<td>查找</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<h3 id="队列操作复杂度">队列操作复杂度</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>enqueue</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr>
<td>dequeue</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr>
<td>peek</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr>
<td>查找</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<h3 id="优先队列堆操作复杂度">优先队列（堆）操作复杂度</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr>
<td>删除最小/最大</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr>
<td>查找最小/最大</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr>
<td>建堆</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<h3 id="双端队列操作复杂度">双端队列操作复杂度</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>两端插入</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr>
<td>两端删除</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr>
<td>随机访问</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<h3 id="常见算法复杂度总结">常见算法复杂度总结</h3>
<ol type="1">
<li><strong>括号匹配</strong>：<span class="math inline">\(O(n)\)</span>
时间，<span class="math inline">\(O(n)\)</span> 空间</li>
<li><strong>单调栈找下一个更大元素</strong>：<span class="math inline">\(O(n)\)</span> 时间，<span class="math inline">\(O(n)\)</span> 空间</li>
<li><strong>BFS 层次遍历</strong>：<span class="math inline">\(O(V +
E)\)</span> 时间（<span class="math inline">\(V\)</span> 是节点数，<span class="math inline">\(E\)</span> 是边数），<span class="math inline">\(O(V)\)</span> 空间</li>
<li><strong>滑动窗口最大值（单调队列）</strong>：<span class="math inline">\(O(n)\)</span> 时间，<span class="math inline">\(O(k)\)</span> 空间</li>
<li><strong>前 K 个高频元素（堆）</strong>：<span class="math inline">\(O(n \log k)\)</span> 时间，<span class="math inline">\(O(n)\)</span> 空间</li>
</ol>
<h2 id="qa-栈与队列常见问题">❓ Q&amp;A: 栈与队列常见问题</h2>
<h3 id="q1-什么时候用栈什么时候用队列">Q1:
什么时候用栈，什么时候用队列？</h3>
<p><strong>A</strong>:</p>
<ul>
<li><p><strong>用栈</strong>：需要后进先出（LIFO）的场景</p>
<ul>
<li>括号匹配、表达式求值</li>
<li>函数调用、递归转迭代</li>
<li>回溯算法（DFS）</li>
<li>单调栈优化</li>
</ul></li>
<li><p><strong>用队列</strong>：需要先进先出（FIFO）的场景</p>
<ul>
<li>层次遍历（BFS）</li>
<li>任务调度</li>
<li>消息队列</li>
</ul></li>
</ul>
<h3 id="q2-单调栈为什么能优化时间复杂度">Q2:
单调栈为什么能优化时间复杂度？</h3>
<p><strong>A</strong>:
单调栈利用了"如果当前元素满足某个条件（比如更大），那么它可能对之前未处理的元素也满足这个条件"的性质。通过维护单调性，避免了重复比较，将时间复杂度从
<span class="math inline">\(O(n^2)\)</span> 优化到 <span class="math inline">\(O(n)\)</span>。</p>
<p>例如，在"下一个更大元素"问题中，如果当前元素比栈顶大，那么它一定比栈中所有比栈顶小的元素都大，因此可以一次性处理多个元素。</p>
<h3 id="q3-python-中如何选择-list-和-deque">Q3: Python 中如何选择 list
和 deque？</h3>
<p><strong>A</strong>:</p>
<ul>
<li><strong>list</strong>：适合栈操作（<code>append</code> 和
<code>pop</code> 都是 <span class="math inline">\(O(1)\)</span>），但不适合队列（<code>pop(0)</code>
是 <span class="math inline">\(O(n)\)</span>）</li>
<li><strong>deque</strong>：两端操作都是 <span class="math inline">\(O(1)\)</span>，适合队列和双端队列</li>
</ul>
<p>对于队列，优先使用 <code>deque</code>；对于栈，<code>list</code> 和
<code>deque</code> 都可以，但 <code>list</code> 更常用。</p>
<h3 id="q4-如何判断一个题目是否可以用单调栈">Q4:
如何判断一个题目是否可以用单调栈？</h3>
<p><strong>A</strong>: 如果题目涉及：</p>
<ul>
<li>"下一个更大/更小元素"</li>
<li>"左边第一个更大/更小元素"</li>
<li>"区间最值"</li>
<li>"满足某种单调性的子数组"</li>
</ul>
<p>并且暴力解法是 <span class="math inline">\(O(n^2)\)</span>，可以考虑单调栈优化。</p>
<h3 id="q5-bfs-和-dfs-的区别是什么">Q5: BFS 和 DFS 的区别是什么？</h3>
<p><strong>A</strong>:</p>
<ul>
<li><strong>BFS（广度优先搜索）</strong>：用队列实现，按层次遍历，适合找最短路径</li>
<li><strong>DFS（深度优先搜索）</strong>：用栈（递归）实现，一条路走到底再回溯，适合找所有路径</li>
</ul>
<p>BFS 的空间复杂度通常是 <span class="math inline">\(O(宽度)\)</span>，DFS 的空间复杂度是 <span class="math inline">\(O(深度)\)</span>。</p>
<h3 id="q6-优先队列和普通队列的区别">Q6: 优先队列和普通队列的区别？</h3>
<p><strong>A</strong>:</p>
<ul>
<li><strong>普通队列</strong>：先进先出，按插入顺序出队</li>
<li><strong>优先队列</strong>：按优先级出队，优先级高的先出（可以用最小堆或最大堆实现）</li>
</ul>
<p>优先队列常用于：</p>
<ul>
<li>Top K 问题</li>
<li>合并多个有序序列</li>
<li>任务调度（按优先级）</li>
</ul>
<h3 id="q7-为什么滑动窗口最大值用单调队列而不是优先队列">Q7:
为什么滑动窗口最大值用单调队列而不是优先队列？</h3>
<p><strong>A</strong>:</p>
<ul>
<li><strong>优先队列</strong>：需要 <span class="math inline">\(O(\log
k)\)</span> 时间删除窗口外的元素（需要查找），总时间复杂度 <span class="math inline">\(O(n \log k)\)</span></li>
<li><strong>单调队列</strong>：可以在 <span class="math inline">\(O(1)\)</span>
时间删除窗口外的元素（队首），总时间复杂度 <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>单调队列通过维护单调性，避免了堆的额外开销。</p>
<h3 id="q8-如何用栈实现递归">Q8: 如何用栈实现递归？</h3>
<p><strong>A</strong>: 递归的本质就是函数调用栈。可以用显式栈模拟：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归版本</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    process(node)</span><br><span class="line">    dfs(node.left)</span><br><span class="line">    dfs(node.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代版本（用栈）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs_iterative</span>(<span class="params">root</span>):</span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        process(node)</span><br><span class="line">        stack.append(node.right)  <span class="comment"># 注意顺序</span></span><br><span class="line">        stack.append(node.left)</span><br></pre></td></tr></table></figure>
<h3 id="q9-什么时候需要两个栈队列">Q9: 什么时候需要两个栈/队列？</h3>
<p><strong>A</strong>:</p>
<ul>
<li><strong>两个栈实现队列</strong>：需要将后进先出转换为先进先出</li>
<li><strong>两个队列实现栈</strong>：需要将先进先出转换为后进先出</li>
<li><strong>辅助栈</strong>：如最小栈问题，需要一个辅助栈记录额外信息</li>
</ul>
<h3 id="q10-如何优化栈队列的空间复杂度">Q10:
如何优化栈/队列的空间复杂度？</h3>
<p><strong>A</strong>:</p>
<ol type="1">
<li><strong>及时清理</strong>：处理完的元素及时出栈/出队</li>
<li><strong>复用空间</strong>：如用两个栈实现队列时，可以复用
<code>stack_out</code> 的空间</li>
<li><strong>延迟计算</strong>：如"下一个更大元素"，可以延迟到需要时才计算</li>
<li><strong>使用索引</strong>：如果只需要索引信息，栈/队列中存储索引而不是完整对象</li>
</ol>
<h2 id="变体与扩展问题">变体与扩展问题</h2>
<h3 id="变体一多栈多队列问题">变体一：多栈/多队列问题</h3>
<p>有些问题需要同时维护多个栈或队列，或者在不同条件下使用不同的数据结构。</p>
<p><strong>例题：用栈实现队列（LeetCode 232）</strong></p>
<p>需要两个栈：一个用于入队，一个用于出队。当出队栈为空时，将入队栈的所有元素转移到出队栈。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>move()</code> 操作是均摊 <span class="math inline">\(O(1)\)</span> 的，因为每个元素最多移动一次</li>
<li>只有在 <code>stack_out</code> 为空时才需要移动</li>
</ul>
<h3 id="变体二单调栈的变种">变体二：单调栈的变种</h3>
<p>单调栈不仅可以找"下一个更大元素"，还可以解决其他相关问题。</p>
<p><strong>例题：去除重复字母（LeetCode 316）</strong></p>
<p>使用单调栈的思想，维护一个字典序最小的子序列。当遇到更小的字符且后面还有当前字符时，可以移除当前字符。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>需要记录每个字符的剩余次数</li>
<li>需要记录字符是否已经在栈中</li>
</ul>
<h3 id="变体三优先队列的变种">变体三：优先队列的变种</h3>
<p>优先队列不仅可以找 Top K，还可以解决其他优化问题。</p>
<p><strong>例题：合并 K 个升序链表（LeetCode 23）</strong></p>
<p>使用最小堆，每次取出最小的节点，然后将其下一个节点入堆。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>堆中需要存储 <code>(值, 索引, 节点)</code>
元组，避免节点无法比较的问题</li>
<li>当某个链表遍历完时，不再将其节点入堆</li>
</ul>
<h2 id="常见错误与调试技巧">常见错误与调试技巧</h2>
<h3 id="错误一栈队列为空时访问">错误一：栈/队列为空时访问</h3>
<p><strong>问题</strong>：在栈/队列为空时调用 <code>pop()</code> 或
<code>peek()</code>，导致错误。</p>
<p><strong>解决方法</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误</span></span><br><span class="line">val = stack.pop()  <span class="comment"># 如果栈为空会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确</span></span><br><span class="line"><span class="keyword">if</span> stack:</span><br><span class="line">    val = stack.pop()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 处理空栈情况</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="错误二单调栈维护错误">错误二：单调栈维护错误</h3>
<p><strong>问题</strong>：单调栈的单调性维护不当，导致结果错误。</p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>明确是单调递增还是单调递减</li>
<li>明确是严格单调还是非严格单调</li>
<li>检查弹出条件是否正确</li>
</ul>
<h3 id="错误三bfs-中忘记标记已访问">错误三：BFS 中忘记标记已访问</h3>
<p><strong>问题</strong>：在 BFS 中，节点可能被重复加入队列。</p>
<p><strong>解决方法</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">visited = <span class="built_in">set</span>()</span><br><span class="line">queue.append(start)</span><br><span class="line">visited.add(start)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">    node = queue.popleft()</span><br><span class="line">    <span class="keyword">for</span> neighbor <span class="keyword">in</span> get_neighbors(node):</span><br><span class="line">        <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.add(neighbor)</span><br><span class="line">            queue.append(neighbor)</span><br></pre></td></tr></table></figure>
<h3 id="错误四优先队列的比较函数错误">错误四：优先队列的比较函数错误</h3>
<p><strong>问题</strong>：在 Python 中使用 <code>heapq</code>
时，默认是最小堆。如果需要最大堆，需要取负数或使用自定义比较。</p>
<p><strong>解决方法</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最小堆（默认）</span></span><br><span class="line">heapq.heappush(heap, val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大堆（取负数）</span></span><br><span class="line">heapq.heappush(heap, -val)</span><br><span class="line">max_val = -heapq.heappop(heap)</span><br></pre></td></tr></table></figure>
<h3 id="调试技巧">调试技巧</h3>
<ol type="1">
<li><strong>打印栈/队列内容</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Stack: <span class="subst">&#123;stack&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Queue: <span class="subst">&#123;<span class="built_in">list</span>(queue)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p><strong>跟踪操作序列</strong>：记录每次 push/pop
操作，验证逻辑正确性</p></li>
<li><p><strong>使用可视化</strong>：对于复杂问题，画出栈/队列的变化过程</p></li>
<li><p><strong>测试边界情况</strong>：</p>
<ul>
<li>空栈/空队列</li>
<li>单个元素</li>
<li>所有元素相同</li>
<li>极端大小</li>
</ul></li>
</ol>
<h2 id="实战建议">实战建议</h2>
<h3 id="如何快速识别栈队列问题">如何快速识别栈/队列问题</h3>
<p>看到以下关键词时，考虑栈或队列：</p>
<ul>
<li><strong>匹配问题</strong>：括号、标签匹配 → 栈</li>
<li><strong>表达式求值</strong>：中缀转后缀、后缀求值 → 栈</li>
<li><strong>层次遍历</strong>：树的层次遍历、图的 BFS → 队列</li>
<li><strong>下一个更大/更小</strong>：下一个更大元素 → 单调栈</li>
<li><strong>滑动窗口最值</strong>：滑动窗口最大值 → 单调队列</li>
<li><strong>Top K</strong>：前 K 个高频元素 → 优先队列</li>
</ul>
<h3 id="选择数据结构的决策树">选择数据结构的决策树</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">问题类型？</span><br><span class="line">├─ 需要后进先出（LIFO）→ 栈</span><br><span class="line">│   ├─ 括号匹配 → 栈</span><br><span class="line">│   ├─ 表达式求值 → 栈</span><br><span class="line">│   └─ 单调栈优化 → 栈</span><br><span class="line">├─ 需要先进先出（FIFO）→ 队列</span><br><span class="line">│   ├─ 层次遍历 → 队列</span><br><span class="line">│   ├─ BFS → 队列</span><br><span class="line">│   └─ 滑动窗口 → 双端队列</span><br><span class="line">└─ 需要优先级 → 优先队列</span><br><span class="line">    ├─ Top K → 堆</span><br><span class="line">    └─ 合并有序序列 → 堆</span><br></pre></td></tr></table></figure>
<h3 id="解题步骤">解题步骤</h3>
<ol type="1">
<li><strong>识别问题类型</strong>：确定需要栈、队列还是其他数据结构</li>
<li><strong>设计数据结构</strong>：确定需要存储什么信息（值、索引、状态等）</li>
<li><strong>设计算法流程</strong>：明确入栈/入队、出栈/出队的时机</li>
<li><strong>处理边界情况</strong>：空栈/空队列、单个元素等</li>
<li><strong>优化</strong>：如果可能，进行时间或空间优化</li>
</ol>
<h3 id="性能优化建议">性能优化建议</h3>
<ol type="1">
<li><p><strong>空间优化</strong>：</p>
<ul>
<li>及时清理不需要的元素</li>
<li>使用索引代替完整对象</li>
<li>复用数据结构空间</li>
</ul></li>
<li><p><strong>时间优化</strong>：</p>
<ul>
<li>使用更高效的数据结构（如 <code>deque</code> 代替
<code>list</code>）</li>
<li>避免不必要的操作</li>
<li>使用单调栈/队列优化查找</li>
</ul></li>
<li><p><strong>代码优化</strong>：</p>
<ul>
<li>合并相似逻辑</li>
<li>使用更简洁的实现方式</li>
</ul></li>
</ol>
<h2 id="总结">总结</h2>
<p>栈和队列是算法中最基础也最重要的数据结构。通过本文的学习，你应该掌握：</p>
<ol type="1">
<li><strong>基础操作</strong>：栈和队列的基本操作和实现</li>
<li><strong>经典应用</strong>：括号匹配、表达式求值、最小栈等</li>
<li><strong>单调栈</strong>：优化"下一个更大/更小元素"类问题</li>
<li><strong>BFS</strong>：用队列实现层次遍历和最短路径</li>
<li><strong>优先队列</strong>：解决 Top K 问题和合并问题</li>
<li><strong>双端队列</strong>：滑动窗口最值问题</li>
<li><strong>相互实现</strong>：栈和队列的相互实现技巧</li>
</ol>
<p>掌握这些知识点后，你就能解决 LeetCode
中大部分涉及栈和队列的题目。记住：多练习，多总结，理解每个数据结构的本质和应用场景，才能在面试中游刃有余。</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    
    
    
    
    
    
    <ul>
        <li>本文标题：LeetCode（八）—— 栈与队列</li>
        <li>本文作者：Chen Kai</li>
        <li>创建时间：2023-08-20 00:00:00</li>
        <li>
            本文链接：https://www.chenk.top/LeetCode%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Leetcode/">#Leetcode</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/LeetCode%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode（六）—— 动态规划入门</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/LeetCode%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LeetCode（五）—— 二分查找</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'p2Cu9MgjoKzo3VmulhNLIusH-gzGzoHsz',
                    appKey: 'QThQHg3c8sVwGpzg9lu8zEG3',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情赞美帅气伟大的ck吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chen Kai';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2026&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chen Kai</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
            </div>
        
        <div class="theme-info info-item">
            <!-- 由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a> -->
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">栈与队列的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88stack"><span class="nav-number">1.1.</span> <span class="nav-text">栈（Stack）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97queue"><span class="nav-number">1.2.</span> <span class="nav-text">队列（Queue）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text">为什么需要栈和队列？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">栈的经典应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7leetcode-20"><span class="nav-number">2.1.</span> <span class="nav-text">有效的括号（LeetCode 20）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%88leetcode-155"><span class="nav-number">2.2.</span> <span class="nav-text">最小栈（LeetCode 155）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BCleetcode-150"><span class="nav-number">2.3.</span> <span class="nav-text">逆波兰表达式求值（LeetCode
150）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6leetcode-739"><span class="nav-number">2.4.</span> <span class="nav-text">每日温度（LeetCode 739）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">单调栈详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-ileetcode-496"><span class="nav-number">3.1.</span> <span class="nav-text">下一个更大元素 I（LeetCode
496）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-iileetcode-503"><span class="nav-number">3.2.</span> <span class="nav-text">下一个更大元素 II（LeetCode
503）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2leetcode-84"><span class="nav-number">3.3.</span> <span class="nav-text">柱状图中最大的矩形（LeetCode
84）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4leetcode-42"><span class="nav-number">3.4.</span> <span class="nav-text">接雨水（LeetCode 42）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E4%B8%8E-bfs"><span class="nav-number">4.</span> <span class="nav-text">队列与 BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bfs-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">4.1.</span> <span class="nav-text">BFS 的基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86leetcode-102"><span class="nav-number">4.2.</span> <span class="nav-text">二叉树的层次遍历（LeetCode
102）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8Fleetcode-200"><span class="nav-number">4.3.</span> <span class="nav-text">岛屿数量（LeetCode 200）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81leetcode-752"><span class="nav-number">4.4.</span> <span class="nav-text">打开转盘锁（LeetCode 752）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86%E5%BA%94%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">优先队列（堆）应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0leetcode-347"><span class="nav-number">5.1.</span> <span class="nav-text">前 K 个高频元素（LeetCode
347）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8leetcode-23"><span class="nav-number">5.2.</span> <span class="nav-text">合并 K 个升序链表（LeetCode
23）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0leetcode-295"><span class="nav-number">5.3.</span> <span class="nav-text">数据流的中位数（LeetCode 295）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">6.</span> <span class="nav-text">双端队列（滑动窗口最大值）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BCleetcode-239"><span class="nav-number">6.1.</span> <span class="nav-text">滑动窗口最大值（LeetCode 239）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number">6.2.</span> <span class="nav-text">滑动窗口最小值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="nav-number">7.</span> <span class="nav-text">栈实现队列 &#x2F; 队列实现栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97leetcode-232"><span class="nav-number">7.1.</span> <span class="nav-text">用栈实现队列（LeetCode 232）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88leetcode-225"><span class="nav-number">7.2.</span> <span class="nav-text">用队列实现栈（LeetCode 225）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">8.</span> <span class="nav-text">时间空间复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E6%93%8D%E4%BD%9C%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">8.1.</span> <span class="nav-text">栈操作复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">8.2.</span> <span class="nav-text">队列操作复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86%E6%93%8D%E4%BD%9C%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">8.3.</span> <span class="nav-text">优先队列（堆）操作复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">8.4.</span> <span class="nav-text">双端队列操作复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E7%BB%93"><span class="nav-number">8.5.</span> <span class="nav-text">常见算法复杂度总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qa-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">❓ Q&amp;A: 栈与队列常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#q1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%A0%88%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%98%9F%E5%88%97"><span class="nav-number">9.1.</span> <span class="nav-text">Q1:
什么时候用栈，什么时候用队列？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q2-%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">9.2.</span> <span class="nav-text">Q2:
单调栈为什么能优化时间复杂度？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q3-python-%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-list-%E5%92%8C-deque"><span class="nav-number">9.3.</span> <span class="nav-text">Q3: Python 中如何选择 list
和 deque？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q4-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%A2%98%E7%9B%AE%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">9.4.</span> <span class="nav-text">Q4:
如何判断一个题目是否可以用单调栈？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q5-bfs-%E5%92%8C-dfs-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">9.5.</span> <span class="nav-text">Q5: BFS 和 DFS 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q6-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E6%99%AE%E9%80%9A%E9%98%9F%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.6.</span> <span class="nav-text">Q6: 优先队列和普通队列的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q7-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%E7%94%A8%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E8%80%8C%E4%B8%8D%E6%98%AF%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">9.7.</span> <span class="nav-text">Q7:
为什么滑动窗口最大值用单调队列而不是优先队列？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q8-%E5%A6%82%E4%BD%95%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92"><span class="nav-number">9.8.</span> <span class="nav-text">Q8: 如何用栈实现递归？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q9-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%B8%A4%E4%B8%AA%E6%A0%88%E9%98%9F%E5%88%97"><span class="nav-number">9.9.</span> <span class="nav-text">Q9: 什么时候需要两个栈&#x2F;队列？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#q10-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%A0%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">9.10.</span> <span class="nav-text">Q10:
如何优化栈&#x2F;队列的空间复杂度？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%8E%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98"><span class="nav-number">10.</span> <span class="nav-text">变体与扩展问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%80%E5%A4%9A%E6%A0%88%E5%A4%9A%E9%98%9F%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-number">10.1.</span> <span class="nav-text">变体一：多栈&#x2F;多队列问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%BA%8C%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E5%8F%98%E7%A7%8D"><span class="nav-number">10.2.</span> <span class="nav-text">变体二：单调栈的变种</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E4%B8%89%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%98%E7%A7%8D"><span class="nav-number">10.3.</span> <span class="nav-text">变体三：优先队列的变种</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">11.</span> <span class="nav-text">常见错误与调试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%80%E6%A0%88%E9%98%9F%E5%88%97%E4%B8%BA%E7%A9%BA%E6%97%B6%E8%AE%BF%E9%97%AE"><span class="nav-number">11.1.</span> <span class="nav-text">错误一：栈&#x2F;队列为空时访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BA%8C%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%B4%E6%8A%A4%E9%94%99%E8%AF%AF"><span class="nav-number">11.2.</span> <span class="nav-text">错误二：单调栈维护错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%B8%89bfs-%E4%B8%AD%E5%BF%98%E8%AE%B0%E6%A0%87%E8%AE%B0%E5%B7%B2%E8%AE%BF%E9%97%AE"><span class="nav-number">11.3.</span> <span class="nav-text">错误三：BFS 中忘记标记已访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%9B%9B%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E9%94%99%E8%AF%AF"><span class="nav-number">11.4.</span> <span class="nav-text">错误四：优先队列的比较函数错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">11.5.</span> <span class="nav-text">调试技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E5%BB%BA%E8%AE%AE"><span class="nav-number">12.</span> <span class="nav-text">实战建议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%AF%86%E5%88%AB%E6%A0%88%E9%98%9F%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-number">12.1.</span> <span class="nav-text">如何快速识别栈&#x2F;队列问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91"><span class="nav-number">12.2.</span> <span class="nav-text">选择数据结构的决策树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="nav-number">12.3.</span> <span class="nav-text">解题步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-number">12.4.</span> <span class="nav-text">性能优化建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">13.</span> <span class="nav-text">总结</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>

<script src="/js/lang-switch.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
